<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【院試対策 | 北海道大学 | 情報科学院 | 情報理工 | コンピュータシステム】走る作曲家のAIカフェ</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <header>
        <h1>走る作曲家のAIカフェ</h1>
        <nav>
            <ul>
                <li><a href="index.html">ホーム</a></li>
                <li><a href="study.html">勉強</a></li>
                <li><a href="music.html">音楽</a></li>
                <li><a href="sports.html">スポーツ</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section>
          <p>「北海道大学大学院情報科学院修士課程入学試験」（令和6年8月実施）の情報理工学コース「<b>コンピュータシステム</b>」対策ページです。</p>
        </section>
        <section>
          <h2>分野別対策</h2>
          <ul>
            <li><a href="gradexam.html">院試対策 ～はじめに～</a></li>
            <li><a href="gradexam_basicmath.html">院試対策 ～基礎数学編～</a></li>
            <li><a href="gradexam_infomath.html">院試対策 ～情報数学編～</a></li>
            <li><a href="gradexam_statistics.html">院試対策 ～確率・統計編～</a></li>
            <li><a href="gradexam_infotheory.html">院試対策 ～情報理論編～</a></li>
            <li><a href="gradexam_algo.html">院試対策 ～アルゴリズムとデータ構造編～</a></li>
            <li><a href="gradexam_ai.html">院試対策 ～人工知能編～</a></li>
            <li><a href="gradexam_cs.html">院試対策 ～コンピュータシステム編～</a></li>
              <li><a href="gradexam_final.html">院試対策 ～最終チェック～</a></li>
          </ul>
        </section>
      <section id="probability-statistics">
        <h2>コンピュータシステム</h2>
        <h3>補数表現</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://www.momoyama-usagi.com/entry/info-calc-sys02">うさぎでもわかる計算機システム　Part02　2の補数表現 [基本情報対応] _ 工業大学生ももやまのうさぎ塾.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <p>2の補数表現を用いて、10進数の"-4"を5ビットの2進数で表せ。</p>
            <p><b>解答</b></p>
            <ol>
              <li>正の数"4"を5ビットの2進数で表すと、\(00100\)である。</li>
              <li>ビットを反転させると、\(11011\)となる。</li>
              <li>この反転した値に1を加えて、\(11100\)を得る。</li>
            </ol>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>10進数の計算85-12を8ビット、2の補数表現で計算した場合の計算過程と結果を示せ。</p>
            <p><b>解答</b></p>
            <ol>
              <li>85を2進数で表すと、01010101である。</li>
              <li>12を2進数で表すと、00001100であり、ビット反転して1を加えると、11110100である。</li>
              <li>01010101と11110100を加算すると、1|01001001となる（|の左にある1は桁あふれ）。</li>
              <li>この結果を10進数に変換すると73であり、オーバーフローが発生せずに正しく計算されていることがわかる。</li>
            </ol>
          </div>
        <div class="example">
            <p><b>問題</b></p>
            <p>補数に関する以下の問に答えよ。</p>
            <ol>
                <li>コンピュータにおいて補数を用いる利点をあげよ。</li>
                <li>負の整数を2の補数で表現するとき、\(n\)ビットの2進数で表現できる整数の範囲を、\(n\)を用いて示せ。</li>
                <li>同様に負の整数を1の補数で表現するときの範囲を示せ。</li>
                <li>1の補数と2の補数の表現できる範囲の違いが生じる理由を記せ。</li>
                <li>補数の考え方からすると、10進数における10の補数、9の補数を考えることが可能である。10進数の42−16の計算を、10の補数を用いて行った場合の計算過程を示せ。桁数は3ケタとする。</li>
            </ol>
            <p><b>(1)の解答</b></p>
            <p>補数を用いる利点として、加算器だけで減算が可能になることが挙げられる。これにより、ハードウェアが簡素化され、計算速度が向上する。また、符号付き整数の表現においても補数は効果的である。</p>
            <p><b>(2)の解答</b></p>
            <p>例として、3ビットの場合（\(n = 3\)）を考える。</p>
            <table>
                <tr>
                    <th>対応する整数</th>
                    <th>二進数</th>
                    <th>対応する整数</th>
                    <th>二進数</th>
                </tr>
                <tr>
                    <td>0</td>
                    <td>000</td>
                    <td>-1</td>
                    <td>111</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>001</td>
                    <td>-2</td>
                    <td>110</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>010</td>
                    <td>-3</td>
                    <td>101</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>011</td>
                    <td>-4</td>
                    <td>100</td>
                </tr>
            </table>
            <p>よって、\(- 2^{n-1}\)から\(2^{n-1} - 1\)まで。</p>
            <p><b>(3)の解答</b></p>
            <p>例として、3ビットの場合（\(n = 3\)）を考える。</p>
            <table>
                <tr>
                    <th>対応する整数</th>
                    <th>二進数</th>
                    <th>対応する整数</th>
                    <th>二進数</th>
                </tr>
                <tr>
                    <td>0</td>
                    <td>000</td>
                    <td>0</td>
                    <td>111</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>001</td>
                    <td>1</td>
                    <td>110</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>010</td>
                    <td>2</td>
                    <td>101</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>011</td>
                    <td>3</td>
                    <td>100</td>
                </tr>
            </table>
            <p>よって、\(- 2^{n-1} + 1\)から\(2^{n-1} - 1\)まで。</p>
            <p><b>(4)の解答</b></p>
            <p>1の補数は、符号を反転させるだけで負の数を表現するため、負のゼロが存在する。しかし、2の補数は負のゼロが存在しないため、その分、表現できる負の数が1つ多くなる。</p>
            <p><b>(5)の解答</b></p>
            <ol>
                <li>16の10の補数を求める：1000 - 016 = 984</li>
                <li>42に984を加える：042 + 984 = 1026</li>
                <li>最後に桁あふれを無視する：1026 → 026</li>
                <li>結果は26である。</li>
            </ol>
          </div>
        </ul>
        <h3>固定小数点・浮動小数点</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://www.momoyama-usagi.com/entry/info-calc-sys03">うさぎでもわかる計算機システム　Part03　固定小数点・浮動小数点 _ 工業大学生ももやまのうさぎ塾.html</a></p>
        <p><a href="https://medium-company.com/%E4%B8%B8%E3%82%81%E8%AA%A4%E5%B7%AE-%E6%89%93%E5%88%87%E3%82%8A%E8%AA%A4%E5%B7%AE-%E6%A1%81%E8%90%BD%E3%81%A1-%E6%83%85%E5%A0%B1%E8%90%BD%E3%81%A1-%E9%81%95%E3%81%84/">丸め誤差、打切り誤差、桁落ち、情報落ちの違い - ITを分かりやすく解説.html</a></p>
        <p><a href="https://medium-company.com/%e6%b5%ae%e5%8b%95%e5%b0%8f%e6%95%b0%e7%82%b9%e6%95%b0/#i-3">浮動小数点数を分かりやすく解説 - ITを分かりやすく解説.html</a></p>
         <p><a href="https://qiita.com/ryuichi1208/items/31442f9e8a7a7c94aeec">[バイトオーダー]ビックエンディアン_リトルエンディアン #Linux - Qiita.html</a></p>
          <ul>
            <li>誤差</li>
            <ul>
                <li><b>丸め誤差</b>：「表現できる数の範囲」（有効桁）を超えてしまった際に有効桁以降を切り捨てることによって発生する誤差。</li>
                <li><b>打ち切り誤差</b>：コンピュータの計算処理を途中で打ち切ることにより発生する誤差。</li>
                <li><b>桁落ち</b>：値がほぼ等しい数値差を求めた時に発生する誤差。</li>
                <li><b>情報落ち</b>：大きい値と小さい値の数値を和もしくは差を求めた時に発生する誤差。</li>
            </ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <p>固定小数点方式と浮動小数点方式について、それぞれどのような数値表現方式か簡潔に記述せよ。</p>
            <p><b>解答</b></p>
            <ol>
              <li><b>固定小数点方式</b>：固定小数点方式は、数値を固定された小数点位置で表現する方式である。
                この方式では、小数点以下の桁数があらかじめ決まっており、整数部と小数部の桁数が固定されている。
                例えば、16ビットの固定小数点数の場合、8ビットを整数部、8ビットを小数部として扱う。
                この方式は、計算が簡単で処理が高速であるが、表現できる数の範囲と精度が限られている。</li>
              <li><b>浮動小数点方式</b>：浮動小数点方式は、数値を仮数部と指数部に分けて表現する方式である。
                この方式では、小数点の位置が仮数部と指数部によって動的に決定されるため、非常に大きい数や非常に小さい数を表現することができる。
                IEEE 754規格が広く使われており、32ビットの単精度と64ビットの倍精度が一般的である。
                浮動小数点方式は、広い範囲の数を表現できる一方で、計算が複雑で丸め誤差が生じることがある。</li>
            </ol>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>浮動小数点数の算術演算における｢丸め誤差｣はどのような場合に生ずるか簡潔に述べよ。</p>
            <p><b>解答</b></p>
            <p>浮動小数点数の算術演算における「丸め誤差」は、有限のビット数で無限小数を表現する際に、元の数値を近似的に表現する必要がある場合に生じる。
            この近似により、演算結果が正確な値から僅かにずれることがあり、これが丸め誤差の原因である。特に、小数点以下の桁数が長い数値や、極端に大きいまたは小さい数値の演算時に顕著に現れることが多い。</p>
          </div>
        　<div class="example">
            <p><b>問題</b></p>
            <p>浮動小数点形式の数値の演算に関する次の記述中の括弧 a～d に入れるべき適切な数値および用語を答えよ。</p>
    
            <p>
                浮動小数点形式で表現された数値の演算では、浮動小数点形式の表現規則により、「(a)」と「(b)」と呼ばれる誤差が発生する。たとえば、仮数部の有効桁数が3桁、指数部の有効桁数が2桁の10進浮動小数点数で、0.123 × 10² + 0.456 × 10⁻²という演算を行う場合、実際には、0.123 × 10² + (c)という演算が行われることになる。このような場合に発生する誤差を「(d)」と呼ぶ。一方、0.789 × 10² - 0.788 × 10²という演算では、演算結果が正規化され(c)となり、有効桁数が減少する。このような有効桁数の減少を「(d)」と呼ぶ。なお、ここでは仮数部の有効桁の先頭が小数第1位に来るように正規化されている。
            </p>
            <p><b>解答</b></p>
            <ul>
                <li>(a) \(0.000 \times 10^2\)</li>
                <li>(b) 情報落ち</li>
                <li>(c) 0.1</li>
                <li>(d) 桁落ち</li>
            </ul>
          </div>
            <div class="example">
                <p><b>問題</b></p>
                <ol>
                    <li>数値表現の浮動小数点方式における正規化とは何か簡潔に記述せよ。</li>
                    <li>ネットワークバイトオーダ（ビッグエンディアン）で複数バイトを送信する場合の規則を簡潔に記述し、16進数の8532AEC7を送信する具体的な順序を示せ。</li>
                </ol>
                <p><b>(1)の解答</b></p>
                <p>正規化とは、小数点の位置を調整し最上位桁を0以外の値にする作業のことである。正規化によって、有効桁数を最大化し丸め誤差を少なくすることができる。</p>
                <p><b>(2)の解答</b></p>
                <p>ネットワークバイトオーダ、別名ビッグエンディアンとは、データをバイト単位で送信する際に、最も重要なバイト（最上位バイト）を最初に送信する形式である。複数バイトから成るデータをネットワークで送信する場合、ビッグエンディアン方式では、データの先頭に最上位バイトが来るように順序付けされる。</p>
                <p>16進数の値8532AEC7は以下の4バイトで構成されている:</p>
                <ul>
                    <li>85</li>
                    <li>32</li>
                    <li>AE</li>
                    <li>C7</li>
                </ul>
                <p>ビッグエンディアン方式では、この順序そのままにバイトが送信される。したがって、送信される具体的な順序は以下の通りである:</p>
                <ul>
                    <p>送信順序: 85 32 AE C7</p>
                </ul>
                <p>ちなみに、リトルエンディアン方式における送信順序は、「C7, AE, 32, 85」となる。</p>
            </div>
        </ul>
        <h3>フォン・ノイマン・ボトルネック</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://e-words.jp/w/%E3%83%8E%E3%82%A4%E3%83%9E%E3%83%B3%E5%9E%8B%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF.html">ノイマン型コンピュータ（ストアードプログラム方式 _ プログラム内蔵方式）とは - 意味をわかりやすく - IT用語辞典 e-Words.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <ol>
                <li>フォン・ノイマン・ボトルネックとはどのようなものか簡潔に述べよ。</li>
                <li>フォン・ノイマン・ボトルネックの解消に有効な技術の一つとしてキャッシュメモリがある。
                キャッシュメモリに関して述べた以下の文中の空欄Ⅰ〜Ⅳに当てはまる最も適切な語句を(a)〜(h)から選択し、解答用紙にそれぞれ対応付けて示せ。（例：Ⅰ:(a)）
                <p>「キャッシュメモリはメインメモリと比べてその容量は[ ]Ⅰ が、そのアクセス速度は[ ]Ⅱ である。
                    キャッシュメモリを有効に活用するためには、メモリアクセスの[ ]Ⅲ を高めることが重要である。
                    例えば、大きな配列を走査する場合は、各要素へのアクセスをメモリ上で連続化することで、メモリアクセスの[ ]Ⅳ [ ]Ⅲ を高めることができる。」</p>
                    <ul>
                        <li>(a) 大きい</li>
                        <li>(b) 小さい</li>
                        <li>(c) 高速</li>
                        <li>(d) 低速</li>
                        <li>(e) 汎用性</li>
                        <li>(f) 局所性</li>
                        <li>(g) 時間的</li>
                        <li>(h) 空間的</li>
                    </ul>
                </li>
                <li>キャッシュメモリのヒット率h(0 ≦ h ≦ 1)、そのアクセス時間をtとし、メインメモリへのアクセス時間をtmとするとき、メインメモリへの実効アクセス時間teを、t, tm, hにより表せ。
                また、tm = 10t である場合のヒット率hと実効アクセス時間teの関係を表すグラフの概形（横軸をh、縦軸をteとする）を解答用紙に図示せよ。</li>
                <li>キャッシュメモリの代表的なデータ格納構造として、ダイレクトマップ方式とセットアソシアティブ方式がある。
                今、幅32ビットのアドレスで管理されるメインメモリに対して、ダイレクトマップ方式を用いたキャッシュメモリを設計したとき、タグのビット数が16ビットとなった。
                キャッシュメモリの容量を増加させる場合（キャッシュブロックのサイズを変更せずに）、データ格納構造を4ウェイのセットアソシアティブ方式に変更した場合、タグのビット数はいくつになるか、その理由とともに述べよ。</li>
            </ol>
            <p><b>解答</b></p>
            <ol>
              <li>フォン・ノイマン・ボトルネックとは、コンピュータの中央処理装置(CPU)とメモリ間のデータ転送速度が、CPUの処理速度に比べて低速であるために、システム全体の性能が制約される問題である。</li>
              <li>「キャッシュメモリはメインメモリと比べてその容量は<b>Ⅰ:(b) 小さい</b>が、そのアクセス速度は<b>Ⅱ:(c) 高速</b>である。
                キャッシュメモリを有効に活用するためには、メモリアクセスの<b>Ⅲ:(f) 局所性</b>を高めることが重要である。
                例えば、大きな配列を走査する場合は、各要素へのアクセスをメモリ上で連続化することで、メモリアクセスの<b>Ⅳ:(h) 空間的</b><b>Ⅲ:(f) 局所性</b>を高めることができる。」</li>
              <li>
                  <ul>
                      <li>実効アクセス時間 \( t_e \) は、キャッシュメモリのヒット率 \( h \) を用いて次の式で表される：</li>
                      <li>\( t_e = h \cdot t + (1 - h) \cdot t_m \)</li>
                      <li>ここで、\( t_m = 10t \) である場合、実効アクセス時間は以下のように表される：</li>
                      <li>\( t_e = t(10 - 9h) \)</li>
                      <li>この関係をグラフに表すと、横軸をヒット率 \( h \)、縦軸を実効アクセス時間 \( t_e \) とした場合、ヒット率 \( h \) が 0 から 1 に増加するにつれて、実効アクセス時間 \( t_e \) は直線的に減少する。</li>
                  </ul>
              </li>
              <li>
                  <ul>
                      <li>幅32ビットのアドレスに対して、ダイレクトマップ方式を用いた場合、キャッシュメモリのタグビット数が16ビットであるとき、キャッシュインデックスは16ビット（32ビットのアドレスからタグビットとブロックオフセットビットを引いたもの）で構成されている。</li>
                      <li>キャッシュメモリの容量を増加させるために、4ウェイのセットアソシアティブ方式に変更すると、キャッシュインデックスのビット数は減少し、その分タグビット数が増加する。具体的には、4ウェイセットアソシアティブ方式ではキャッシュインデックスが2ビット減少し、その分タグビットが18ビットに増加する。</li>
                  </ul>
              </li>
            
            </ol>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>10進数の計算85-12を8ビット、2の補数表現で計算した場合の計算過程と結果を示せ。</p>
            <p><b>解答</b></p>
            <ol>
              <li>85を2進数で表すと、01010101である。</li>
              <li>12を2進数で表すと、00001100であり、ビット反転して1を加えると、11110100である。</li>
              <li>01010101と11110100を加算すると、1|01001001となる（|の左にある1は桁あふれ）。</li>
              <li>この結果を10進数に変換すると73であり、オーバーフローが発生せずに正しく計算されていることがわかる。</li>
            </ol>
          </div>
        </ul>
        <h3>キャッシュメモリ</h3>
        <p>参考にした書籍・サイトは以下のとおり。</p>
          <p><a href="https://www.amazon.co.jp/%E4%BB%A4%E5%92%8C06%E5%B9%B4%E3%80%90%E6%98%A5%E6%9C%9F%E3%80%91%E3%80%90%E7%A7%8B%E6%9C%9F%E3%80%91-%E5%BF%9C%E7%94%A8%E6%83%85%E5%A0%B1%E6%8A%80%E8%A1%93%E8%80%85-%E5%90%88%E6%A0%BC%E6%95%99%E6%9C%AC-%E5%A4%A7%E6%BB%9D-%E3%81%BF%E3%82%84%E5%AD%90/dp/4297138654/ref=sr_1_1_sspa?adgrpid=150605272950&dib=eyJ2IjoiMSJ9.S5cWzjFkp_nrIqu_5ApE1QWMXCbFLFmwkG8mbhI-YBh4T0pbirPKpWiVtbv7TQ4Vyyf8_N8-tgy_OInBZ68fif15QmWUr69nJIbVclCOHUJ-w90GQURndbGISfc55NDmfWz92sgNct-xzXTWB-hIBlqcIjCPZNK1XI6rbQvxsL6q1n9CHEtizf2OgL__nNze8sDGqR0Bo_s1fEtUKuvc8wkRAGFAIHUZaRrtfu1VPa0.hzxEdIOow2NBUwzQYUtYcoXPOgRX4_TsYf832Qx1J3k&dib_tag=se&hvadid=679063608944&hvdev=c&hvqmt=e&hvtargid=kwd-1992164082181&hydadcr=4074_13378684&jp-ad-ap=0&keywords=%E5%BF%9C%E7%94%A8%E6%83%85%E5%A0%B1%E6%8A%80%E8%A1%93%E8%80%85%E8%A9%A6%E9%A8%93+%E5%8F%82%E8%80%83%E6%9B%B8&qid=1723515043&s=books&sr=1-1-spons&sp_csd=d2lkZ2V0TmFtZT1zcF9hdGY&psc=1">令和06年【春期】【秋期】 応用情報技術者 合格教本</a></p>
          <p><a href="https://ascend-beyond.com/study/3183/#toc27">【応用情報_超分かりやすい】ダイレクトマッピング_フルアソシアティブ_セットアソシアティブ【新感覚Sutdy】.html</a></p>
        <p><a href="https://medium-company.com/%e3%82%bb%e3%83%83%e3%83%88%e3%82%a2%e3%82%bd%e3%82%b7%e3%82%a2%e3%83%86%e3%82%a3%e3%83%96%e6%96%b9%e5%bc%8f/">セットアソシアティブ方式とは - ITを分かりやすく解説.html</a></p>
        <p><a href="https://e-words.jp/w/%E3%82%BB%E3%83%83%E3%83%88%E3%82%A2%E3%82%BD%E3%82%B7%E3%82%A2%E3%83%86%E3%82%A3%E3%83%96%E6%96%B9%E5%BC%8F.html">セットアソシアティブ方式とは - 意味をわかりやすく - IT用語辞典 e-Words.html</a></p>
        <p><a href="https://e-words.jp/w/%E3%82%B9%E3%83%A9%E3%83%83%E3%82%B7%E3%83%B3%E3%82%B0.html">スラッシングとは - 意味をわかりやすく - IT用語辞典 e-Words.html</a></p>
        <ul>
            <li>仮想記憶方式</li>
            <ul>
                <li><b>ページング方式</b>：プログラムをページという固定長の単位に分割し、ページ単位でアドレス変換を行う。実行に必要なページのみ主記憶に読み込むため、主記憶の有効活用やフラグメンテーション問題の解決が期待できる。</li>
                <li><b>セグメンテーション方式</b>：プログラムをセグメントという論理的な単位（大きさは可変）に分割し、セグメント単位でアドレス変換を行う。ページング方式と組み合わせた方式もあり、これを<b>セグメンテーションページング方式</b>という。</li>
            </ul>
            <li>スラッシング</li>
            <ul>
                <li>仮想記憶システムでは、プログラムの多重度が高く、各プログラムへの割り当て主記憶容量が小さかったり、適切なページ置き換え方法が取られなかったりすると、ページングが発生する。ページング（ページイン/ページアウト）の実行優先度はプログラムよりも高いため、ページングが多発すると、プログラムに割り当てられるCPU時間が少なくなる。これにより処理速度（レスポンス）が極端に悪くなり、システム全体のスループットが急激に低下するという現象が発生する。この現象を<b>スラッシング</b>という。</li>
            </ul>
            <li>キャッシュメモリの割り付け方式</li>
            <ul>
                <li><b>ダイレクトマップ方式</b>：主記憶のブロック番号から、キャッシュメモリでのブロック番号が一意に定まる方式。具体的には、主記憶上のブロック番号にハッシュ演算を行い、一意に対応するキャッシュメモリのブロック番号を算出する。</li>
                <li><b>フルアソシアティブ方式</b>：主記憶のブロックがどのキャッシュブロックにも対応付けられる方式。ダイレクトマップ方式と異なり、最初に書きこもうとしたブロックがふさがっていても、空いているブロックに書けるため、ヒット率が向上する。しかし、主記憶のどのブロック内容がキャッシュのどのブロックに格納されているのか、すべて記憶しておく必要があり、検索にも時間がかかる。</li>
                <li><b>セットアソシアティブ方式</b>：ダイレクトマップ方式とフルアソシアティブ方式の中間に位置する方式。具体的には、連続したキャッシュブロックをセットとしてまとめ、そのセットの中であればどのブロックでも格納できる方式である。</li>
            </ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <ol>
              <li>キャッシュメモリはキャッシュライン（キャッシュブロック）を単位として管理される。
              キャッシュメモリのデータ格納構造としてよく用いられるセットアソシアティブ方式とはどのような方式か。</li>
              <li>同じく、キャッシュメモリのデータ格納構造である、ダイレクトマップ方式とフルアソシアティブについて、両者の違いが分かるように説明せよ。</li>
              <li>キャッシュメモリのスラッシングとはどのような現象か。アプリケーションが受ける影響を含めて説明せよ。</li>
            </ol>
            <p><b>(1)の解答</b></p>
            <p>セットアソシアティブ方式は、キャッシュメモリを複数のセットに分割し、各セット内でデータを複数のキャッシュラインに柔軟に格納できる方式であり、ダイレクトマップ方式とフルアソシアティブ方式の中間的な特性を持つ。</p>
            <p><b>(2)の解答</b></p>
              <p>ダイレクトマップ方式では、キャッシュメモリの各ブロックがメインメモリの特定のアドレス範囲と1対1で対応する。つまり、メインメモリのあるブロックは、キャッシュメモリの特定の1つのブロックにのみ格納される。この方式では、キャッシュのブロック番号はメインメモリのアドレスによって直接決まるため、データの検索や格納が高速だ。しかし、異なるメモリアドレスが同じキャッシュブロックを使う場合には競合が発生し、キャッシュの効果が減少することがある。</p>
              <p>フルアソシアティブ方式では、メインメモリの任意のデータブロックをキャッシュメモリの任意のブロックに格納できる。この方式では、メインメモリのどのアドレスのデータもキャッシュのどのブロックにも格納可能で、データの格納場所に制約がない。そのため、キャッシュミスが発生する可能性が低く、スラッシングのリスクも少ない。ただし、フルアソシアティブ方式では、データをキャッシュ内で検索する際に全ブロックを確認する必要があり、ハードウェア的な複雑さと検索時間の増加が課題となる。</p>
            <p><b>(3)の解答</b></p>
            <p>キャッシュメモリのスラッシング（cache thrashing）とは、CPUがアクセスするメモリブロックが頻繁にキャッシュ内で置き換えられる現象である。この現象は、特定のアクセスパターンによって、キャッシュの一部にメモリブロックが集中して配置されるために発生する。スラッシングが発生すると、キャッシュミスが増加し、キャッシュの利点である高速なデータアクセスが失われ、結果としてシステムのパフォーマンスが大幅に低下する。アプリケーションにとっては、処理速度が遅くなる、レスポンスが悪化するなどの悪影響を受ける可能性がある。</p>
        </ul>
        <h3>プロセッサ</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://www.momoyama-usagi.com/entry/info-calc-sys17">うさぎでもわかる計算機システム（基本情報対応）　Part17　割込み（外部割込み・内部割込みの違い）・バッファ _ 工業大学生ももやまのうさぎ塾.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <p>プロセッサの実行モードである特権モードと非特権モードの違いについて、簡潔に述べよ。</p>
            <p><b>解答</b></p>
            <p>特権モードとは、プロセッサがシステム全体の制御を行うために特別な権限を持つ実行モードであり、OSカーネルやドライバなどが動作する。
                一方、非特権モードは、ユーザープログラムが動作するモードであり、システムリソースへの直接アクセスや重要な操作が制限されている。
                これにより、システムの安全性と安定性が保たれる。</p>
        </ul>
        <h3>IPアドレス</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://www.momoyama-usagi.com/entry/info-calc-sys02">うさぎでもわかる計算機システム　Part02　2の補数表現 [基本情報対応] _ 工業大学生ももやまのうさぎ塾.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <p>IPネットワークのあるサブネットに接続されたホストAを考える。ホストAのIPアドレスとサブネットマスクは10進ドット記法で以下に示す通りである。</p>
            <p>IPアドレス：10.1.4.139、サブネットマスク：255.255.255.192</p>
            <p>このとき、以下の問いに答えよ。</p>
            <ol>
              <li>このサブネットのブロードキャストアドレスの下位8ビットを16進数で表せ。</li>
              <li>このサブネットにはホストAを含めて最大何台のホスト（ルータも含む）が接続できるか求めよ。</li>
              <li>このサブネットを同じ大きさの4つのサブネットにさらに分割することを考える。
              このとき、分割で得られる4つのサブネットのネットワークアドレスを求め、それぞれ10進ドット記法で記せ。</li>
            </ol>
            <p><b>(1)の解答</b></p>
            <ol>
              <li>サブネットマスクについて、192を２進数で表すと11000000であるから、CIDR表記だと"/26"になる。</li>
              <li>したがって、ホスト部は6ビットである。</li>
              <li>IPアドレスの下位8ビットは、139を２進数で表すことで10001011とわかる。</li>
              <li>この8ビットのうち、ホスト部（後ろ6ビット）をすべて1に書き換えると、10111111となり、16進数でBFである。</li>
            </ol>
            <p><b>(2)の解答</b></p>
            <ol>
              <li>ホスト部の6ビットで表現できるのは、\(2^6 = 64\)アドレスである。</li>
              <li>ネットワークアドレス、ブロードキャストアドレスの2アドレスを除いて62アドレスをホストに割り当てることができる。</li>
            </ol>
            <p><b>(3)の解答</b></p>
            <ol>
              <li>サブネットを4つに分割する場合、\(4 = 2^2\)より、さらに2ビットをホスト部からネットワーク部として流用することになる。</li>
              <li>元のIPアドレスは10.1.4.10001011であり、ホスト部は6ビット、ネットワーク部は26ビットだった。</li>
              <li>したがって、分割を行うとホスト部は4ビットに、ネットワーク部は28ビットになる。</li>
              <li>ネットワークアドレスを求めたいので、ホスト部をすべて0にすると、10.1.4.1000|0000である。（"|"はネットワーク部とホスト部の境界を示す。）</li>
              <li>流用する2ビットで表現可能な値は、00, 01, 10, 11の4種類であり、これをネットワーク部の下位2ビット（流用した部分）とすればよい。</li>
              <li>以上より、得られる4つのサブネットのネットワークアドレスは次の通りである。</li>
              <ul>
                <li>10.1.4.10<b>00</b>0000 → 10.1.4.128</li>
                <li>10.1.4.10<b>01</b>0000 → 10.1.4.144</li>
                <li>10.1.4.10<b>10</b>0000 → 10.1.4.160</li>
                <li>10.1.4.10<b>11</b>0000 → 10.1.4.176</li>
              </ul>
            </ol>
          </div>
          <div class="example">
              <p><b>問題</b></p>
              <p>IPネットワークのあるサブネットに接続されたホストAを考える。ホストAのIPアドレスとサブネットマスクは10進ドット記法で以下に示す通りである。</p>
              <p>IPアドレス：172.16.2.181、サブネットマスク：255.255.255.248</p>
              <p>このとき、以下の問いに答えよ。</p>
              <ol>
                  <li>端末AのIPアドレスとサブネットマスクのそれぞれ下位8ビットを2進数で表せ。</li>
                  <li>端末Aが接続しているサブネットのネットワークアドレスとブロードキャストアドレスを求め、それぞれ10進ドット記法で示せ。</li>
                  <li>端末Aのサブネットを拡張し、以下に示すIPアドレスを有する端末B、Cが端末Aと同じサブネットに含まれるようにするためには、サブネットマスクをどのように設定すればよいか。(端末B: 172.16.2.185、端末C: 172.16.2.174)</li>
              </ol>
              <p><b>(1)の解答</b></p>
              <ol>
                  <li>IPアドレスの下位8ビット: 181 → 2進数で表すと"10110101"</li>
                  <li>サブネットマスクの下位8ビット: 248 → 2進数で表すと"11111000"</li>
              </ol>
              <p><b>(2)の解答</b></p>
              <p>まず、ネットワークアドレスを求める。</p>
              <ol>
                  <li>10110101 AND 11111000 = 10110000 (下位8ビット)</li>
                  <li>上位24ビットはそのままなので、172.16.2.176 となる。</li>
              </ol>
              <p>次に、ブロードキャストアドレスを求める。</p>
              <ol>
                  <li>ネットワークアドレスのホスト部のすべてのビットを1にしたものがブロードキャストアドレスである。</li>
                  <li>下位8ビット: 10111111 (ブロードキャストアドレス)</li>
                  <li>上位24ビットはそのままなので、172.16.2.183 となる。</li>
              </ol>
              <p><b>(3)の解答</b></p>
              <ol>
                  <li>マスク長は元々29である。</li>
                  <li>これを27に変更すれば、10100000～10111111の範囲、つまり、172.16.2.160～172.16.2.191の範囲をカバーすることができる。</li>
                  <li>したがって、求めるサブネットマスクは255.255.255.224であり、ネットワークアドレスは172.16.2.160である。</li>
              </ol>
          </div>
        </ul>
        <h3>OSスケジューラ</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://www.momoyama-usagi.com/entry/info-calc-sys18">うさぎでもわかる計算機システム（基本情報対応）　Part18　プロセスの3状態・スケジューリングアルゴリズム _ 工業大学生ももやまのうさぎ塾.html</a></p>
        <p>参考にした本は以下のとおり。</p>
        <p><a href="https://www.amazon.co.jp/%E4%BB%A4%E5%92%8C06%E5%B9%B4%E3%80%90%E6%98%A5%E6%9C%9F%E3%80%91%E3%80%90%E7%A7%8B%E6%9C%9F%E3%80%91-%E5%BF%9C%E7%94%A8%E6%83%85%E5%A0%B1%E6%8A%80%E8%A1%93%E8%80%85-%E5%90%88%E6%A0%BC%E6%95%99%E6%9C%AC-%E5%A4%A7%E6%BB%9D-%E3%81%BF%E3%82%84%E5%AD%90/dp/4297138654/ref=sr_1_1_sspa?adgrpid=150605272950&dib=eyJ2IjoiMSJ9.S5cWzjFkp_nrIqu_5ApE1QWMXCbFLFmwkG8mbhI-YBh4T0pbirPKpWiVtbv7TQ4Vyyf8_N8-tgy_OInBZ68fif15QmWUr69nJIbVclCOHUJ-w90GQURndbGISfc55NDmfWz92sgNct-xzXTWB-hIBlqcIjCPZNK1XI6rbQvxsL6q1n9CHEtizf2OgL__nNze8sDGqR0Bo_s1fEtUKuvc8wkRAGFAIHUZaRrtfu1VPa0.hzxEdIOow2NBUwzQYUtYcoXPOgRX4_TsYf832Qx1J3k&dib_tag=se&hvadid=679063608944&hvdev=c&hvqmt=e&hvtargid=kwd-1992164082181&hydadcr=4074_13378684&jp-ad-ap=0&keywords=%E5%BF%9C%E7%94%A8%E6%83%85%E5%A0%B1%E6%8A%80%E8%A1%93%E8%80%85%E8%A9%A6%E9%A8%93+%E5%8F%82%E8%80%83%E6%9B%B8&qid=1723515043&s=books&sr=1-1-spons&sp_csd=d2lkZ2V0TmFtZT1zcF9hdGY&psc=1">令和06年【春期】【秋期】 応用情報技術者 合格教本</a></p>
        <ul>
            <li><b>プリエンプション</b>：実行中のタスクのCPU使用権を奪い、実行を一時的に中断させる動作のこと。</li>
            <li><b>オーバーヘッド</b>：コンピュータシステムやソフトウェアが特定の機能を実行するために必要な追加の処理やリソースのこと。タスクの切り替えに要する時間やコストなど。</li>
            <li><b>タスクのスケジューリング方式</b></li>
            <ul>
                <li><b>到着順方式(First Come First Served)</b>：タスクには優先度をもたせず、実行可能になった順に実行し、タスクの実行が終了するまでプリエンプションは発生しない。</li>
                <li><b>優先順位方式</b>：各タスクに与えた優先度の高い順に実行する方式。
                    この方式では、現在実行しているタスクよりも高い優先度を持つタスクが実行可能状態になると、タスクの実行はプリエンプションされる。
                    優先順位方式のうち、タスクの優先度をあらかじめ決めた値から変えない方式を<b>静的優先順位方式</b>という。
                    この方式では、優先度が固定化されるため、優先度の低いタスクにはCPU使用権が与えられず、なかなか実行できないという<b>スタベーション(starvation)</b>が起こる可能性がある。
                    このスタベーションを回避するため、待ち時間が一定時間以上となったタスクの優先度を動的に高くして、実行できるようにした方式が<b>動的優先度順方式</b>である。
                    優先度を高くして実行の可能性を与えることを<b>エージング(aging)</b>ということから、<b>エージング方式</b>とも呼ばれる。
                </li>
                <li><b>ラウンドロビン方式</b>：実行可能待ち行列の先頭のタスクから順にCPU時間（<b>タイムクォンタム</b>）を割り当て、そのタスクがタイムクォンタム内に終了しない場合は、実行を中断して実行可能待ち行列の末尾に移し、次のタスクにCPUを割り当てる、ということを繰り返す方式。
                    実行可能待ち行列にあるタスクを平等に実行できるため、<b>タイムシェアリングシステム(TSS: Time Sharing System)</b>のスケジューリングに適している。
                    タイムクォンタムを長くすれば到着順方式に近づき、短くすれば処理時間が短いタスクの応答時間が短くなるため、結果として処理時間順方式に近づく。
                </li>
                <li><b>フィードバック待ち行列方式</b>：ラウンドロビン方式に優先度を加えた方式であり、言い換えれば、多段のラウンドロビン方式である。
                    優先度ごとにタイムクォンタムが異なる待ち行列をもつため、<b>多重待ち行列方式</b>とも呼ばれる。
                    この方式では、最初に最も高い優先度を割り当て、処理が終了しない場合は、順次その優先度を低くしていく。
                    これはCPUを占有しやすいタスクの優先度を徐々に下げるという考えだが、これによりスタベーション問題が発生するため、エージング手法などを用いての対応が必要となる。
                </li>
                <li><b>処理時間順方式(Shortest Processing Time First)</b>：処理時間の短いタスクから順に実行する方式。
                    ただし、処理時間を前もって予測できないため、実際にはフィードバック待ち行列方式として実現される。
                </li>
            </ul>
            <li><b>ターンアラウンド時間</b>：ジョブの到着から完了までにかかる総時間</li>
            <li><b>レスポンス時間</b>：ジョブの到着から最初に処理が開始されるまでの時間</li>
            <li>具体例</li>
            <div class="example">
            <p><b>問題</b></p>
            <p>下記の3つのOSスケジューラに関する以下の問いに答えよ。</p>
            <ol>
              <li>First Come, First Served (FCFS)</li>
              <li>Shortest Job First (SJF)</li>
              <li>Round-Robin (RR)</li>
            </ol>
            <p>(1) 表1の到着時刻および処理時間のジョブを実行する場合のスケジューリング結果をそれぞれ図示せよ。
              なお、FCFS及びSJFはノンプリエンプティブ、RRはプリエンプティブなスケジューラとし、ジョブ切り替えに伴うオーバーヘッドは無視できるものとする。
              また、RRのタイムクォンタムは3とする。</p>
            <table>
            <tr>
                <th>ジョブ</th>
                <th>到着時刻</th>
                <th>処理に要する時間</th>
            </tr>
            <tr>
                <td>A</td>
                <td>0</td>
                <td>12</td>
            </tr>
            <tr>
                <td>B</td>
                <td>1</td>
                <td>6</td>
            </tr>
            <tr>
                <td>C</td>
                <td>2</td>
                <td>3</td>
            </tr>
            </table>
            <p>(2) それぞれのスケジューラにおける平均ターンアラウンド時間及び平均レスポンス時間を計算して示せ。計算過程についても記述せよ。</p>
            <p>(3) 現実のOSスケジューリングでは、優先度付きのスケジューリングが広く用いられる。
            優先度付きのスケジューリングにおいて、スタベーション（飢餓状態）の問題はどのような場合に発生するか、またその解決案も簡潔に記述せよ。</p>
            <p><b>(1)の解答</b></p>
            <p>a) FCFS</p>
            <ul>
                <li>0-12 : A(12/12)</li>
                <li>12-18 : B(6/6)</li>
                <li>18-21 : C(3/3)</li>
            </ul>
            <p>b) SJF</p>
            <ul>
                <li>0-12 : A(12/12)</li>
                <li>12-15 : C(3/3)</li>
                <li>15-21 : B(6/6)</li>
            </ul>
            <p>c) RR</p>
            <ul>
                <li>0-3 : A(3/12)</li>
                <li>3-6 : B(3/6)</li>
                <li>6-9 : C(3/3)</li>
                <li>9-12 : A(6/12)</li>
                <li>12-15 : B(6/6)</li>
                <li>15-21 : A(12/12)</li>
            </ul>
            <p><b>(2)の解答</b></p>
            <p>a) FCFS</p>
            <ul>
                <li>各ターンアラウンド時間 A : \(12-0=12\), B : \(18-1=17\), C : \(21-2=19\)</li>
                <li>平均ターンアラウンド時間 \(\frac{12+17+19}{3} = 16\)</li>
                <li>各レスポンス時間 A : \(0-0=0\), B : \(12-1=11\), C : \(18-2=16\)</li>
                <li>平均レスポンス時間 \(\frac{0+11+16}{3} = 9\)</li>
            </ul>
            <p>b) SJF</p>
            <ul>
                <li>各ターンアラウンド時間 A : \(12-0=12\), B : \(21-1=20\), C : \(15-2=13\)</li>
                <li>平均ターンアラウンド時間 \(\frac{12+20+13}{3} = 15\)</li>
                <li>各レスポンス時間 A : \(0-0=0\), B : \(15-1=14\), C : \(12-2=10\)</li>
                <li>平均レスポンス時間 \(\frac{0+14+10}{3} = 8\)</li>
            </ul>
            <p>c) RR</p>
            <ul>
                <li>各ターンアラウンド時間 A : \(21-0=21\), B : \(15-1=14\), C : \(9-2=7\)</li>
                <li>平均ターンアラウンド時間 \(\frac{21+14+7}{3} = 14\)</li>
                <li>各レスポンス時間 A : \(0-0=0\), B : \(3-1=2\), C : \(6-2=4\)</li>
                <li>平均レスポンス時間 \(\frac{0+2+4}{3} = 2\)</li>
            </ul>
            <p><b>(3)の解答</b></p>
            <p>スタベーションは、低優先度のプロセスが実行されず、無限に待たされる場合に発生する。
                これは、システムが常に高優先度のプロセスを実行し続けることで、低優先度のプロセスにCPU時間が割り当てられないためである。
                この問題の解決策としては、エイジング（aging）が有効である。
                エイジングとは、時間の経過とともに待機しているプロセスの優先度を徐々に引き上げる方法であり、
                これにより低優先度のプロセスも一定の時間が経過すれば実行されるようになり、スタベーションを防ぐことができる。</p>
            </div>
            <div class="example">
            <p><b>問題</b></p>
            <p>プロセスのターンアラウンドタイムに及ぼすタイムクォンタムの効果について、プロセスの処理時間と関連付けて簡潔に説明せよ。</p>
            <p><b>解答</b></p>
            <p>プロセスのターンアラウンドタイムは、プロセスがシステムに投入されてから全ての処理が完了するまでの時間を指す。タイムクォンタムは、プロセススケジューリングにおいて、各プロセスがCPUを連続して使用できる最大時間を決定するパラメータである。
                タイムクォンタムが短すぎると、プロセスが頻繁にコンテキストスイッチされ、オーバーヘッドが増加し、ターンアラウンドタイムが長くなる可能性がある。一方、タイムクォンタムが長すぎると、短い処理時間を持つプロセスが長時間待たされる可能性があり、これもターンアラウンドタイムを悪化させる原因となる。
                したがって、適切なタイムクォンタムを選定することが重要であり、プロセスの処理時間とのバランスが求められる。プロセスの平均処理時間に近いタイムクォンタムを設定することで、ターンアラウンドタイムを最適化することができる。</p>
            </div>
        </ul>
        <h3>論理回路</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://www.momoyama-usagi.com/entry/info-karnaugh-map">うさぎでもわかる論理回路　カルノー図編 _ 工業大学生ももやまのうさぎ塾.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <p>論理式 <strong>Q = A'BC' + A'B'C + ABC' + BC</strong> のカルノー図を回答用紙に図示し、それを用いて簡単化した論理式を示せ。</p>
            <p><b>解答</b></p>
            <table>
                <tr>
                    <th colspan="2"></th>
                    <th colspan="4">BC</th>
                </tr>
                <tr>
                    <th colspan="2"></th>
                    <td>00</td>
                    <td>01</td>
                    <td>11</td>
                    <td>10</td>
                </tr>
                <tr>
                    <th rowspan="2">A</th>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                    <td>1</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                    <td>1</td>
                </tr>
            </table>
            <p>したがって、Q = B + A'Cを得る。</p>
          </div>
        </ul>
        <h3>ページング方式</h3>
        <p>参考にしたサイトは以下のとおり。</p>
          <p><a href="https://e-words.jp/w/%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%95%E3%82%A9%E3%83%BC%E3%83%AB%E3%83%88.html">ページフォールトとは - 意味をわかりやすく - IT用語辞典 e-Words.html</a></p>
          <p><a href="https://www.momoyama-usagi.com/entry/info-arc-paging">ページング（ページフォルト・LRUアルゴリズム）について（基本情報・応用情報） _ 工業大学生ももやまのうさぎ塾.html</a></p>
        <p><a href="https://www.momoyama-usagi.com/entry/info-calc-sys19">うさぎでもわかる計算機システム（基本情報対応）　Part19　仮想記憶とページング（4GBの壁の正体は？） _ 工業大学生ももやまのうさぎ塾.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <p>ページング方式によるメモリ管理及び仮想記憶に関する以下の問いに答えよ。</p>
            <ol>
                <li>ページフォルトとはどのような現象か，括弧内の語句を用いて簡潔に述べよ。</li>
                <li>ページサイズを拡大することにより生ずる利点と欠点について簡潔に述べよ。</li>
            </ol>
            <p><b>(1)の解答</b></p>
            <p>ページフォールトとは、プログラムがアクセスしようとしたメモリページが物理メモリ上に存在しないため、オペレーティングシステムがディスクからそのページを読み込む必要がある状況、または、その割込みを指す。
            ページフォールトが発生した場合、オペレーティングシステムは直ちに、物理メモリ上のページから一定の基準（最後にアクセスされてからの経過時間など）で一つを選び、ストレージ上に退避している要求ページと入れ替える処理（スワップ）を行って、プロセスがそのページにアクセスできるようにする。</p>
            <p><b>(2)の解答</b></p>
            <p>大きなサイズのページを管理できるため、ページ数を少なくでき、管理情報に使うメモリサイズを削減できる。
            また、管理情報の検索にかかる時間の削減が可能である。
            しかし、無駄に大きなページになって何も入らない場所が増えるため、ページイン、ページアウトするときにディスクアクセス量が大きくなって時間がかかり、レスポンスが低下する。</p>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>物理アドレス空間 8Mバイトの小規模な主記憶装置と十分な容量の補助記憶装置を用いて，仮想アドレス空間 4G バイトのページング方式の仮想記憶を実現することを考える。
                ただしページサイズは 4K バイトとし，アドレスはバイト単位に割り当てるものとする。また，\(1G = 2^{30}，1M = 2^{20}，1K = 2^{10}\) である。このとき以下の設問に答えよ。</p>
            <ol>
                <li>仮想アドレスと物理アドレスのビット幅はそれぞれ何ビットか。</li>
                <li>仮想記憶を1段ページングで実現すると仮定し，ページテーブルのエントリ1つ当たりの大きさを2バイトとするとき，ページテーブル全体の大きさは何バイトになるか。</li>
                <li>アドレス空間やページサイズは変更せずに，主記憶上に置かれるページテーブルの領域を小さく抑えるためにはどのような方法が考えられるか。その方法の短所も含めて簡潔に説明せよ。</li>
                <li>ページング方式の仮想記憶におけるスラッシングとは何か。簡潔に説明せよ。</li>
            </ol>
            <p><b>(1)の解答</b></p>
            <p>
                仮想アドレス空間は 4G バイト = 2³² バイト = 2^{35} ビットである。したがって、仮想アドレスのビット幅は 35 ビットである。<br>
                物理アドレス空間は 8M バイト = 2²³ バイト = 2^{26} ビットであるため、物理アドレスのビット幅は 26 ビットである。
            </p>
            <p><b>(2)の解答</b></p>
            <p>
                ページサイズは 4K バイト = 2¹² バイトである。仮想アドレス空間は 4G バイト = 2³² バイトであるため、ページ数は 
                \( \frac{2^{32}}{2^{12}} = 2^{20} \) ページとなる。<br>
                ページテーブルのエントリ 1 つ当たりの大きさは 2 バイトであるので、ページテーブル全体の大きさは 
                \( 2^{20} \times 2 = 2^{21} \) バイト、つまり 2M バイトとなる。
            </p>
            <p><b>(3)の解答</b></p>
            <p>
                <strong>方法:</strong> ページテーブルを階層化する（多段ページング）ことである。<br>
                <strong>短所:</strong> 階層化により、ページテーブルアクセス時のオーバーヘッドが増加し、メモリアクセスの遅延が発生する可能性がある。
            </p>
            <p><b>(4)の解答</b></p>
            <p>
                スラッシングとは、主記憶のページング領域が頻繁に入れ替わることで、ページフォールトが頻発し、システムのパフォーマンスが著しく低下する現象のことである。
            </p>
          </div>
            <div class="example">
                <p><b>問題</b></p>
                <p>プログラム実行過程で、実行に必要なページが主記憶にないとき、ページフォールトが発生し、ページアウトやページインという割込みが発生する。いま物理ページの個数が3しか使えないと仮定し、以下の順で仮想ページを照らし合わせ、ページ置換えアルゴリズムがFIFO (First-In First-Out) の場合とLRU (Least Recently Used) の場合で発生するページフォールトの回数を比較せよ。</p>
                <p>【仮想ページの参照順 (仮想ページ番号の並び)】 2→4→3→1→3→4→5→4→3→1→4</p>
                <p><b>解答</b></p>
                <p>FIFOの場合</p>
                <div class="scroll">
                <table>
                    <tr>
                        <th>参照列</th>
                        <td>2</td>
                        <td>4</td>
                        <td>3</td>
                        <td>1</td>
                        <td>3</td>
                        <td>4</td>
                        <td>5</td>
                        <td>4</td>
                        <td>3</td>
                        <td>1</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <th rowspan="3">ページ枠</th>
                        <td><b>2</b></td>
                        <td>2</td>
                        <td>2</td>
                        <td><b>1</b></td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td><b>3</b></td>
                        <td>3</td>
                        <td>3</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td><b>4</b></td>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                        <td><b>5</b></td>
                        <td>5</td>
                        <td>5</td>
                        <td><b>1</b></td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td></td>
                        <td><b>3</b></td>
                        <td>3</td>
                        <td>3</td>
                        <td>3</td>
                        <td>3</td>
                        <td><b>4</b></td>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <th>ページフォールト</th>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>0</td>
                    </tr>
                </table>
                </div>
                <p>LRUの場合</p>
                <div class="scroll">
                <table>
                    <tr>
                        <th>参照列</th>
                        <td>2</td>
                        <td>4</td>
                        <td>3</td>
                        <td>1</td>
                        <td>3</td>
                        <td>4</td>
                        <td>5</td>
                        <td>4</td>
                        <td>3</td>
                        <td>1</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <th rowspan="3">ページ枠</th>
                        <td><b>2</b></td>
                        <td>2</td>
                        <td>2</td>
                        <td><b>1</b></td>
                        <td>1</td>
                        <td>1</td>
                        <td><b>5</b></td>
                        <td>5</td>
                        <td>5</td>
                        <td><b>1</b></td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td><b>4</b></td>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td></td>
                        <td><b>3</b></td>
                        <td>3</td>
                        <td>3</td>
                        <td>3</td>
                        <td>3</td>
                        <td>3</td>
                        <td>3</td>
                        <td>3</td>
                        <td>3</td>
                    </tr>
                    <tr>
                        <th>ページフォールト</th>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                        <td>1</td>
                        <td>0</td>
                    </tr>
                </table>
                </div>
                <p>したがって、FIFOの場合はページフォールトは8回発生し、LRUの場合は6回発生する。</p>
            </div>
        </ul>
        <h3>OSの入出力</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://ja.gadget-info.com/difference-between-interrupt">OSにおける割り込みとポーリングの違い.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <ol>
                <li>OSの入出力におけるポーリング方式と割り込み方式について、それぞれ簡潔に説明せよ。また双方の利点と欠点について述べよ。</li>
                <li>同じく入出力に関して、DMAコントローラとは何か簡潔に説明せよ。</li>
            </ol>
            <p><b>(1)の解答</b></p>
            <p>ポーリング方式：CPUが定期的に各入出力デバイスの状態を確認し、処理が必要かどうかを判断する方式。
            実装が比較的簡単で、ハードウェアのサポートが少ない環境でも動作可能だが、
            CPUが常にデバイスの状態をチェックするため、他の処理が滞る可能性があり、非効率的。</p>
            <p>割込み方式：入出力デバイスからの割り込み信号により、CPUが必要なときにのみデバイスを処理する方式。
            CPUの効率を向上させ、他の処理と入出力処理の並行性を確保できるが、
            ハードウェアのサポートが必要であり、システムの設計が複雑になる。</p>
            <p><b>(2)の解答</b></p>
            <p>ダイレクトメモリアクセス（DMA）を実現するためのコントローラで、CPUを介さずに入出力デバイスとメモリ間のデータ転送を直接行うハードウェアモジュール。
                これにより、CPUの負荷を軽減し、入出力処理を高速化することができる。</p>
          </div>
        </ul>
        <h3>OSのカーネル</h3>
          <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://udemy.benesse.co.jp/development/what-is-kernel.html">カーネル(Kernel)とは？種類や機能をわかりやすく解説！｜Udemy メディア.html</a></p>
        <ul>
            <li>具体例</li>
            <div class="example">
                <p><b>問題</b></p>
                <p>オペレーティングシステムに関する以下の問に答えよ。</p>
                <ol>
                    <li>カーネルが行う管理のうち2つを記述せよ。</li>
                    <li>カーネルはCPUの特権モードで実行されるが、特権モードと非特権モードの違いは何か、簡潔に記述せよ。</li>
                </ol>
                <p><b>(1)の解答</b></p>
                <ol>
                    <li>メモリ管理: カーネルは、プロセスが使用するメモリ領域の割り当てや解放、仮想メモリの管理などを行う。これにより、各プロセスが独立したメモリ空間を持つことができ、プロセス間のメモリ干渉を防止する。</li>
                    <li>プロセス管理: カーネルは、プロセスの生成、スケジューリング、終了などの管理を行う。プロセススケジューリングでは、CPUリソースを各プロセスに公平に分配するためのスケジューリングアルゴリズムを用いる。</li>
                </ol>
                <p><b>(2)の解答</b></p>
                <p>特権モードは、CPUがハードウェアのすべての機能にアクセスできるモードであり、カーネルやデバイスドライバのような、システムの重要な部分が実行されるモードである。一方、非特権モードは、ユーザープログラムが実行されるモードであり、直接的にハードウェアにアクセスする権限が制限されている。これにより、ユーザープログラムがシステムの安定性やセキュリティに悪影響を及ぼさないようにする。</p>
            </div>
        </ul>
        <h3>計算速度の高速化</h3>
        <ul>
            <li>具体例</li>
            <div class="example">
                <p><b>問題</b></p>
                <ol>
                    <li>計算機が開発されてから、単一プロセッサ（コア）の計算速度は、向上の一途をたどってきたが、近年、その速度向上が鈍化してきている。その原因はなぜか、簡潔に記述せよ。</li>
                    <li>上記の単一プロセッサ（コア）の速度向上が鈍化していることに対して、高速化を図るために現在利用されている工夫、方法論、システムアーキテクチャ等について一つ示し、その概要を簡潔に記述せよ。</li>
                </ol>
                <p><b>(1)の解答</b></p>
                <p>単一プロセッサの計算速度向上が鈍化している主な原因は、ムーアの法則が限界に近づいているためである。
                    ムーアの法則に従い、半導体の集積度が2年ごとに倍増し、それに伴い計算速度も向上してきた。
                    しかし、プロセス技術の微細化が物理的な限界に近づき、トランジスタのさらなる微細化が困難になっている。
                    この結果、クロック周波数の向上も限界に達し、発熱問題や消費電力の増加が主な課題となり、単一コアの速度向上が鈍化している。</p>
                <p><b>(2)の解答</b></p>
                <p>単一コアの速度向上の鈍化に対処するために、現在広く利用されているアプローチの一つは、マルチコアプロセッシングである。
                    マルチコアプロセッサでは、複数のプロセッサコアを一つのチップ上に搭載し、並列処理を行うことで全体の計算速度を向上させる。
                    これにより、単一のタスクに対する速度向上は限定的であるが、複数のタスクやスレッドを同時に実行することで、システム全体のスループットを向上させ、より効率的な計算を実現している。</p>
            </div>
        </ul>
        <h3>C言語</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://temp-soft.com/blog/2020/11/19/c-introductionextra-swap/">【独学Ｃ言語入門 番外編】swap関数を作成しよう【ポインタ応用①】 _ Temp Soft ブログ.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <p>図1に示すC言語のプログラムがある。関数 <code>koukan</code> を呼び出すことにより、
                <code>int</code> 型変数 <code>a</code> と <code>b</code> の値を入れ替えたい。
                図1のプログラム内の(A)～(D)の空欄に入る内容について、解答用紙に記述せよ。</p>
            <pre>
            #include &lt;stdio.h&gt;
        
            void koukan( (A) );
        
            int main()
            {
                int a, b;
                a = 0; b = 1;
        
                koukan( (B) );
        
                printf("%d %d\n", a, b);
                return 0;
            }
        
            void koukan( (C) )
            {
                (D)
            }
            </pre>

            <p><b>解答</b></p>
            <pre>
            #include &lt;stdio.h&gt;
        
            void koukan(int *x, int *y);
        
            int main()
            {
                int a, b;
                a = 0; b = 1;
        
                koukan(&a, &b);
        
                printf("%d %d\n", a, b);
                return 0;
            }
        
            void koukan(int *x, int *y)
            {
                int temp;
                temp = *x;
                *x = *y;
                *y = temp;
            }
            </pre>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>以下のソースコードは、2つの複素数の積を計算して標準出力に表示するC言語プログラムである。
            空欄を適切に埋めてプログラムを完成させよ。</p>
            <pre>
            #include &lt;stdio.h&gt;

            （ア）;
            
            struct COMPLEX MultiComplex(struct COMPLEX a, struct COMPLEX b);
            void PrintComplex(struct COMPLEX a);
            
            int main(void)
            {
                struct COMPLEX a = { 1.0, 2.0 }, b = { 3.0, 5.0 }, c;
            
                c = MultiComplex(a, b);
                PrintComplex(c);
                return 0;
            }
            
            struct COMPLEX MultiComplex(struct COMPLEX a, struct COMPLEX b) {
                struct COMPLEX c;
                c.re = a.re * b.re - a.im * b.im;
                c.im = （イ）;
                return c;
            }
            
            void PrintComplex(struct COMPLEX a) {
                printf("%f%s%fi", a.re, (a.im &gt= 0.0) ? "+" : "", a.im);
            }
            </pre>

            <p><b>解答</b></p>
            <p>（ア）には、複素数を表す構造体の宣言が必要である。</p>
            <p>（イ）には、複素数の虚部の計算式が入る。</p>
            <pre>
            #include &lt;stdio.h&gt;

            struct COMPLEX {
                double re;
                double im;
            };
            
            struct COMPLEX MultiComplex(struct COMPLEX a, struct COMPLEX b);
            void PrintComplex(struct COMPLEX a);
            
            int main(void)
            {
                struct COMPLEX a = { 1.0, 2.0 }, b = { 3.0, 5.0 }, c;
            
                c = MultiComplex(a, b);
                PrintComplex(c);
                return 0;
            }
            
            struct COMPLEX MultiComplex(struct COMPLEX a, struct COMPLEX b) {
                struct COMPLEX c;
                c.re = a.re * b.re - a.im * b.im;
                c.im = a.re * b.im + a.im * b.re;
                return c;
            }
            
            void PrintComplex(struct COMPLEX a) {
                printf("%f%s%fi", a.re, (a.im &gt= 0.0) ? "+" : "", a.im);
            }
            </pre>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>以下のソースコードは、標準入力から読み込んだ自然数に対してその階乗を計算して標準出力に表示するC言語プログラムである。
            空欄を適切に埋めてプログラムを完成させよ。</p>
            <pre>
            #include &lt;stdio.h&gt;

            int main(void)
            {
                int a, b;
                scanf("%d", &a);
                if (a &lt 1) {
                    printf("自然数を入力してください\n");
                } else {
                    b = factorial(a);
                    printf("%d\n", b);
                }
                return 0;
            }
            
            int factorial(int n) {
                if (n == 1) {
                    return （ウ）;  
                } else {
                    return （エ）;
                }
            }
            </pre>

            <p><b>解答</b></p>
            <pre>
            #include &lt;stdio.h&gt;

            int main(void)
            {
                int a, b;
                scanf("%d", &a);
                if (a &lt 1) {
                    printf("自然数を入力してください\n");
                } else {
                    b = factorial(a);
                    printf("%d\n", b);
                }
                return 0;
            }
            
            int factorial(int n) {
                if (n == 1) {
                    return 1;  
                } else {
                    return n * factorial(n - 1);  
                }
            }
            </pre>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>以下のソースコードは、乱数を用いて近似的に求めた半径1の四分位円の面積から、円周率を計算して標準出力に表示するC言語プログラムである。
            空欄を適切に埋めてプログラムを完成させよ。
            ここで<code>rand()</code>は0以上<code>RAND_MAX</code>以下の一様整数乱数を返す関数である。</p>
            <pre>
            #include &lt;stdio.h&gt;
            #include &lt;stdlib.h&gt;

            int main(void)
            {
                int i, count;
                int max_iter = 1000000;
                double x, y, pi;
            
                （オ）;  
                for (i = 0; i &lt max_iter; i++) {
                    x = (double)rand() / (RAND_MAX + 1.0);
                    y = (double)rand() / (RAND_MAX + 1.0);
            
                    if (x * x + y * y &lt 1) {
                        count++;
                    }
                }
            
                pi = 4.0 * （カ）;
                printf("%f\n", pi);
                return 0;
            }
            </pre>

            <p><b>解答</b></p>
            <p>空欄 (オ) には、乱数によって四分円の内部に入った点のカウントを初期化するために <code>count = 0;</code>を記述する。
                これは、四分円内にランダムに生成された点の数を計算するための変数である。</p>
            <p>空欄 (カ) には、四分円内に入った点の割合を基にして\(\pi\)を計算する式が入る。
                四分円の面積は\(\frac{\pi}{4}\)で表されるため、次のように計算する：<code>count / (double)max_iter</code></p>
            <pre>
            #include &lt;stdio.h&gt;
            #include &lt;stdlib.h&gt;

            int main(void)
            {
                int i, count;
                int max_iter = 1000000;
                double x, y, pi;
            
                count = 0;
                for (i = 0; i &lt max_iter; i++) {
                    x = (double)rand() / (RAND_MAX + 1.0);
                    y = (double)rand() / (RAND_MAX + 1.0);
            
                    if (x * x + y * y &lt 1) {
                        count++;
                    }
                }
            
                pi = 4.0 * count / (double)max_iter;
                printf("%f\n", pi);
                return 0;
            }
            </pre>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>以下のソースコードは、与えた関数<code>func</code>の定積分を長方形近似で計算して標準出力に表示するC言語プログラムである。
            空欄を適切に埋めてプログラムを完成させよ。</p>
            <pre>
            #include &lt;stdio.h&gt;

            double func(double x);
            double integral(（キ）, double min, double max, int steps); 
            
            int main(void)
            {
                double min = 0.0;
                double max = 1.0;
                int steps = 1000;
                double s;
            
                s = integral(（ク）, min, max, steps);
                printf("%f\n", s);
                return 0;
            }
            
            double func(double x) {
                return x * x * x;
            }
            
            double integral(（キ）, double min, double max, int steps) {
                int i;
                double x = min;
                double h = (max - min) / steps;
                double sum = 0.0;
            
                for (i = 0; i &lt steps; i++) {
                    sum += fp(x);
                    x += h;
                }
            
                return (h * sum);
            }
            </pre>

            <p><b>解答</b></p>
            <p>空欄 (キ) には、関数ポインタ double (*fp)(double) が入る。これは、func のポインタを受け取るための引数である。</p>
            <p>空欄 (ク) には、func 関数のポインタを渡す。この関数ポインタは、定積分を計算するために使用される。</p>
            <pre>
            #include &lt;stdio.h&gt;

            double func(double x);
            double integral(double (*fp)(double), double min, double max, int steps);  
            
            int main(void)
            {
                double min = 0.0;
                double max = 1.0;
                int steps = 1000;
                double s;
            
                s = integral(func, min, max, steps);  
                printf("%f\n", s);
                return 0;
            }
            
            double func(double x) {
                return x * x * x;
            }
            
            double integral(double (*fp)(double), double min, double max, int steps) {
                int i;
                double x = min;
                double h = (max - min) / steps;
                double sum = 0.0;
            
                for (i = 0; i &lt steps; i++) {
                    sum += fp(x);
                    x += h;
                }
            
                return (h * sum);
            }
            </pre>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>2001年1月1日は月曜日であった。以下のソースコードは、2001年の日付を標準入力から読み込み、曜日を標準出力に表示するC言語プログラムである。
            日付は、例えば5月3日は5/3、10月11日は10/11という形式で与える。ただし、存在しない日付に対するエラーチェックは省略している。
            曜日は英語で出力する。なお、2001年は｢うるう年｣ではなく、2月は28日間である。
            空欄を適切に埋めてプログラムを完成させよ。</p>
            <pre>
            #include &lt;stdio.h&gt;

            int main(void)
            {
                int i, month, day;
                int total_days = 0;
                int days_of_month[] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
                （ケ） day_of_week[] = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };  
            
                scanf("%d/%d", &month, &day);
            
                for (i = 0; i &lt month-1; i++) {
                    total_days += days_of_month[i];
                }
            
                total_days += day;
            
                printf("%s\n", day_of_week[（コ）]); 
                return 0;
            }
            </pre>

            <p><b>解答</b></p>
            <p>空欄 (ケ) には、曜日を格納するための配列 day_of_week の定義が必要である。</p>
            <p>空欄 (コ) には、計算された日数 total_days に対応する曜日を配列 day_of_week から取得するために、total_days % 7 というインデックスを使用する。この操作により、日付が何曜日に当たるかを求めることができる。</p>
            <pre>
            #include &lt;stdio.h&gt;

            int main(void)
            {
                int i, month, day;
                int total_days = 0;
                int days_of_month[] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
                char* day_of_week[] = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };
            
                scanf("%d/%d", &month, &day);
            
                for (i = 0; i &lt month-1; i++) {
                    total_days += days_of_month[i];
                }
            
                total_days += day;
            
                printf("%s\n", day_of_week[total_days % 7]);
                return 0;
            }
            </pre>
          </div>
        </ul>
        <h3>コンピュータネットワーク</h3>
        <p>参考にした書籍・サイトは以下のとおり。</p>
        <p><a href="https://www.amazon.co.jp/%E4%BB%A4%E5%92%8C06%E5%B9%B4%E3%80%90%E6%98%A5%E6%9C%9F%E3%80%91%E3%80%90%E7%A7%8B%E6%9C%9F%E3%80%91-%E5%BF%9C%E7%94%A8%E6%83%85%E5%A0%B1%E6%8A%80%E8%A1%93%E8%80%85-%E5%90%88%E6%A0%BC%E6%95%99%E6%9C%AC-%E5%A4%A7%E6%BB%9D-%E3%81%BF%E3%82%84%E5%AD%90/dp/4297138654/ref=sr_1_1_sspa?adgrpid=116229741496&dib=eyJ2IjoiMSJ9.3HIWJJcKK0OnSDk0o2dN14AWFX_tqIJG5wk00NJ0GP94T0pbirPKpWiVtbv7TQ4V1K9eeS_9Gbn3rO2q3MUenhGlex3ZhwhzbFtSk-WxwXJlS12e2E78OUitRTqDyb3vWO3lvZh3lldqx8vw1XqApscyzUXszM_LxNIRA9XEqwLbc-LQzGcg9rS3lVCVD9UxLaZx-LdUW4KzypRKUBNBRGFG1oDUJLDYOCyQbz3Yf3c.9rDm-12tMlPD7zMQpIrgxP9LaTPUc9D3dYmEZlNr7jk&dib_tag=se&hvadid=679018724842&hvdev=c&hvqmt=e&hvtargid=kwd-398224603637&hydadcr=26606_11788876&jp-ad-ap=0&keywords=%E5%BF%9C%E7%94%A8%E6%83%85%E5%A0%B1%E6%8A%80%E8%A1%93%E8%80%85%E8%A9%A6%E9%A8%93+%E5%8F%82%E8%80%83%E6%9B%B8&qid=1724377459&s=books&sr=1-1-spons&sp_csd=d2lkZ2V0TmFtZT1zcF9hdGY&psc=1">令和06年【春期】【秋期】 応用情報技術者 合格教本</a></p>
        <p><a href="https://it-biz.online/it-skills/osi-reference-model/">OSI参照モデルとは？役割・覚え方をわかりやすく３分で解説 _ ビズドットオンライン.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <ol>
                <li>OSI参照モデルにおけるデータリンク層とネットワーク層の役割の違いを、200文字程度で説明せよ。なお、説明にはMACアドレスとIPアドレスがそれぞれどの層で利用されるかを含めること。</li>
                <li>DNSはどのような役割を果たすものかを150文字程度で説明せよ。</li>
            </ol>
            <p><b>(1)の解答</b></p>
            <p>OSI参照モデルにおいて、データリンク層は隣接するノード間でのデータ転送を担当し、物理的なネットワークの信頼性を確保する役割を持つ。
                この層ではMACアドレスが利用され、ネットワーク内のデバイスを識別する。
                一方、ネットワーク層は異なるネットワーク間でのデータ転送を管理し、データのルーティングを行う層である。
                この層ではIPアドレスが使用され、グローバルにデバイスを識別し、最適な経路を選択する。</p>
            <p><b>(2)の解答</b></p>
            <p>DNS（Domain Name System）は、インターネット上でドメイン名を対応するIPアドレスに変換する役割を果たすシステムである。
                これにより、ユーザーは覚えやすいドメイン名を入力するだけで、目的のウェブサイトやサーバーにアクセスできる。
                DNSは階層構造で管理され、各レベルで異なる部分の名前解決を担当する。
                これにより、インターネット上の通信やリソースのアクセスがスムーズに行えるようになっている。</p>
          </div>
            <div class="example">
                <p><b>問題</b></p>
                <p>異なるコンピュータ間でデータのやりとりを行う場合の手順やルールを定めたものは、通信プロトコルと呼ばれる。このプロトコルはISOが定めたOSI基本参照モデルによって、7つの階層に分けられ、各階層に必要な機能が定義されている。各層の機能、役割について端的に記述せよ。</p>
                <p><b>解答</b></p>
                <p><b>アプリケーション層</b></p>
                <p>やりとりされたデータの意味内容を直接取り扱う。SMTP（メール）、HTTP（Webアクセス）などそれぞれのアプリケーションに特化したプロトコル。</p>
                <p><b>プレゼンテーション層</b></p>
                <p>データの表現形式を管理する。文字コードや圧縮の種類などのデータの特性を規定する。</p>
                <p><b>セッション層</b></p>
                <p>最終的な通信の目的に合わせてデータの送受信管理を行う。コネクション確立・データ転送のタイミング管理を行い、特性の異なる通信の差異を吸収する。</p>
                <p><b>トランスポート層</b></p>
                <p>エラーの検出/再送などデータ転送の制御により通信の品質を保証する、ネットワークアドレスはノードに対して付与されるが、トランスポート層では、<b>ポート番号</b>によりノード内のアプリケーションを特定する。<b>TCP</b>や<b>UDP</b>がこの層に該当する。</p>
                <p><b>ネットワーク層</b></p>
                <p>エンドツーエンドのやり取りを規定。MACアドレスをはじめとするデータリンクアドレスはローカルネットワーク内だけで有効であるため、ネットワークを越えた通信を行う場合に付け替える必要があるが、ネットワーク層で提供されるアドレスは、通信の最初から最後まで一貫したアドレスである。<b>IP</b>がこの層に該当する。</p>
                <p><b>データリンク層</b></p>
                <p>同じネットワークに接続された隣接ノード間での通信について規定。<b>HDLC</b>手順や、MACフレームの規格が該当する。</p>
                <p><b>物理層</b></p>
                <p>最下位に位置し、システムの物理的、電気的な性質を規定する。デジタルデータを、どのように電流の波形や電圧的な高低に割り付けるのかといったことや、ケーブルが満たすべき抵抗などの要件、コネクタピンの形状などを定める。</p>
            </div>
            <div class="example">
                <p><b>問題</b></p>
                <p>ネットワークにおけるプロトコル階層化の概要およびその利点について説明せよ。
                    また、TCP と IP の二つのプロトコルを例として取り上げ、それらのプロトコルの役割がそれぞれの階層でどのように異なるか、二つのプロトコルが送信や受信の際に階層間でどのような処理を行って通信を実現するか説明せよ。</p>
                <p><b>解答</b></p>
                <p>ネットワークにおけるプロトコルの階層化は、通信システムを複数の階層に分割し、それぞれの階層が特定の機能を担当するという考え方に基づいている。
                    この階層化の利点は、各階層が独立して機能するため、一つの階層の変更が他の階層に影響を与えない点にある。
                    これにより、ネットワークの設計や管理が容易になり、異なる機器やプロトコルの相互運用性が向上する。
                    TCP/IPモデルにおいては、IP（インターネットプロトコル）がネットワーク層に位置し、データのルーティングや転送を担当する。
                    一方、TCP（トランスポートコントロールプロトコル）はトランスポート層に位置し、データの信頼性や整合性を確保する役割を担う。
                    具体的には、IPはデータをパケットに分割し、目的地までの経路を決定して転送を行う。
                    TCPは、これらのパケットが正確に順序通りに到達するよう、エラーチェックや再送制御を行う。
                    送信時には、TCPがデータをセグメントに分割し、それにシーケンス番号やチェックサムを付加する。
                    その後、IPがこれをパケットとして処理し、ネットワークを介して送信する。
                    受信時には、IPがパケットを受け取り、TCPがそれを再構築して元のデータを復元する。
                    このように、TCPとIPはそれぞれの階層で異なる役割を果たしながら、協力して信頼性の高い通信を実現している。</p>
            </div>
        </ul>
        <h3>TCP・UDP</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://hldc.co.jp/blog/2019/07/11/2819/">TCPとUDPの違いとは？～Ethernet接続におけるオーバーヘッド削減ノウハウ～ _ ハートランド・ザ・ワールド.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <ol>
                <li>TCPはUDPと比較して信頼性を有するプロトコルである。TCPは通信の信頼性を提供するためにどのような機能を実現しているか、150文字程度で説明せよ。</li>
                <li>インターネットでは、トランスポート層のプロトコルとしてTCPではなくUDPが用いられる場面がある。TCPと比較してUDPを広域通信で用いる場合の利点やアプリケーション例について、150文字程度で説明せよ。</li>
            </ol>
            <p><b>(1)の解答</b></p>
            <p>TCPは信頼性を確保するために、データの順序制御、パケットの再送制御、エラーチェック、フロー制御、接続確立と終了のハンドシェイクを実現している。これにより、通信が正確で完全に行われることを保証し、データが損失なく送受信されることを確保する。</p>
            <p><b>(2)の解答</b></p>
            <p>UDPはTCPと比較して接続の確立や状態管理が不要であり、オーバーヘッドが少なく、リアルタイム性が求められる通信に適している。これにより、遅延が少なく高速な通信が可能であり、VoIP、ストリーミング、オンラインゲームなどのアプリケーションで広く利用されている。</p>
          </div>
        </ul>
        <h3>ARP</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://e-words.jp/w/ARP.html">ARP（アドレス解決プロトコル）とは - 意味をわかりやすく - IT用語辞典 e-Words.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <p>EthernetなどのL2ネットワークでInternet Protocolによる通信を行う際は、宛先ホストのIPアドレスから物理アドレス（またはMACアドレス）を取得する仕組み(Address Resolution Protocol, ARP)が必要となる。ARPの動作概要を250字程度で説明せよ。</p>
            <p><b>解答</b></p>
            <p>
                EthernetなどのL2ネットワークでInternet Protocolによる通信を行う際は、宛先ホストのIPアドレスから物理アドレス（またはMACアドレス）を取得する仕組みが必要となる。この仕組みがAddress Resolution Protocol（ARP）である。
            </p>
            <p>
                ARPの基本的な動作は次の通りである。まず、送信側ホストが宛先ホストのIPアドレスに対応するMACアドレスを持っていない場合、ネットワーク上にARPリクエストをブロードキャストする。このARPリクエストには、送信元のIPアドレスとMACアドレス、および宛先のIPアドレスが含まれている。
            </p>
            <p>
                ネットワーク内の全てのホストがこのARPリクエストを受信するが、宛先IPアドレスと自分のIPアドレスが一致するホストのみが、ARPリプライを送信する。このARPリプライには、宛先ホストのMACアドレスが含まれている。送信側ホストはこのARPリプライを受信し、対応するMACアドレスを取得してARPキャッシュに保存する。このプロセスにより、IPアドレスから物理アドレスへの変換が完了し、データの送信が可能となる。
            </p>
          </div>
        </ul>
        <h3>ノイマン型計算機</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://nw.tsuda.ac.jp/lec/risc/risc.html">Chapter 1. The Foundation of Computer System.html</a></p>
        <p><a href="https://art.ist.hokudai.ac.jp/~horiyama/lecture/comp_sys/">コンピュータシステム (Computer System).html</a></p>
        <ul>
            <li>CPUが直接実行する機械語プログラムはデータとともに<b>主記憶</b>に格納される。</li>
            <li>CPUは<b>プログラムカウンタ</b>が示す番地に格納されている命令語を<b>主記憶</b>から読み出し、その意味を解釈し、逐次実行する。</li>
            <li>一般に個々の命令語は命令の種類を示す<b>オペコード</b>と命令の対象を示す<b>オペランド</b>から構成される。</li>
            <li><b>オペランド</b>が対象のデータの格納番地である場合には、これを<b>間接</b>アドレッシングと呼ぶ。</li>
            <li>具体例</li>
            <div class="example">
                <p><b>問題</b></p>
                <p>ノイマン型コンピュータにおけるプロセッサに関する以下の問いに答えよ。</p>
                <ol>
                    <li>プロセッサが以下の (a) から (e) の動作を順に行って一つの演算命令を実行するケースを考える。このとき、(a) から (e) のそれぞれはどのような動作か、簡潔に示せ。</li>
                    <ul>
                        <li>(a) Instruction fetch</li>
                        <li>(b) Decode</li>
                        <li>(c) Operand read</li>
                        <li>(d) Execute</li>
                        <li>(e) Write back</li>
                    </ul>
                    <li>フォンノイマンボトルネックとはノイマン型コンピュータのどのような弱点を言い表したものか、簡潔に記述せよ。</li>
                </ol>
                <p><b>(1)の解答</b></p>
                <p>(a) Instruction fetch：命令をメモリから取得する。この段階では、プログラムカウンタ（PC）が指し示すメモリ上のアドレスから命令を読み取る。</p>
                <p>(b) Decode：取得した命令を解釈し、どの操作を行うかを決定する。命令デコーダがこの役割を果たし、命令のオペコードを解析して次のステップを決定する。</p>
                <p>(c) Operand read：命令の実行に必要なオペランド（操作対象データ）を取得する。これには、レジスタやメモリからオペランドを読み取る操作が含まれる。</p>
                <p>(d) Execute：実際に命令を実行する。算術演算や論理演算、データの移動など、命令が指定する操作を行う。</p>
                <p>(e) Write back：実行結果をレジスタやメモリに書き戻す。これにより、演算結果が次の命令で使用できるようになる。</p>
                <p><b>(2)の解答</b></p>
                <p>フォンノイマンボトルネックとは、ノイマン型コンピュータにおけるプロセッサとメモリ間のデータ転送速度がシステム全体のパフォーマンスの制約となる現象を指す。プロセッサが非常に高速で命令を処理できる場合でも、メモリからのデータ転送が遅いと、プロセッサがその能力を十分に発揮できず、システム全体の効率が低下する問題が生じる。これにより、メモリ帯域がシステム性能のボトルネックとなり、計算能力がメモリの読み書き速度に依存してしまう。</p>
            </div>
        </ul>
        <h3>パイプライン制御</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://www.ap-siken.com/kakomon/23_toku/q10.html">応用情報技術者試験ドットコム</a></p>
        <ul>
            <li>具体例</li>
            <div class="example">
                <p><b>問題</b></p>
                <p>
                    パイプライン制御とは、CPUの内部動作をいくつかのステージに分割して、ステージ単位で並行処理を行う仕組みである。ここでは、1つの命令を以下の4つのステージに分割する。
                </p>
                <ul>
                    <li>命令取り出し (Instruction Fetch)</li>
                    <li>命令解読 (Instruction Decode)</li>
                    <li>命令実行 (Execute)</li>
                    <li>結果書き込み (Write-back)</li>
                </ul>
        
                <ol>
                    <li>
                        命令を分割するステージ数を4、ステージ毎の実行時間を10ms、実行する命令数を5とするとき、すべての処理を終了するまでの時間を計算せよ。
                    </li>
                    <li>
                        命令を分割するステージ数を \( D \)、ステージ毎の実行時間を \( P \) 秒とするとき、1個の命令をパイプラインで実行するのに要する時間を \( D \), \( P \), \( I \) と数値を用いて表せ。なお、パイプラインの各ステージは1ピッチで処理されるものとし、パイプラインハザードについては考慮しなくてよい。
                    </li>
                </ol>
                <p><b>(1)の解答</b></p>
                <p>
                    パイプラインでは、最初の命令がすべてのステージを通過するまでの時間を求め、その後の各命令は1ステージ分の時間で次々に処理される。1つの命令が4つのステージをすべて通過するのにかかる時間は、40msである。残りの4つの命令は、それぞれ10msずつで処理されるため、すべての処理を終了するまでの時間は次のように求められる。
                </p>
        
                <p><div class="scroll">\begin{align}
                    40ms + 40ms = 80ms
                \end{align}</div></p>
                <p><b>(2)の解答</b></p>
                <p>
                    1つの命令がパイプライン全体を通過するのにかかる時間は、\( D \times P \) 秒である。次の命令からは各ステージで1サイクル毎に処理が進むため、I個の命令全体が処理されるまでの時間は次のように表される。
                </p>
        
                <p><div class="scroll">\begin{align}
                    P \times (D + I - 1)
                \end{align}</div></p>
        
                <p>
                    これが、1個の命令をパイプラインで実行するのに要する時間である。
                </p>
            </div>
        <h3>プログラムカウンタ</h3>
            <div class="example">
                <p><b>問題</b></p>
                <p>多くの計算機アーキテクチャでは、プログラム内蔵方式を採用し、プログラムカウンタ（PC）をプロセッサ内部に有している。プログラムカウンタとは何か、またプログラム内蔵方式において、プログラムカウンタが何故必要であるか簡潔に答えよ。</p>
                <p><b>解答</b></p>
                <p>プログラムカウンタとは：プログラムカウンタ（Program Counter, PC）とは、次に実行すべき命令のメモリアドレスを保持するレジスタである。CPUがプログラムを実行する際、プログラムカウンタは次に読み取る命令のメモリ上の位置を示しており、命令を実行するたびに通常は次の命令のアドレスに自動的に更新される。</p>
                <p>プログラム内蔵方式においてプログラムカウンタが必要である理由：プログラム内蔵方式（Stored Program Architecture）は、プログラムとデータの両方をメモリに格納し、CPUがそれらを順次取り出して実行する方式である。
                    この方式では、CPUが命令を実行するために、メモリから命令を順次取り出す必要がある。
                    プログラムカウンタがない場合、次にどの命令を実行するかをCPUが特定できないため、プログラムの順序通りの実行ができなくなる。
                    プログラムカウンタは、プログラムの正しい順序で命令を実行するために不可欠であり、分岐命令やサブルーチンの呼び出しなどが発生した際には、プログラムカウンタの値を適切に変更することで、プログラムの制御フローを管理する役割を果たしている。
                    このため、プログラムカウンタは、プログラム内蔵方式においてプログラムを適切に実行するために必須の要素である。
                </p>
            </div>
      </section>
    </main>
</body>
</html>
