<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【院試対策|北海道大学 情報科学院】走る作曲家のAIカフェ～コンピュータシステム編～</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <header>
        <h1>走る作曲家のAIカフェ</h1>
        <nav>
            <ul>
                <li><a href="index.html">ホーム</a></li>
                <li><a href="study.html">勉強</a></li>
                <li><a href="music.html">音楽</a></li>
                <li><a href="sports.html">スポーツ</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section>
          <p>「北海道大学大学院情報科学院修士課程入学試験」（令和6年8月実施）の「<b>コンピュータシステム</b>」対策ページです。</p>
        </section>
        <section>
          <h2>分野別対策</h2>
          <ul>
            <li><a href="gradexam.html">院試対策 ～はじめに～</a></li>
            <li><a href="gradexam_basicmath.html">院試対策 ～基礎数学編～</a></li>
            <li><a href="gradexam_infomath.html">院試対策 ～情報数学編～</a></li>
            <li><a href="gradexam_statistics.html">院試対策 ～確率・統計編～</a></li>
            <li><a href="gradexam_algo.html">院試対策 ～アルゴリズムとデータ構造編～</a></li>
            <li><a href="gradexam_ai.html">院試対策 ～人工知能編～</a></li>
            <li><a href="gradexam_cs.html">院試対策 ～コンピュータシステム編～</a></li>
          </ul>
        </section>
      <section id="probability-statistics">
        <h2>コンピュータシステム</h2>
        <h3>2の補数表現</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://www.momoyama-usagi.com/entry/info-calc-sys02">うさぎでもわかる計算機システム　Part02　2の補数表現 [基本情報対応] _ 工業大学生ももやまのうさぎ塾.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <p>2の補数表現を用いて、10進数の"-4"を5ビットの2進数で表せ。</p>
            <p><b>解答</b></p>
            <ol>
              <li>正の数"4"を5ビットの2進数で表すと、\(00100\)である。</li>
              <li>ビットを反転させると、\(11011\)となる。</li>
              <li>この反転した値に1を加えて、\(11100\)を得る。</li>
            </ol>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>10進数の計算85-12を8ビット、2の補数表現で計算した場合の計算過程と結果を示せ。</p>
            <p><b>解答</b></p>
            <ol>
              <li>85を2進数で表すと、01010101である。</li>
              <li>12を2進数で表すと、00001100であり、ビット反転して1を加えると、11110100である。</li>
              <li>01010101と11110100を加算すると、1|01001001となる（|の左にある1は桁あふれ）。</li>
              <li>この結果を10進数に変換すると73であり、オーバーフローが発生せずに正しく計算されていることがわかる。</li>
            </ol>
          </div>
        </ul>
        <h3>固定小数点・浮動小数点</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://www.momoyama-usagi.com/entry/info-calc-sys03">うさぎでもわかる計算機システム　Part03　固定小数点・浮動小数点 _ 工業大学生ももやまのうさぎ塾.html</a></p>
        <p><a href="https://medium-company.com/%E4%B8%B8%E3%82%81%E8%AA%A4%E5%B7%AE-%E6%89%93%E5%88%87%E3%82%8A%E8%AA%A4%E5%B7%AE-%E6%A1%81%E8%90%BD%E3%81%A1-%E6%83%85%E5%A0%B1%E8%90%BD%E3%81%A1-%E9%81%95%E3%81%84/">丸め誤差、打切り誤差、桁落ち、情報落ちの違い - ITを分かりやすく解説.html</a></p>
        <ul>
            <li>誤差</li>
            <ul>
                <li><b>丸め誤差</b>：「表現できる数の範囲」（有効桁）を超えてしまった際に有効桁以降を切り捨てることによって発生する誤差。</li>
                <li><b>打ち切り誤差</b>：コンピュータの計算処理を途中で打ち切ることにより発生する誤差。</li>
                <li><b>桁落ち</b>：値がほぼ等しい数値差を求めた時に発生する誤差。</li>
                <li><b>情報落ち</b>：大きい値と小さい値の数値を和もしくは差を求めた時に発生する誤差。</li>
            </ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <p>固定小数点方式と浮動小数点方式について、それぞれどのような数値表現方式か簡潔に記述せよ。</p>
            <p><b>解答</b></p>
            <ol>
              <li><b>固定小数点方式</b>：固定小数点方式は、数値を固定された小数点位置で表現する方式である。
                この方式では、小数点以下の桁数があらかじめ決まっており、整数部と小数部の桁数が固定されている。
                例えば、16ビットの固定小数点数の場合、8ビットを整数部、8ビットを小数部として扱う。
                この方式は、計算が簡単で処理が高速であるが、表現できる数の範囲と精度が限られている。</li>
              <li><b>浮動小数点方式</b>：浮動小数点方式は、数値を仮数部と指数部に分けて表現する方式である。
                この方式では、小数点の位置が仮数部と指数部によって動的に決定されるため、非常に大きい数や非常に小さい数を表現することができる。
                IEEE 754規格が広く使われており、32ビットの単精度と64ビットの倍精度が一般的である。
                浮動小数点方式は、広い範囲の数を表現できる一方で、計算が複雑で丸め誤差が生じることがある。</li>
            </ol>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>浮動小数点数の算術演算における｢丸め誤差｣はどのような場合に生ずるか簡潔に述べよ。</p>
            <p><b>解答</b></p>
            <p>浮動小数点数の算術演算における「丸め誤差」は、有限のビット数で無限小数を表現する際に、元の数値を近似的に表現する必要がある場合に生じる。
            この近似により、演算結果が正確な値から僅かにずれることがあり、これが丸め誤差の原因である。特に、小数点以下の桁数が長い数値や、極端に大きいまたは小さい数値の演算時に顕著に現れることが多い。</p>
          </div>
        </ul>
        <h3>フォン・ノイマン・ボトルネック</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://e-words.jp/w/%E3%83%8E%E3%82%A4%E3%83%9E%E3%83%B3%E5%9E%8B%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF.html">ノイマン型コンピュータ（ストアードプログラム方式 _ プログラム内蔵方式）とは - 意味をわかりやすく - IT用語辞典 e-Words.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <ol>
                <li>フォン・ノイマン・ボトルネックとはどのようなものか簡潔に述べよ。</li>
                <li>フォン・ノイマン・ボトルネックの解消に有効な技術の一つとしてキャッシュメモリがある。
                キャッシュメモリに関して述べた以下の文中の空欄Ⅰ〜Ⅳに当てはまる最も適切な語句を(a)〜(h)から選択し、解答用紙にそれぞれ対応付けて示せ。（例：Ⅰ:(a)）
                <p>「キャッシュメモリはメインメモリと比べてその容量は[ ]Ⅰ が、そのアクセス速度は[ ]Ⅱ である。
                    キャッシュメモリを有効に活用するためには、メモリアクセスの[ ]Ⅲ を高めることが重要である。
                    例えば、大きな配列を走査する場合は、各要素へのアクセスをメモリ上で連続化することで、メモリアクセスの[ ]Ⅳ [ ]Ⅲ を高めることができる。」</p>
                    <ul>
                        <li>(a) 大きい</li>
                        <li>(b) 小さい</li>
                        <li>(c) 高速</li>
                        <li>(d) 低速</li>
                        <li>(e) 汎用性</li>
                        <li>(f) 局所性</li>
                        <li>(g) 時間的</li>
                        <li>(h) 空間的</li>
                    </ul>
                </li>
                <li>キャッシュメモリのヒット率h(0 ≦ h ≦ 1)、そのアクセス時間をtとし、メインメモリへのアクセス時間をtmとするとき、メインメモリへの実効アクセス時間teを、t, tm, hにより表せ。
                また、tm = 10t である場合のヒット率hと実効アクセス時間teの関係を表すグラフの概形（横軸をh、縦軸をteとする）を解答用紙に図示せよ。</li>
                <li>キャッシュメモリの代表的なデータ格納構造として、ダイレクトマップ方式とセットアソシアティブ方式がある。
                今、幅32ビットのアドレスで管理されるメインメモリに対して、ダイレクトマップ方式を用いたキャッシュメモリを設計したとき、タグのビット数が16ビットとなった。
                キャッシュメモリの容量を増加させる場合（キャッシュブロックのサイズを変更せずに）、データ格納構造を4ウェイのセットアソシアティブ方式に変更した場合、タグのビット数はいくつになるか、その理由とともに述べよ。</li>
            </ol>
            <p><b>解答</b></p>
            <ol>
              <li>フォン・ノイマン・ボトルネックとは、コンピュータの中央処理装置(CPU)とメモリ間のデータ転送速度が、CPUの処理速度に比べて低速であるために、システム全体の性能が制約される問題である。</li>
              <li>「キャッシュメモリはメインメモリと比べてその容量は<b>Ⅰ:(b) 小さい</b>が、そのアクセス速度は<b>Ⅱ:(c) 高速</b>である。
                キャッシュメモリを有効に活用するためには、メモリアクセスの<b>Ⅲ:(f) 局所性</b>を高めることが重要である。
                例えば、大きな配列を走査する場合は、各要素へのアクセスをメモリ上で連続化することで、メモリアクセスの<b>Ⅳ:(h) 空間的</b><b>Ⅲ:(f) 局所性</b>を高めることができる。」</li>
              <li>
                  <ul>
                      <li>実効アクセス時間 \( t_e \) は、キャッシュメモリのヒット率 \( h \) を用いて次の式で表される：</li>
                      <li>\( t_e = h \cdot t + (1 - h) \cdot t_m \)</li>
                      <li>ここで、\( t_m = 10t \) である場合、実効アクセス時間は以下のように表される：</li>
                      <li>\( t_e = t(10 - 9h) \)</li>
                      <li>この関係をグラフに表すと、横軸をヒット率 \( h \)、縦軸を実効アクセス時間 \( t_e \) とした場合、ヒット率 \( h \) が 0 から 1 に増加するにつれて、実効アクセス時間 \( t_e \) は直線的に減少する。</li>
                  </ul>
              </li>
              <li>
                  <ul>
                      <li>幅32ビットのアドレスに対して、ダイレクトマップ方式を用いた場合、キャッシュメモリのタグビット数が16ビットであるとき、キャッシュインデックスは16ビット（32ビットのアドレスからタグビットとブロックオフセットビットを引いたもの）で構成されている。</li>
                      <li>キャッシュメモリの容量を増加させるために、4ウェイのセットアソシアティブ方式に変更すると、キャッシュインデックスのビット数は減少し、その分タグビット数が増加する。具体的には、4ウェイセットアソシアティブ方式ではキャッシュインデックスが2ビット減少し、その分タグビットが18ビットに増加する。</li>
                  </ul>
              </li>
            
            </ol>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>10進数の計算85-12を8ビット、2の補数表現で計算した場合の計算過程と結果を示せ。</p>
            <p><b>解答</b></p>
            <ol>
              <li>85を2進数で表すと、01010101である。</li>
              <li>12を2進数で表すと、00001100であり、ビット反転して1を加えると、11110100である。</li>
              <li>01010101と11110100を加算すると、1|01001001となる（|の左にある1は桁あふれ）。</li>
              <li>この結果を10進数に変換すると73であり、オーバーフローが発生せずに正しく計算されていることがわかる。</li>
            </ol>
          </div>
        </ul>
        <h3>キャッシュメモリ</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://medium-company.com/%e3%82%bb%e3%83%83%e3%83%88%e3%82%a2%e3%82%bd%e3%82%b7%e3%82%a2%e3%83%86%e3%82%a3%e3%83%96%e6%96%b9%e5%bc%8f/">セットアソシアティブ方式とは - ITを分かりやすく解説.html</a></p>
        <p><a href="https://e-words.jp/w/%E3%82%BB%E3%83%83%E3%83%88%E3%82%A2%E3%82%BD%E3%82%B7%E3%82%A2%E3%83%86%E3%82%A3%E3%83%96%E6%96%B9%E5%BC%8F.html">セットアソシアティブ方式とは - 意味をわかりやすく - IT用語辞典 e-Words.html</a></p>
        <p><a href="https://e-words.jp/w/%E3%82%B9%E3%83%A9%E3%83%83%E3%82%B7%E3%83%B3%E3%82%B0.html">スラッシングとは - 意味をわかりやすく - IT用語辞典 e-Words.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <ol>
              <li>キャッシュメモリはキャッシュライン（キャッシュブロック）を単位として管理される。
              キャッシュメモリのデータ格納構造としてよく用いられるセットアソシアティブ方式とはどのような方式か。</li>
              <li>キャッシュメモリのスラッシングとはどのような現象か。アプリケーションが受ける影響を含めて説明せよ。</li>
            </ol>
            <p><b>(1)の解答</b></p>
            <p>セットアソシアティブ方式は、キャッシュメモリを複数のセットに分割し、各セット内でデータを複数のキャッシュラインに柔軟に格納できる方式であり、直接マップ方式と完全アソシアティブ方式の中間的な特性を持つ。</p>
            <p><b>(2)の解答</b></p>
            <p>スラッシングとは、特定のメモリアクセスパターンが原因でキャッシュメモリからデータが頻繁に追い出され、結果的にキャッシュヒット率が低下してアプリケーションのパフォーマンスが著しく低下する現象。</p>
        </ul>
        <h3>プロセッサ</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://www.momoyama-usagi.com/entry/info-calc-sys17">うさぎでもわかる計算機システム（基本情報対応）　Part17　割込み（外部割込み・内部割込みの違い）・バッファ _ 工業大学生ももやまのうさぎ塾.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <p>プロセッサの実行モードである特権モードと非特権モードの違いについて、簡潔に述べよ。</p>
            <p><b>解答</b></p>
            <p>特権モードとは、プロセッサがシステム全体の制御を行うために特別な権限を持つ実行モードであり、OSカーネルやドライバなどが動作する。
                一方、非特権モードは、ユーザープログラムが動作するモードであり、システムリソースへの直接アクセスや重要な操作が制限されている。
                これにより、システムの安全性と安定性が保たれる。</p>
        </ul>
        <h3>IPアドレス</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://www.momoyama-usagi.com/entry/info-calc-sys02">うさぎでもわかる計算機システム　Part02　2の補数表現 [基本情報対応] _ 工業大学生ももやまのうさぎ塾.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <p>IPネットワークのあるサブネットに接続されたホストAを考える。ホストAのIPアドレスとサブネットマスクは10進ドット記法で以下に示す通りである。</p>
            <p>IPアドレス：10.1.4.139、サブネットマスク：255.255.255.192</p>
            <p>このとき、以下の問いに答えよ。</p>
            <ol>
              <li>このサブネットのブロードキャストアドレスの下位8ビットを16進数で表せ。</li>
              <li>このサブネットにはホストAを含めて最大何台のホスト（ルータも含む）が接続できるか求めよ。</li>
              <li>このサブネットを同じ大きさの4つのサブネットにさらに分割することを考える。
              このとき、分割で得られる4つのサブネットのネットワークアドレスを求め、それぞれ10進ドット記法で記せ。</li>
            </ol>
            <p><b>(1)の解答</b></p>
            <ol>
              <li>サブネットマスクについて、192を２進数で表すと11000000であるから、CIDR表記だと"/26"になる。</li>
              <li>したがって、ホスト部は6ビットである。</li>
              <li>IPアドレスの下位8ビットは、139を２進数で表すことで10001011とわかる。</li>
              <li>この8ビットのうち、ホスト部（後ろ6ビット）をすべて1に書き換えると、10111111となり、16進数でBFである。</li>
            </ol>
            <p><b>(2)の解答</b></p>
            <ol>
              <li>ホスト部の6ビットで表現できるのは、\(2^6 = 64\)アドレスである。</li>
              <li>ネットワークアドレス、ブロードキャストアドレスの2アドレスを除いて62アドレスをホストに割り当てることができる。</li>
            </ol>
            <p><b>(3)の解答</b></p>
            <ol>
              <li>サブネットを4つに分割する場合、\(4 = 2^2\)より、さらに2ビットをホスト部からネットワーク部として流用することになる。</li>
              <li>元のIPアドレスは10.1.4.10001011であり、ホスト部は6ビット、ネットワーク部は26ビットだった。</li>
              <li>したがって、分割を行うとホスト部は4ビットに、ネットワーク部は28ビットになる。</li>
              <li>ネットワークアドレスを求めたいので、ホスト部をすべて0にすると、10.1.4.1000|0000である。（"|"はネットワーク部とホスト部の境界を示す。）</li>
              <li>流用する2ビットで表現可能な値は、00, 01, 10, 11の4種類であり、これをネットワーク部の下位2ビット（流用した部分）とすればよい。</li>
              <li>以上より、得られる4つのサブネットのネットワークアドレスは次の通りである。</li>
              <ul>
                <li>10.1.4.10<b>00</b>0000 → 10.1.4.128</li>
                <li>10.1.4.10<b>01</b>0000 → 10.1.4.144</li>
                <li>10.1.4.10<b>10</b>0000 → 10.1.4.160</li>
                <li>10.1.4.10<b>11</b>0000 → 10.1.4.176</li>
              </ul>
            </ol>
          </div>
          <div class="example">
              <p><b>問題</b></p>
              <p>IPネットワークのあるサブネットに接続されたホストAを考える。ホストAのIPアドレスとサブネットマスクは10進ドット記法で以下に示す通りである。</p>
              <p>IPアドレス：172.16.2.181、サブネットマスク：255.255.255.248</p>
              <p>このとき、以下の問いに答えよ。</p>
              <ol>
                  <li>端末AのIPアドレスとサブネットマスクのそれぞれ下位8ビットを2進数で表せ。</li>
                  <li>端末Aが接続しているサブネットのネットワークアドレスとブロードキャストアドレスを求め、それぞれ10進ドット記法で示せ。</li>
                  <li>端末Aのサブネットを拡張し、以下に示すIPアドレスを有する端末B、Cが端末Aと同じサブネットに含まれるようにするためには、サブネットマスクをどのように設定すればよいか。(端末B: 172.16.2.185、端末C: 172.16.2.174)</li>
              </ol>
              <p><b>(1)の解答</b></p>
              <ol>
                  <li>IPアドレスの下位8ビット: 181 → 2進数で表すと"10110101"</li>
                  <li>サブネットマスクの下位8ビット: 248 → 2進数で表すと"11111000"</li>
              </ol>
              <p><b>(2)の解答</b></p>
              <p>まず、ネットワークアドレスを求める。</p>
              <ol>
                  <li>10110101 AND 11111000 = 10110000 (下位8ビット)</li>
                  <li>上位24ビットはそのままなので、172.16.2.176 となる。</li>
              </ol>
              <p>次に、ブロードキャストアドレスを求める。</p>
              <ol>
                  <li>ネットワークアドレスのホスト部のすべてのビットを1にしたものがブロードキャストアドレスである。</li>
                  <li>下位8ビット: 10111111 (ブロードキャストアドレス)</li>
                  <li>上位24ビットはそのままなので、172.16.2.183 となる。</li>
              </ol>
              <p><b>(3)の解答</b></p>
              <ol>
                  <li>マスク長は元々29である。</li>
                  <li>これを27に変更すれば、10100000～10111111の範囲、つまり、172.16.2.160～172.16.2.191の範囲をカバーすることができる。</li>
                  <li>したがって、求めるサブネットマスクは255.255.255.224であり、ネットワークアドレスは172.16.2.160である。</li>
              </ol>
          </div>
        </ul>
        <h3>OSスケジューラ</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://www.momoyama-usagi.com/entry/info-calc-sys18">うさぎでもわかる計算機システム（基本情報対応）　Part18　プロセスの3状態・スケジューリングアルゴリズム _ 工業大学生ももやまのうさぎ塾.html</a></p>
        <p>参考にした本は以下のとおり。</p>
        <p><a href="https://www.amazon.co.jp/%E4%BB%A4%E5%92%8C06%E5%B9%B4%E3%80%90%E6%98%A5%E6%9C%9F%E3%80%91%E3%80%90%E7%A7%8B%E6%9C%9F%E3%80%91-%E5%BF%9C%E7%94%A8%E6%83%85%E5%A0%B1%E6%8A%80%E8%A1%93%E8%80%85-%E5%90%88%E6%A0%BC%E6%95%99%E6%9C%AC-%E5%A4%A7%E6%BB%9D-%E3%81%BF%E3%82%84%E5%AD%90/dp/4297138654/ref=sr_1_1_sspa?adgrpid=150605272950&dib=eyJ2IjoiMSJ9.S5cWzjFkp_nrIqu_5ApE1QWMXCbFLFmwkG8mbhI-YBh4T0pbirPKpWiVtbv7TQ4Vyyf8_N8-tgy_OInBZ68fif15QmWUr69nJIbVclCOHUJ-w90GQURndbGISfc55NDmfWz92sgNct-xzXTWB-hIBlqcIjCPZNK1XI6rbQvxsL6q1n9CHEtizf2OgL__nNze8sDGqR0Bo_s1fEtUKuvc8wkRAGFAIHUZaRrtfu1VPa0.hzxEdIOow2NBUwzQYUtYcoXPOgRX4_TsYf832Qx1J3k&dib_tag=se&hvadid=679063608944&hvdev=c&hvqmt=e&hvtargid=kwd-1992164082181&hydadcr=4074_13378684&jp-ad-ap=0&keywords=%E5%BF%9C%E7%94%A8%E6%83%85%E5%A0%B1%E6%8A%80%E8%A1%93%E8%80%85%E8%A9%A6%E9%A8%93+%E5%8F%82%E8%80%83%E6%9B%B8&qid=1723515043&s=books&sr=1-1-spons&sp_csd=d2lkZ2V0TmFtZT1zcF9hdGY&psc=1">令和06年【春期】【秋期】 応用情報技術者 合格教本</a></p>
        <ul>
            <li><b>プリエンプション</b>：実行中のタスクのCPU使用権を奪い、実行を一時的に中断させる動作のこと。</li>
            <li><b>オーバーヘッド</b>：コンピュータシステムやソフトウェアが特定の機能を実行するために必要な追加の処理やリソースのこと。タスクの切り替えに要する時間やコストなど。</li>
            <li><b>タスクのスケジューリング方式</b></li>
            <ul>
                <li><b>到着順方式(First Come First Served)</b>：タスクには優先度をもたせず、実行可能になった順に実行し、タスクの実行が終了するまでプリエンプションは発生しない。</li>
                <li><b>優先順位方式</b>：各タスクに与えた優先度の高い順に実行する方式。
                    この方式では、現在実行しているタスクよりも高い優先度を持つタスクが実行可能状態になると、タスクの実行はプリエンプションされる。
                    優先順位方式のうち、タスクの優先度をあらかじめ決めた値から変えない方式を<b>静的優先順位方式</b>という。
                    この方式では、優先度が固定化されるため、優先度の低いタスクにはCPU使用権が与えられず、なかなか実行できないという<b>スタベーション(starvation)</b>が起こる可能性がある。
                    このスタベーションを回避するため、待ち時間が一定時間以上となったタスクの優先度を動的に高くして、実行できるようにした方式が<b>動的優先度順方式</b>である。
                    優先度を高くして実行の可能性を与えることを<b>エージング(aging)</b>ということから、<b>エージング方式</b>とも呼ばれる。
                </li>
                <li><b>ラウンドロビン方式</b>：実行可能待ち行列の先頭のタスクから順にCPU時間（<b>タイムクォンタム</b>）を割り当て、そのタスクがタイムクォンタム内に終了しない場合は、実行を中断して実行可能待ち行列の末尾に移し、次のタスクにCPUを割り当てる、ということを繰り返す方式。
                    実行可能待ち行列にあるタスクを平等に実行できるため、<b>タイムシェアリングシステム(TSS: Time Sharing System)</b>のスケジューリングに適している。
                    タイムクォンタムを長くすれば到着順方式に近づき、短くすれば処理時間が短いタスクの応答時間が短くなるため、結果として処理時間順方式に近づく。
                </li>
                <li><b>フィードバック待ち行列方式</b>：ラウンドロビン方式に優先度を加えた方式であり、言い換えれば、多段のラウンドロビン方式である。
                    優先度ごとにタイムクォンタムが異なる待ち行列をもつため、<b>多重待ち行列方式</b>とも呼ばれる。
                    この方式では、最初に最も高い優先度を割り当て、処理が終了しない場合は、順次その優先度を低くしていく。
                    これはCPUを占有しやすいタスクの優先度を徐々に下げるという考えだが、これによりスタベーション問題が発生するため、エージング手法などを用いての対応が必要となる。
                </li>
                <li><b>処理時間順方式(Shortest Processing Time First)</b>：処理時間の短いタスクから順に実行する方式。
                    ただし、処理時間を前もって予測できないため、実際にはフィードバック待ち行列方式として実現される。
                </li>
            </ul>
            <li><b>ターンアラウンド時間</b>：ジョブの到着から完了までにかかる総時間</li>
            <li><b>レスポンス時間</b>：ジョブの到着から最初に処理が開始されるまでの時間</li>
            <li>具体例</li>
            <div class="example">
            <p><b>問題</b></p>
            <p>下記の3つのOSスケジューラに関する以下の問いに答えよ。</p>
            <ol>
              <li>First Come, First Served (FCFS)</li>
              <li>Shortest Job First (SJF)</li>
              <li>Round-Robin (RR)</li>
            </ol>
            <p>(1) 表1の到着時刻および処理時間のジョブを実行する場合のスケジューリング結果をそれぞれ図示せよ。
              なお、FCFS及びSJFはノンプリエンプティブ、RRはプリエンプティブなスケジューラとし、ジョブ切り替えに伴うオーバーヘッドは無視できるものとする。
              また、RRのタイムクォンタムは3とする。</p>
            <table>
            <tr>
                <th>ジョブ</th>
                <th>到着時刻</th>
                <th>処理に要する時間</th>
            </tr>
            <tr>
                <td>A</td>
                <td>0</td>
                <td>12</td>
            </tr>
            <tr>
                <td>B</td>
                <td>1</td>
                <td>6</td>
            </tr>
            <tr>
                <td>C</td>
                <td>2</td>
                <td>3</td>
            </tr>
            </table>
            <p>(2) それぞれのスケジューラにおける平均ターンアラウンド時間及び平均レスポンス時間を計算して示せ。計算過程についても記述せよ。</p>
            <p>(3) 現実のOSスケジューリングでは、優先度付きのスケジューリングが広く用いられる。
            優先度付きのスケジューリングにおいて、スタベーション（飢餓状態）の問題はどのような場合に発生するか、またその解決案も簡潔に記述せよ。</p>
            <p><b>(1)の解答</b></p>
            <p>a) FCFS</p>
            <ul>
                <li>0-12 : A(12/12)</li>
                <li>12-18 : B(6/6)</li>
                <li>18-21 : C(3/3)</li>
            </ul>
            <p>b) SJF</p>
            <ul>
                <li>0-12 : A(12/12)</li>
                <li>12-15 : C(3/3)</li>
                <li>15-21 : B(6/6)</li>
            </ul>
            <p>c) RR</p>
            <ul>
                <li>0-3 : A(3/12)</li>
                <li>3-6 : B(3/6)</li>
                <li>6-9 : C(3/3)</li>
                <li>9-12 : A(6/12)</li>
                <li>12-15 : B(6/6)</li>
                <li>15-21 : A(12/12)</li>
            </ul>
            <p><b>(2)の解答</b></p>
            <p>a) FCFS</p>
            <ul>
                <li>各ターンアラウンド時間 A : \(12-0=12\), B : \(18-1=17\), C : \(21-2=19\)</li>
                <li>平均ターンアラウンド時間 \(\frac{12+17+19}{3} = 16\)</li>
                <li>各レスポンス時間 A : \(0-0=0\), B : \(12-1=11\), C : \(18-2=16\)</li>
                <li>平均レスポンス時間 \(\frac{0+11+16}{3} = 9\)</li>
            </ul>
            <p>b) SJF</p>
            <ul>
                <li>各ターンアラウンド時間 A : \(12-0=12\), B : \(21-1=20\), C : \(15-2=13\)</li>
                <li>平均ターンアラウンド時間 \(\frac{12+20+13}{3} = 15\)</li>
                <li>各レスポンス時間 A : \(0-0=0\), B : \(15-1=14\), C : \(12-2=10\)</li>
                <li>平均レスポンス時間 \(\frac{0+14+10}{3} = 8\)</li>
            </ul>
            <p>c) RR</p>
            <ul>
                <li>各ターンアラウンド時間 A : \(21-0=21\), B : \(15-1=14\), C : \(9-2=7\)</li>
                <li>平均ターンアラウンド時間 \(\frac{21+14+7}{3} = 14\)</li>
                <li>各レスポンス時間 A : \(0-0=0\), B : \(3-1=2\), C : \(6-2=4\)</li>
                <li>平均レスポンス時間 \(\frac{0+2+4}{3} = 2\)</li>
            </ul>
            <p><b>(3)の解答</b></p>
            <p>スタベーションは、低優先度のプロセスが実行されず、無限に待たされる場合に発生する。
                これは、システムが常に高優先度のプロセスを実行し続けることで、低優先度のプロセスにCPU時間が割り当てられないためである。
                この問題の解決策としては、エイジング（aging）が有効である。
                エイジングとは、時間の経過とともに待機しているプロセスの優先度を徐々に引き上げる方法であり、
                これにより低優先度のプロセスも一定の時間が経過すれば実行されるようになり、スタベーションを防ぐことができる。</p>
            </div>
        </ul>
        <h3>論理回路</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://www.momoyama-usagi.com/entry/info-karnaugh-map">うさぎでもわかる論理回路　カルノー図編 _ 工業大学生ももやまのうさぎ塾.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <p>論理式 <strong>Q = A'BC' + A'B'C + ABC' + BC</strong> のカルノー図を回答用紙に図示し、それを用いて簡単化した論理式を示せ。</p>
            <p><b>解答</b></p>
            <table>
                <tr>
                    <th colspan="2"></th>
                    <th colspan="4">BC</th>
                </tr>
                <tr>
                    <th colspan="2"></th>
                    <td>00</td>
                    <td>01</td>
                    <td>11</td>
                    <td>10</td>
                </tr>
                <tr>
                    <th rowspan="2">A</th>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                    <td>1</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                    <td>1</td>
                </tr>
            </table>
            <p>したがって、Q = B + A'Cを得る。</p>
          </div>
        </ul>
        <h3>ページング方式</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://www.momoyama-usagi.com/entry/info-calc-sys19">うさぎでもわかる計算機システム（基本情報対応）　Part19　仮想記憶とページング（4GBの壁の正体は？） _ 工業大学生ももやまのうさぎ塾.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <p>ページング方式によるメモリ管理及び仮想記憶に関する以下の問いに答えよ。</p>
            <ol>
                <li>ページフォルトとはどのような現象か，括弧内の語句を用いて簡潔に述べよ。</li>
                <li>ページサイズを拡大することにより生ずる利点と欠点について簡潔に述べよ。</li>
            </ol>
            <p><b>(1)の解答</b></p>
            <p>ページフォールトとは、プログラムがアクセスしようとしたメモリページが物理メモリ上に存在しないため、オペレーティングシステムがディスクからそのページを読み込む必要がある状況、または、その割込みを指す。</p>
            <p><b>(2)の解答</b></p>
            <p>大きなサイズのページを管理できるため、ページ数を少なくでき、管理情報に使うメモリサイズを削減できる。
            また、管理情報の検索にかかる時間の削減が可能である。
            しかし、無駄に大きなページになって何も入らない場所が増えるため、ページイン、ページアウトするときにディスクアクセス量が大きくなって時間がかかり、レスポンスが低下する。</p>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>物理アドレス空間 8Mバイトの小規模な主記憶装置と十分な容量の補助記憶装置を用いて，仮想アドレス空間 4G バイトのページング方式の仮想記憶を実現することを考える。
                ただしページサイズは 4K バイトとし，アドレスはバイト単位に割り当てるものとする。また，\(1G = 2^30，1M = 2^20，1K = 2^10\) である。このとき以下の設問に答えよ。</p>
            <ol>
                <li>仮想アドレスと物理アドレスのビット幅はそれぞれ何ビットか。</li>
                <li>仮想記憶を1段ページングで実現すると仮定し，ページテーブルのエントリ1つ当たりの大きさを2バイトとするとき，ページテーブル全体の大きさは何バイトになるか。</li>
                <li>アドレス空間やページサイズは変更せずに，主記憶上に置かれるページテーブルの領域を小さく抑えるためにはどのような方法が考えられるか。その方法の短所も含めて簡潔に説明せよ。</li>
                <li>ページング方式の仮想記憶におけるスラッシングとは何か。簡潔に説明せよ。</li>
            </ol>
            <p><b>(1)の解答</b></p>
            <p>
                仮想アドレス空間は 4G バイト = 2³² バイトである。したがって、仮想アドレスのビット幅は 32 ビットである。<br>
                物理アドレス空間は 8M バイト = 2²³ バイトであるため、物理アドレスのビット幅は 23 ビットである。
            </p>
            <p><b>(2)の解答</b></p>
            <p>
                ページサイズは 4K バイト = 2¹² バイトである。仮想アドレス空間は 4G バイト = 2³² バイトであるため、ページ数は 
                \( \frac{2^{32}}{2^{12}} = 2^{20} \) ページとなる。<br>
                ページテーブルのエントリ 1 つ当たりの大きさは 2 バイトであるので、ページテーブル全体の大きさは 
                \( 2^{20} \times 2 = 2^{21} \) バイト、つまり 2M バイトとなる。
            </p>
            <p><b>(3)の解答</b></p>
            <p>
                <strong>方法:</strong> ページテーブルを階層化する（多段ページング）ことである。<br>
                <strong>短所:</strong> 階層化により、ページテーブルアクセス時のオーバーヘッドが増加し、メモリアクセスの遅延が発生する可能性がある。
            </p>
            <p><b>(4)の解答</b></p>
            <p>
                スラッシングとは、主記憶のページング領域が頻繁に入れ替わることで、ページフォールトが頻発し、システムのパフォーマンスが著しく低下する現象のことである。
            </p>
          </div>
        </ul>
        <h3>OSの入出力</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://ja.gadget-info.com/difference-between-interrupt">OSにおける割り込みとポーリングの違い.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <ol>
                <li>OSの入出力におけるポーリング方式と割り込み方式について、それぞれ簡潔に説明せよ。また双方の利点と欠点について述べよ。</li>
                <li>同じく入出力に関して、DMAコントローラとは何か簡潔に説明せよ。</li>
            </ol>
            <p><b>(1)の解答</b></p>
            <p>ポーリング方式：CPUが定期的に各入出力デバイスの状態を確認し、処理が必要かどうかを判断する方式。
            実装が比較的簡単で、ハードウェアのサポートが少ない環境でも動作可能だが、
            CPUが常にデバイスの状態をチェックするため、他の処理が滞る可能性があり、非効率的。</p>
            <p>割込み方式：入出力デバイスからの割り込み信号により、CPUが必要なときにのみデバイスを処理する方式。
            CPUの効率を向上させ、他の処理と入出力処理の並行性を確保できるが、
            ハードウェアのサポートが必要であり、システムの設計が複雑になる。</p>
            <p><b>(2)の解答</b></p>
            <p>ダイレクトメモリアクセス（DMA）を実現するためのコントローラで、CPUを介さずに入出力デバイスとメモリ間のデータ転送を直接行うハードウェアモジュール。
                これにより、CPUの負荷を軽減し、入出力処理を高速化することができる。</p>
          </div>
        </ul>
        <h3>C言語</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://temp-soft.com/blog/2020/11/19/c-introductionextra-swap/">【独学Ｃ言語入門 番外編】swap関数を作成しよう【ポインタ応用①】 _ Temp Soft ブログ.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <p>図1に示すC言語のプログラムがある。関数 <code>koukan</code> を呼び出すことにより、
                <code>int</code> 型変数 <code>a</code> と <code>b</code> の値を入れ替えたい。
                図1のプログラム内の(A)～(D)の空欄に入る内容について、解答用紙に記述せよ。</p>
            <pre>
            #include &lt;stdio.h&gt;
        
            void koukan( (A) );
        
            int main()
            {
                int a, b;
                a = 0; b = 1;
        
                koukan( (B) );
        
                printf("%d %d\n", a, b);
                return 0;
            }
        
            void koukan( (C) )
            {
                (D)
            }
            </pre>

            <p><b>解答</b></p>
            <pre>
            #include &lt;stdio.h&gt;
        
            void koukan(int *x, int *y);
        
            int main()
            {
                int a, b;
                a = 0; b = 1;
        
                koukan(&a, &b);
        
                printf("%d %d\n", a, b);
                return 0;
            }
        
            void koukan(int *x, int *y)
            {
                int temp;
                temp = *x;
                *x = *y;
                *y = temp;
            }
            </pre>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>以下のソースコードは、2つの複素数の積を計算して標準出力に表示するC言語プログラムである。
            空欄を適切に埋めてプログラムを完成させよ。</p>
            <pre>
            #include &lt;stdio.h&gt;

            （ア）;
            
            struct COMPLEX MultiComplex(struct COMPLEX a, struct COMPLEX b);
            void PrintComplex(struct COMPLEX a);
            
            int main(void)
            {
                struct COMPLEX a = { 1.0, 2.0 }, b = { 3.0, 5.0 }, c;
            
                c = MultiComplex(a, b);
                PrintComplex(c);
                return 0;
            }
            
            struct COMPLEX MultiComplex(struct COMPLEX a, struct COMPLEX b) {
                struct COMPLEX c;
                c.re = a.re * b.re - a.im * b.im;
                c.im = （イ）;
                return c;
            }
            
            void PrintComplex(struct COMPLEX a) {
                printf("%f%s%fi", a.re, (a.im &gt= 0.0) ? "+" : "", a.im);
            }
            </pre>

            <p><b>解答</b></p>
            <p>（ア）には、複素数を表す構造体の宣言が必要である。</p>
            <p>（イ）には、複素数の虚部の計算式が入る。</p>
            <pre>
            #include &lt;stdio.h&gt;

            struct COMPLEX {
                double re;
                double im;
            };
            
            struct COMPLEX MultiComplex(struct COMPLEX a, struct COMPLEX b);
            void PrintComplex(struct COMPLEX a);
            
            int main(void)
            {
                struct COMPLEX a = { 1.0, 2.0 }, b = { 3.0, 5.0 }, c;
            
                c = MultiComplex(a, b);
                PrintComplex(c);
                return 0;
            }
            
            struct COMPLEX MultiComplex(struct COMPLEX a, struct COMPLEX b) {
                struct COMPLEX c;
                c.re = a.re * b.re - a.im * b.im;
                c.im = a.re * b.im + a.im * b.re;
                return c;
            }
            
            void PrintComplex(struct COMPLEX a) {
                printf("%f%s%fi", a.re, (a.im &gt= 0.0) ? "+" : "", a.im);
            }
            </pre>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>以下のソースコードは、標準入力から読み込んだ自然数に対してその階乗を計算して標準出力に表示するC言語プログラムである。
            空欄を適切に埋めてプログラムを完成させよ。</p>
            <pre>
            #include &lt;stdio.h&gt;

            int main(void)
            {
                int a, b;
                scanf("%d", &a);
                if (a &lt 1) {
                    printf("自然数を入力してください\n");
                } else {
                    b = factorial(a);
                    printf("%d\n", b);
                }
                return 0;
            }
            
            int factorial(int n) {
                if (n == 1) {
                    return （ウ）;  
                } else {
                    return （エ）;
                }
            }
            </pre>

            <p><b>解答</b></p>
            <pre>
            #include &lt;stdio.h&gt;

            int main(void)
            {
                int a, b;
                scanf("%d", &a);
                if (a &lt 1) {
                    printf("自然数を入力してください\n");
                } else {
                    b = factorial(a);
                    printf("%d\n", b);
                }
                return 0;
            }
            
            int factorial(int n) {
                if (n == 1) {
                    return 1;  
                } else {
                    return n * factorial(n - 1);  
                }
            }
            </pre>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>以下のソースコードは、乱数を用いて近似的に求めた半径1の四分位円の面積から、円周率を計算して標準出力に表示するC言語プログラムである。
            空欄を適切に埋めてプログラムを完成させよ。
            ここで<code>rand()</code>は0以上<code>RAND_MAX</code>以下の一様整数乱数を返す関数である。</p>
            <pre>
            #include &lt;stdio.h&gt;
            #include &lt;stdlib.h&gt;

            int main(void)
            {
                int i, count;
                int max_iter = 1000000;
                double x, y, pi;
            
                （オ）;  
                for (i = 0; i &lt max_iter; i++) {
                    x = (double)rand() / (RAND_MAX + 1.0);
                    y = (double)rand() / (RAND_MAX + 1.0);
            
                    if (x * x + y * y &lt 1) {
                        count++;
                    }
                }
            
                pi = 4.0 * （カ）;
                printf("%f\n", pi);
                return 0;
            }
            </pre>

            <p><b>解答</b></p>
            <p>空欄 (オ) には、乱数によって四分円の内部に入った点のカウントを初期化するために <code>count = 0;</code>を記述する。
                これは、四分円内にランダムに生成された点の数を計算するための変数である。</p>
            <p>空欄 (カ) には、四分円内に入った点の割合を基にして\(\pi\)を計算する式が入る。
                四分円の面積は\(\frac{\pi}{4}\)で表されるため、次のように計算する：<code>count / (double)max_iter</code></p>
            <pre>
            #include &lt;stdio.h&gt;
            #include &lt;stdlib.h&gt;

            int main(void)
            {
                int i, count;
                int max_iter = 1000000;
                double x, y, pi;
            
                count = 0;
                for (i = 0; i &lt max_iter; i++) {
                    x = (double)rand() / (RAND_MAX + 1.0);
                    y = (double)rand() / (RAND_MAX + 1.0);
            
                    if (x * x + y * y &lt 1) {
                        count++;
                    }
                }
            
                pi = 4.0 * count / (double)max_iter;
                printf("%f\n", pi);
                return 0;
            }
            </pre>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>以下のソースコードは、与えた関数<code>func</code>の定積分を長方形近似で計算して標準出力に表示するC言語プログラムである。
            空欄を適切に埋めてプログラムを完成させよ。</p>
            <pre>
            #include &lt;stdio.h&gt;

            double func(double x);
            double integral(（キ）, double min, double max, int steps); 
            
            int main(void)
            {
                double min = 0.0;
                double max = 1.0;
                int steps = 1000;
                double s;
            
                s = integral(（ク）, min, max, steps);
                printf("%f\n", s);
                return 0;
            }
            
            double func(double x) {
                return x * x * x;
            }
            
            double integral(（キ）, double min, double max, int steps) {
                int i;
                double x = min;
                double h = (max - min) / steps;
                double sum = 0.0;
            
                for (i = 0; i &lt steps; i++) {
                    sum += fp(x);
                    x += h;
                }
            
                return (h * sum);
            }
            </pre>

            <p><b>解答</b></p>
            <p>空欄 (キ) には、関数ポインタ double (*fp)(double) が入る。これは、func のポインタを受け取るための引数である。</p>
            <p>空欄 (ク) には、func 関数のポインタを渡す。この関数ポインタは、定積分を計算するために使用される。</p>
            <pre>
            #include &lt;stdio.h&gt;

            double func(double x);
            double integral(double (*fp)(double), double min, double max, int steps);  
            
            int main(void)
            {
                double min = 0.0;
                double max = 1.0;
                int steps = 1000;
                double s;
            
                s = integral(func, min, max, steps);  
                printf("%f\n", s);
                return 0;
            }
            
            double func(double x) {
                return x * x * x;
            }
            
            double integral(double (*fp)(double), double min, double max, int steps) {
                int i;
                double x = min;
                double h = (max - min) / steps;
                double sum = 0.0;
            
                for (i = 0; i &lt steps; i++) {
                    sum += fp(x);
                    x += h;
                }
            
                return (h * sum);
            }
            </pre>
          </div>
          <div class="example">
            <p><b>問題</b></p>
            <p>2001年1月1日は月曜日であった。以下のソースコードは、2001年の日付を標準入力から読み込み、曜日を標準出力に表示するC言語プログラムである。
            日付は、例えば5月3日は5/3、10月11日は10/11という形式で与える。ただし、存在しない日付に対するエラーチェックは省略している。
            曜日は英語で出力する。なお、2001年は｢うるう年｣ではなく、2月は28日間である。
            空欄を適切に埋めてプログラムを完成させよ。</p>
            <pre>
            #include &lt;stdio.h&gt;

            int main(void)
            {
                int i, month, day;
                int total_days = 0;
                int days_of_month[] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
                （ケ） day_of_week[] = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };  
            
                scanf("%d/%d", &month, &day);
            
                for (i = 0; i &lt month-1; i++) {
                    total_days += days_of_month[i];
                }
            
                total_days += day;
            
                printf("%s\n", day_of_week[（コ）]); 
                return 0;
            }
            </pre>

            <p><b>解答</b></p>
            <p>空欄 (ケ) には、曜日を格納するための配列 day_of_week の定義が必要である。</p>
            <p>空欄 (コ) には、計算された日数 total_days に対応する曜日を配列 day_of_week から取得するために、total_days % 7 というインデックスを使用する。この操作により、日付が何曜日に当たるかを求めることができる。</p>
            <pre>
            #include &lt;stdio.h&gt;

            int main(void)
            {
                int i, month, day;
                int total_days = 0;
                int days_of_month[] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
                char* day_of_week[] = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };
            
                scanf("%d/%d", &month, &day);
            
                for (i = 0; i &lt month-1; i++) {
                    total_days += days_of_month[i];
                }
            
                total_days += day;
            
                printf("%s\n", day_of_week[total_days % 7]);
                return 0;
            }
            </pre>
          </div>
        </ul>
        <h3>コンピュータネットワーク</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://it-biz.online/it-skills/osi-reference-model/">OSI参照モデルとは？役割・覚え方をわかりやすく３分で解説 _ ビズドットオンライン.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <ol>
                <li>OSI参照モデルにおけるデータリンク層とネットワーク層の役割の違いを、200文字程度で説明せよ。なお、説明にはMACアドレスとIPアドレスがそれぞれどの層で利用されるかを含めること。</li>
                <li>DNSはどのような役割を果たすものかを150文字程度で説明せよ。</li>
            </ol>
            <p><b>(1)の解答</b></p>
            <p>OSI参照モデルにおいて、データリンク層は隣接するノード間でのデータ転送を担当し、物理的なネットワークの信頼性を確保する役割を持つ。
                この層ではMACアドレスが利用され、ネットワーク内のデバイスを識別する。
                一方、ネットワーク層は異なるネットワーク間でのデータ転送を管理し、データのルーティングを行う層である。
                この層ではIPアドレスが使用され、グローバルにデバイスを識別し、最適な経路を選択する。</p>
            <p><b>(2)の解答</b></p>
            <p>DNS（Domain Name System）は、インターネット上でドメイン名を対応するIPアドレスに変換する役割を果たすシステムである。
                これにより、ユーザーは覚えやすいドメイン名を入力するだけで、目的のウェブサイトやサーバーにアクセスできる。
                DNSは階層構造で管理され、各レベルで異なる部分の名前解決を担当する。
                これにより、インターネット上の通信やリソースのアクセスがスムーズに行えるようになっている。</p>
          </div>
        </ul>
        <h3>TCP・UDP</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://hldc.co.jp/blog/2019/07/11/2819/">TCPとUDPの違いとは？～Ethernet接続におけるオーバーヘッド削減ノウハウ～ _ ハートランド・ザ・ワールド.html</a></p>
        <ul>
          <li>具体例</li>
          <div class="example">
            <p><b>問題</b></p>
            <ol>
                <li>TCPはUDPと比較して信頼性を有するプロトコルである。TCPは通信の信頼性を提供するためにどのような機能を実現しているか、150文字程度で説明せよ。</li>
                <li>インターネットでは、トランスポート層のプロトコルとしてTCPではなくUDPが用いられる場面がある。TCPと比較してUDPを広域通信で用いる場合の利点やアプリケーション例について、150文字程度で説明せよ。</li>
            </ol>
            <p><b>(1)の解答</b></p>
            <p>TCPは信頼性を確保するために、データの順序制御、パケットの再送制御、エラーチェック、フロー制御、接続確立と終了のハンドシェイクを実現している。これにより、通信が正確で完全に行われることを保証し、データが損失なく送受信されることを確保する。</p>
            <p><b>(2)の解答</b></p>
            <p>UDPはTCPと比較して接続の確立や状態管理が不要であり、オーバーヘッドが少なく、リアルタイム性が求められる通信に適している。これにより、遅延が少なく高速な通信が可能であり、VoIP、ストリーミング、オンラインゲームなどのアプリケーションで広く利用されている。</p>
          </div>
        </ul>
        <h3>ノイマン型計算機</h3>
        <p>参考にしたサイトは以下のとおり。</p>
        <p><a href="https://nw.tsuda.ac.jp/lec/risc/risc.html">Chapter 1. The Foundation of Computer System.html</a></p>
        <ul>
            <li>CPUが直接実行する機械語プログラムはデータとともに<b>主記憶</b>に格納される。</li>
            <li>CPUは<b>プログラムカウンタ</b>が示す番地に格納されている命令語を<b>主記憶</b>から読み出し、その意味を解釈し、逐次実行する。</li>
            <li>一般に個々の命令語は命令の種類を示す<b>オペコード</b>と命令の対象を示す<b>オペランド</b>から構成される。</li>
            <li><b>オペランド</b>が対象のデータの格納番地である場合には、これを<b>間接</b>アドレッシングと呼ぶ。</li>
        </ul>
      </section>
    </main>
</body>
</html>
