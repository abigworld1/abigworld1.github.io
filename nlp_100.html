<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【自然言語処理 ～言語処理100本ノック～】走る作曲家のAIカフェ</title>
    <link rel="stylesheet" href="style.css">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1050827580219099"
     crossorigin="anonymous"></script>
</head>
<body>
    <header>
        <h1>走る作曲家のAIカフェ</h1>
        <nav>
            <ul>
                <li><a href="index.html">ホーム</a></li>
                <li><a href="study.html">勉強</a></li>
                <li><a href="music.html">音楽</a></li>
                <li><a href="sports.html">スポーツ</a></li>
            </ul>
        </nav>
    </header>
    <main>
      <section>
        <h2>言語処理100本ノック</h2>
        <p><a href="https://nlp100.github.io/ja/">言語処理100本ノック</a>に挑戦します。</p>
        <p>使用言語はPythonです。</p>
      </section>
      <section>
        <h2>第1章：準備運動</h2>
        <h3>00.文字列の逆順</h3>
        <p><b>文字列”stressed”の文字を逆に（末尾から先頭に向かって）並べた文字列を得よ．</b></p>
        <pre><code>
# 文字列の定義
text = "stressed"

# 文字列を逆順に並べ替える
reversed_text = text[::-1]

# 結果を出力
print(reversed_text)
        </code></pre>
        <p><code2>text[start:end:step]</code2>というスライスの一般的な形式で、<code2>start</code2>と<code2>end</code2>を省略し、<code2>step</code2>に<code2>-1</code2>を指定することで、逆順に文字を取得できる。</p>
        <h3>01.「パタトクカシーー」</h3>
        <p><b>「パタトクカシーー」という文字列の1,3,5,7文字目を取り出して連結した文字列を得よ．</b></p>
        <pre><code>
# 文字列の定義
text = "パタトクカシーー"

# 1, 3, 5, 7文字目を取り出して連結
result = text[0] + text[2] + text[4] + text[6]

# 結果を出力
print(result)
        </code></pre>
        <h3>02.「パトカー」＋「タクシー」＝「パタトクカシーー」</h3>
        <p><b>「パトカー」＋「タクシー」の文字を先頭から交互に連結して文字列「パタトクカシーー」を得よ．</b></p>
        <pre><code>
# 文字列の定義
text1 = &quot;パトカー&quot;
text2 = &quot;タクシー&quot;

# 交互に文字を取り出して連結
result = &#039;&#039;.join([a + b for a, b in zip(text1, text2)])

# 結果を出力
print(result)
        </code></pre>
          <p>Pythonの<code2>zip</code2>関数を使うことで、2つの文字列を並列に処理できる。</p>
          <p><code2>zip(text1, text2)</code2>は、<code2>text1</code2>と<code2>text2</code2>のそれぞれ対応する位置の文字をペアにする。</p>
          <p>リスト内包表記を用いて、<code2>a + b</code2>という形で交互に文字を連結する。</p>
          <p><code2>''.join([...])</code2>で、リスト内の連結された文字を1つの文字列にまとめる。</p>
          <h3>03.円周率</h3>
          <p><b>“Now I need a drink, alcoholic of course, after the heavy lectures involving quantum mechanics.”という文を単語に分解し，各単語の（アルファベットの）文字数を先頭から出現順に並べたリストを作成せよ．</b></p>
        <pre><code>
# 与えられた文章
sentence = &quot;Now I need a drink, alcoholic of course, after the heavy lectures involving quantum mechanics.&quot;

# 単語に分解（句読点を除去）
words = sentence.replace(&quot;,&quot;, &quot;&quot;).replace(&quot;.&quot;, &quot;&quot;).split()

# 各単語の文字数を計算
word_lengths = [len(word) for word in words]

# 結果を出力
print(word_lengths)
        </code></pre>
          <p><code2>.replace(",", "")</code2>と<code2>.replace(".", "")</code2>を使って、カンマやピリオドなどの句読点を取り除く。これにより、単語だけを扱えるようにする。</p>
          <p><code2>.split()</code2>を使うことで、文章を単語ごとに分割し、リスト<code2>words</code2>に格納する。</p>
          <p>リスト内包表記を使って、<code2>[len(word) for word in words]</code2>で各単語の文字数を計算し、その結果を<code2>word_lengths</code2>に格納する。</p>
          <h3>04.元素記号</h3>
          <p><b>“Hi He Lied Because Boron Could Not Oxidize Fluorine. New Nations Might Also Sign Peace Security Clause. Arthur King Can.”という文を単語に分解し，1, 5, 6, 7, 8, 9, 15, 16, 19番目の単語は先頭の1文字，それ以外の単語は先頭の2文字を取り出し，取り出した文字列から単語の位置（先頭から何番目の単語か）への連想配列（辞書型もしくはマップ型）を作成せよ．</b></p>
        <pre><code>
# 与えられた文章
sentence = &quot;Hi He Lied Because Boron Could Not Oxidize Fluorine. New Nations Might Also Sign Peace Security Clause. Arthur King Can.&quot;

# 句読点を除去して単語に分解
words = sentence.replace(&quot;.&quot;, &quot;&quot;).split()

# 1文字だけを取り出す単語のインデックス（1から始まる）
one_char_indices = [1, 5, 6, 7, 8, 9, 15, 16, 19]

# 結果を格納する辞書
word_map = {}

# 各単語を処理して辞書に格納
for i, word in enumerate(words, 1):  # 単語の位置が1から始まるようにenumerateを使う
    if i in one_char_indices:
        word_map[word[:1]] = i  # 1文字だけを取り出す
    else:
        word_map[word[:2]] = i  # 2文字を取り出す

# 結果を出力
print(word_map)
        </code></pre>
        <h3>05.n-gram</h3>
          <p><b>与えられたシーケンス（文字列やリストなど）からn-gramを作る関数を作成せよ．この関数を用い，”I am an NLPer”という文から単語bi-gram，文字bi-gramを得よ．</b></p>
        <pre><code>
# n-gramを作成する関数
def n_gram(sequence, n):
    return [sequence[i:i+n] for i in range(len(sequence) - n + 1)]

# 与えられた文章
sentence = &quot;I am an NLPer&quot;

# 単語bi-gram
words = sentence.split()  # 文を単語に分解
word_bi_gram = n_gram(words, 2)  # 単語でのbi-gramを生成

# 文字bi-gram
char_bi_gram = n_gram(sentence.replace(&quot; &quot;, &quot;&quot;), 2)  # 空白を除去して文字でのbi-gramを生成

# 結果を出力
print(&quot;単語bi-gram:&quot;, word_bi_gram)
print(&quot;文字bi-gram:&quot;, char_bi_gram)
        </code></pre>
          <h3>06.集合</h3>
          <p><b>“paraparaparadise”と”paragraph”に含まれる文字bi-gramの集合を，それぞれ, XとYとして求め，XとYの和集合，積集合，差集合を求めよ．さらに，’se’というbi-gramがXおよびYに含まれるかどうかを調べよ．</b></p>
        <pre><code>
# n-gramを作成する関数
def n_gram(sequence, n):
    return [sequence[i:i+n] for i in range(len(sequence) - n + 1)]

# 文字列からbi-gramを作成
str1 = &quot;paraparaparadise&quot;
str2 = &quot;paragraph&quot;

# それぞれの文字bi-gram集合を求める
X = set(n_gram(str1, 2))
Y = set(n_gram(str2, 2))

# 和集合、積集合、差集合を求める
union = X | Y
intersection = X &amp; Y
difference = X - Y

# &#039;se&#039;がXとYに含まれるかどうかを調べる
is_se_in_X = &#039;se&#039; in X
is_se_in_Y = &#039;se&#039; in Y

# 結果を出力
print(&quot;X:&quot;, X)
print(&quot;Y:&quot;, Y)
print(&quot;和集合:&quot;, union)
print(&quot;積集合:&quot;, intersection)
print(&quot;差集合:&quot;, difference)
print(&quot;&#039;se&#039;がXに含まれるか:&quot;, is_se_in_X)
print(&quot;&#039;se&#039;がYに含まれるか:&quot;, is_se_in_Y)
        </code></pre>
          <h3>07.テンプレートによる文生成</h3>
          <p><b>引数x, y, zを受け取り「x時のyはz」という文字列を返す関数を実装せよ．さらに，x=12, y=”気温”, z=22.4として，実行結果を確認せよ．</b></p>
        <pre><code>
# 関数の定義
def create_sentence(x, y, z):
    return f&quot;{x}時の{y}は{z}&quot;

# 関数の実行
x = 12
y = &quot;気温&quot;
z = 22.4
result = create_sentence(x, y, z)

# 結果を出力
print(result)
        </code></pre>
          <h3>08.暗号文</h3>
          <p><b>与えられた文字列の各文字を，以下の仕様で変換する関数cipherを実装せよ．
              <ul>
                  <li>英小文字ならば(219 - 文字コード)の文字に置換</li>
                  <li>その他の文字はそのまま出力</li>
              </ul>
              この関数を用い，英語のメッセージを暗号化・復号化せよ．</b></p>
        <pre><code>
# cipher関数の定義
def cipher(text):
    # 各文字を処理
    result = &#039;&#039;.join([chr(219 - ord(c)) if c.islower() else c for c in text])
    return result

# 暗号化するメッセージ
message = &quot;I am a NLPer.&quot;

# 暗号化
encrypted_message = cipher(message)
print(&quot;暗号化:&quot;, encrypted_message)

# 復号化 (同じ関数を使うことで復号も可能)
decrypted_message = cipher(encrypted_message)
print(&quot;復号化:&quot;, decrypted_message)
        </code></pre>
      </section>
    </main>
</body>
</html>
