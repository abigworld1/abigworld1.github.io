<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【深層強化学習 | PyTorch】走る作曲家のAIカフェ</title>
    <link rel="stylesheet" href="style.css"> 
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1050827580219099"
     crossorigin="anonymous"></script>
</head>
<body>
    <header>
        <h1>走る作曲家のAIカフェ</h1>
        <nav>
            <ul>
                <li><a href="index.html">ホーム</a></li>
                <li><a href="study.html">勉強</a></li>
                <li><a href="music.html">音楽</a></li>
                <li><a href="sports.html">スポーツ</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section>
            <h2>目次</h2>
            <ul>
                <li><a href="#overview">Overview</a></li>
                <li><a href="#source">Source</a></li>
                <li><a href="#review">Review</a></li>
                <li><a href="#dqn">DQN</a></li>
                <li><a href="#ddqn">DDQN</a></li>
            </ul>
        </section>
        <section id="overview">
            <h2>Overview</h2>
            深層強化学習とは、強化学習と深層学習を組み合わせた手法です。ニューラルネットワークを使用して、エージェントが環境から得られる観測値をもとに価値関数や方策を近似します。<br>
            このページでは、深層強化学習についてPyTorchによる実装の方法をメインに学んでいきます。
        </section>
        <section id="source">
            <h2>Source</h2>
            以下の書籍を参考にしました。
            <ul>
                <li><a href="https://www.amazon.co.jp/%E3%81%A4%E3%81%8F%E3%82%8A%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6-%E6%B7%B1%E5%B1%A4%E5%BC%B7%E5%8C%96%E5%AD%A6%E7%BF%92-PyTorch%E3%81%AB%E3%82%88%E3%82%8B%E5%AE%9F%E8%B7%B5%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-%E6%A0%AA%E5%BC%8F%E4%BC%9A%E7%A4%BE%E9%9B%BB%E9%80%9A%E5%9B%BD%E9%9A%9B%E6%83%85%E5%A0%B1%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9-%E5%B0%8F%E5%B7%9D%E9%9B%84%E5%A4%AA%E9%83%8E/dp/4839965625">つくりながら学ぶ! 深層強化学習 ~PyTorchによる実践プログラミング~</a></li>
                <ul>
                    <li>Copyright (c) 2018 Yutaro Ogawa</li>
                    <li><a href="https://github.com/YutaroOgawa/Deep-Reinforcement-Learning-Book/blob/master/LICENSE">LICENSE</a></li>
                </ul>
            </ul>
        </section>
        <section id="review">
            <h2>Review</h2>
            <h3>PyTorchによるディープラーニングの実装</h3>
            <ol>
                <li>データの前処理</li>
                <li>DataLoaderの作成</li>
                <li>ネットワークの構築</li>
                <li>誤差関数と最適化手法の設定</li>
                <li>学習と推論の実行</li>
            </ol>
            <p>MNISTを使って復習してみる。</p>
            <pre><code>
from sklearn.datasets import fetch_openml
import numpy as np
import matplotlib.pyplot as plt

# MNISTデータを取得
mnist = fetch_openml(&#039;mnist_784&#039;, version=1, data_home=&quot;.&quot;)
            </code></pre>
            <b>1. データの前処理</b>
            <pre><code>
# データをNumPy配列に変換
X = np.array(mnist.data) / 255  # 正規化
y = np.array(mnist.target).astype(np.int32)  # ラベルをint32型に変換

# 1つ目の画像を表示
plt.imshow(X[0].reshape(28, 28), cmap=&#039;gray&#039;)
plt.title(f&quot;The label of this image is {y[0]}.&quot;)
plt.show()
            </code></pre>
            <b>2. データローダーの作成</b>
            <p>DataLoaderへの変換は以下の4つの手続きからなる。</p>
            <ol>
                <li>訓練データとテストデータに分割</li>
                <li>NumPyデータをTensorに変換</li>
                <li>Datasetの作成</li>
                <li>DatasetをDataLoaderに変換</li>
            </ol>
            <pre><code>
# 2. DataLoderの作成

import torch
from torch.utils.data import TensorDataset, DataLoader
from sklearn.model_selection import train_test_split

# 2.1 データを訓練とテストに分割（6:1）
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=1/7, random_state=0)

# 2.2 データをPyTorchのTensorに変換
X_train = torch.Tensor(X_train)
X_test = torch.Tensor(X_test)
y_train = torch.LongTensor(y_train)
y_test = torch.LongTensor(y_test)

# 2.3 データとラベルをセットにしたDatasetを作成
ds_train = TensorDataset(X_train, y_train)
ds_test = TensorDataset(X_test, y_test)

# 2.4 データセットのミニバッチサイズを指定した、Dataloaderを作成
# Chainerのiterators.SerialIteratorと似ている
loader_train = DataLoader(ds_train, batch_size=64, shuffle=True)
loader_test = DataLoader(ds_test, batch_size=64, shuffle=False)
            </code></pre>
            <p>ラベルのような整数データの場合は<code2>torch.LongTensor</code2>を使う。</p>
            <b>3. ネットワークの構築</b>
            <pre><code>
# 3. ネットワークの構築
# Keras風の書き方 

from torch import nn

model = nn.Sequential()
model.add_module(&#039;fc1&#039;, nn.Linear(28*28*1, 100))
model.add_module(&#039;relu1&#039;, nn.ReLU())
model.add_module(&#039;fc2&#039;, nn.Linear(100, 100))
model.add_module(&#039;relu2&#039;, nn.ReLU())
model.add_module(&#039;fc3&#039;, nn.Linear(100, 10))

print(model)
            </code></pre>
            <b>4. 誤差関数と最適化手法の設定</b>
            <p>誤差関数にはクロスエントロピー誤差関数を、最適化手法にはAdamを設定する</p>
            <pre><code>
# 4. 誤差関数と最適化手法の設定

from torch import optim

# 誤差関数の設定
loss_fn = nn.CrossEntropyLoss()  # 変数名にはcriterionが使われることも多い

# 重みを学習する際の最適化手法の選択
optimizer = optim.Adam(model.parameters(), lr=0.01)
            </code></pre>
            <b>5. 学習と推論の設定</b>
            <pre><code>
# 5. 学習と推論の設定
# 5-1. 学習1回でやることを定義します
# Chainerのtraining.Trainer()に対応するものはない


def train(epoch):
    model.train()  # ネットワークを学習モードに切り替える

    # データローダーから1ミニバッチずつ取り出して計算する
    for data, targets in loader_train:
      
        optimizer.zero_grad()  # 一度計算された勾配結果を0にリセット
        outputs = model(data)  # 入力dataをinputし、出力を求める
        loss = loss_fn(outputs, targets)  # 出力と訓練データの正解との誤差を求める
        loss.backward()  # 誤差のバックプロパゲーションを求める
        optimizer.step()  # バックプロパゲーションの値で重みを更新する

    print(&quot;epoch{}：終了\n&quot;.format(epoch))
            </code></pre>
            <pre><code>
# 5. 学習と推論の設定
# 5-2. 推論1回でやることを定義します
# Chainerのtrainer.extend(extensions.Evaluator())に対応するものはない


def test():
    model.eval()  # ネットワークを推論モードに切り替える
    correct = 0

    # データローダーから1ミニバッチずつ取り出して計算する
    with torch.no_grad():  # 微分は推論では必要ない
        for data, targets in loader_test:

            outputs = model(data)  # 入力dataをinputし、出力を求める

            # 推論する
            _, predicted = torch.max(outputs.data, 1)  # 確率が最大のラベルを求める
            correct += predicted.eq(targets.data.view_as(predicted)).sum()  # 正解と一緒だったらカウントアップ

    # 正解率を出力
    data_num = len(loader_test.dataset)  # データの総数
    print(&#039;\nテストデータの正解率: {}/{} ({:.0f}%)\n&#039;.format(correct,
                                                   data_num, 100. * correct / data_num))
            </code></pre>
            <b>6. 学習と推論の実行</b>
            <pre><code>
# 6. 学習と推論の実行
for epoch in range(3):
    train(epoch)

test()
            </code></pre>
        </section>
        <section id="dqn">
            <h2>DQN</h2>
            <p>ニューラルネットワークへの入力は、各状態変数の値となる。よって、ニューラルネットワークの入力層の祖指数は、状態変数の値と同じになる。</p>
            <p>出力層の素子数は、行動の種類数となる。出力する値は、行動価値関数\(Q(s_t, a_t)\)の値である。</p>
            <p>誤差関数は以下の通り。</p>
            <div class="scroll">
                \begin{align}
                E(s_t, a_t) = (R_{t+1} + \gamma \max_a Q(s_{t+1}, a) - Q(s_t, a_t))^2
                \end{align}
            </div>
            <p>状態\(s_{t+1}\)は、実際に\(s_t\)から行動\(a_t\)を実施して求める。</p>
            <p>\(\max_a Q(s_{t+1}, a)\)の値はニューラルネットワークに状態\(s_{t+1}\)を入力して求める。</p>
            <h3>Experience Replay</h3>
            <p>DQNでは、表形式表現のQ学習のように1ステップごとにそのステップの内容（experience）を学習するのではなく、メモリに各ステップの内容を保存しておき、メモリから内容をランダムに取り出して（replay）、ニューラルネットワークに学習させる。
            1ステップごとの内容をtransitionという。</p>
            <p>各ステップごとにそのステップの内容を学習すると、時間的に相関が高い内容（時刻\(t\)と時刻\(t+1\)の学習内容はよく似ている）を連続してニューラルネットワークが学習するため、結合パラメータの学習が安定しづらいという問題が発生する。
            Experience Replayはこの問題を解決する工夫となる。また、Experience Replayであればメモリから複数ステップの経験を使用することができるので、ミニバッチ学習でニューラルネットワークを学習させることができる。</p>
            <h3>Fixed Target Q-Network</h3>
            <p>ニューラルネットワークとして、行動を決定するmain-networkと誤差関数の計算時に行動価値を求めるtarget-networkの2種類を用意する。</p>
            <P>DQNでは価値関数\(Q(s_t, a)\)を更新していきたいが、Q学習のアルゴリズムで行動価値関数を更新するには、次の時刻の状態\(s_{t+1}\)での価値関数\(Q(s_{t+1}, a)\)が必要である。
            つまり、Q関数の更新のために、同じQ関数を使用する必要がある。これら2つを同じQ関数にしていると、Q関数の更新学習が不安定になりやすくなるという問題が発生する。
            そこで、更新に必要な\(\max_a Q(s_{t+1}, a)\)を求めるときには、少し前の時間の別のQ関数（Fixed Target Q-Network）を使って計算する。</P>
            <p>少し前の時間の別のQ関数とは、ニューラルネットワークの結合パラメータの学習が最新版より古いという意味である。ここでの少し前という表現は、強化学習の課題対象が持つ時間ではなく、ニューラルネットワークの結合パラメータ更新のタイミングを意味している。
            そのため、target-networkは定期的にmain-networkで上書きすることになる。</p>
            <h3>報酬のclipping</h3>
            <p>各ステップで得られる報酬を-1, 0, 1のいずれかに固定しておく。こうすることで課題内容（学習対象）によらず、同じハイパーパラメータでDQNを実行できるというメリットがある。</p>
            <h3>Huber関数</h3>
            <p>誤差を二乗誤差関数ではなく、Huber関数を使用して計算する。誤差が大きい場合に二乗誤差を使用すると、誤差関数の出力が大きくなりすぎて学習が安定しづらいという問題が発生する。</p>
            <h3>実装</h3>
            <p>CartPoleを例に、実装してみる。</p>
            <pre><code>
# パッケージのimport
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
import gym
            </code></pre>
            <pre><code>
from matplotlib import animation
from IPython.display import display, Video
import matplotlib.pyplot as plt

def display_frames_as_gif(frames):
    &quot;&quot;&quot;
    Displays a list of frames as a video (mp4), with controls.
    &quot;&quot;&quot;
    # Figureの設定
    fig = plt.figure(figsize=(frames[0].shape[1]/72.0, frames[0].shape[0]/72.0),
                     dpi=72)
    patch = plt.imshow(frames[0])
    plt.axis(&#039;off&#039;)

    # 各フレームを更新する関数
    def animate(i):
        patch.set_data(frames[i])

    # アニメーションの設定
    anim = animation.FuncAnimation(fig, animate, frames=len(frames), interval=50)

    # mp4ファイルとして保存
    anim.save(&#039;movie_cartpole_DQN.mp4&#039;, writer=&#039;ffmpeg&#039;)

    # IPython上で動画を表示
    display(Video(&quot;movie_cartpole_DQN.mp4&quot;, embed=True))
            </code></pre>
            <p>ここで、<code2>namedtuple</code2>の使用例を示す。</p>
            <pre><code>
# 本コードでは、namedtupleを使用します。
# namedtupleを使うことで、値をフィールド名とペアで格納できます。
# すると値に対して、フィールド名でアクセスできて便利です。
# https://docs.python.jp/3/library/collections.html#collections.namedtuple
# 以下は使用例です

from collections import namedtuple

Tr = namedtuple(&#039;tr&#039;, (&#039;name_a&#039;, &#039;value_b&#039;))
Tr_object = Tr(&#039;名前Aです&#039;, 100)

print(Tr_object)  # 出力：tr(name_a=&#039;名前Aです&#039;, value_b=100)
print(Tr_object.value_b)  # 出力：100
            </code></pre>
            <p>DQNの実装時にも状態や行動の値にアクセスしやすくするために、各ステップでのtransition(経験)をnamedtupleを使用して変換する。実際に使用するnamedtupleは以下の通り。</p>
            <pre><code>
# namedtupleを生成
from collections import namedtuple

Transition = namedtuple(
    &#039;Transition&#039;, (&#039;state&#039;, &#039;action&#039;, &#039;next_state&#039;, &#039;reward&#039;))
            </code></pre>
            <p>今回使用する定数を宣言する。</p>
            <pre><code>
# 定数の設定
ENV = 'CartPole-v0'  # 使用する課題名
GAMMA = 0.99  # 時間割引率
MAX_STEPS = 200  # 1試行のstep数
NUM_EPISODES = 500  # 最大試行回数
            </code></pre>
            <p>ミニバッチ学習を実現するために、経験データを保存しておくメモリクラスReplayMemoryを定義する。
            ReplayMemoryはそのstepでのtransition（経験）を保存する関数pushと、ランダムにtransitionを取り出す関数sampleを用意する。
            また、関数lenに対して、現在格納しているtransitionの数を返すように定義する。
            メモリクラスは保存しているtransitionの数が定数CAPACITY以上になった場合には、インデックスを前に戻して古い内容がから上書きしていく。</p>
            <pre><code>
# 経験を保存するメモリクラスを定義します


class ReplayMemory:

    def __init__(self, CAPACITY):
        self.capacity = CAPACITY  # メモリの最大長さ
        self.memory = []  # 経験を保存する変数
        self.index = 0  # 保存するindexを示す変数

    def push(self, state, action, state_next, reward):
        &#039;&#039;&#039;transition = (state, action, state_next, reward)をメモリに保存する&#039;&#039;&#039;

        if len(self.memory) &lt; self.capacity:
            self.memory.append(None)  # メモリが満タンでないときは足す

        # namedtupleのTransitionを使用し、値とフィールド名をペアにして保存します
        self.memory[self.index] = Transition(state, action, state_next, reward)

        self.index = (self.index + 1) % self.capacity  # 保存するindexを1つずらす

    def sample(self, batch_size):
        &#039;&#039;&#039;batch_size分だけ、ランダムに保存内容を取り出す&#039;&#039;&#039;
        return random.sample(self.memory, batch_size)

    def __len__(self):
        &#039;&#039;&#039;関数lenに対して、現在の変数memoryの長さを返す&#039;&#039;&#039;
        return len(self.memory)
            </code></pre>
            <p>次に、Brainクラスを実装する。ここがDQNの中心部である。メソッドは関数replayと関数decide_actionである。
            関数replayはメモリクラスからミニバッチを取り出して、ニューラルネットワークの結合パラメータを学習し、Q関数を更新する。
            関数decide_actionはε-greedy法に従い、ランダムな行動もしくは現在の状態に対してQ値が最大となる行動のindexを返す。</p>
            <pre><code>
# エージェントが持つ脳となるクラスです、DQNを実行します
# Q関数をディープラーニングのネットワークをクラスとして定義

import random
import torch
from torch import nn
from torch import optim
import torch.nn.functional as F

BATCH_SIZE = 32
CAPACITY = 10000


class Brain:
    def __init__(self, num_states, num_actions):
        self.num_actions = num_actions  # CartPoleの行動（右に左に押す）の2を取得

        # 経験を記憶するメモリオブジェクトを生成
        self.memory = ReplayMemory(CAPACITY)

        # ニューラルネットワークを構築
        self.model = nn.Sequential()
        self.model.add_module(&#039;fc1&#039;, nn.Linear(num_states, 32))
        self.model.add_module(&#039;relu1&#039;, nn.ReLU())
        self.model.add_module(&#039;fc2&#039;, nn.Linear(32, 32))
        self.model.add_module(&#039;relu2&#039;, nn.ReLU())
        self.model.add_module(&#039;fc3&#039;, nn.Linear(32, num_actions))

        print(self.model)  # ネットワークの形を出力

        # 最適化手法の設定
        self.optimizer = optim.Adam(self.model.parameters(), lr=0.0001)

    def replay(self):
        &#039;&#039;&#039;Experience Replayでネットワークの結合パラメータを学習&#039;&#039;&#039;

        # -----------------------------------------
        # 1. メモリサイズの確認
        # -----------------------------------------
        # 1.1 メモリサイズがミニバッチより小さい間は何もしない
        if len(self.memory) &lt; BATCH_SIZE:
            return

        # -----------------------------------------
        # 2. ミニバッチの作成
        # -----------------------------------------
        # 2.1 メモリからミニバッチ分のデータを取り出す
        transitions = self.memory.sample(BATCH_SIZE)

        # 2.2 各変数をミニバッチに対応する形に変形
        # transitionsは1stepごとの(state, action, state_next, reward)が、BATCH_SIZE分格納されている
        # つまり、(state, action, state_next, reward)×BATCH_SIZE
        # これをミニバッチにしたい。つまり
        # (state×BATCH_SIZE, action×BATCH_SIZE, state_next×BATCH_SIZE, reward×BATCH_SIZE)にする
        batch = Transition(*zip(*transitions))

        # 2.3 各変数の要素をミニバッチに対応する形に変形し、ネットワークで扱えるようVariableにする
        # 例えばstateの場合、[torch.FloatTensor of size 1x4]がBATCH_SIZE分並んでいるのですが、
        # それを torch.FloatTensor of size BATCH_SIZEx4 に変換します
        # 状態、行動、報酬、non_finalの状態のミニバッチのVariableを作成
        # catはConcatenates（結合）のことです。
        state_batch = torch.cat(batch.state)
        action_batch = torch.cat(batch.action)
        reward_batch = torch.cat(batch.reward)
        non_final_next_states = torch.cat([s for s in batch.next_state
                                           if s is not None])

        # -----------------------------------------
        # 3. 教師信号となるQ(s_t, a_t)値を求める
        # -----------------------------------------
        # 3.1 ネットワークを推論モードに切り替える
        self.model.eval()

        # 3.2 ネットワークが出力したQ(s_t, a_t)を求める
        # self.model(state_batch)は、右左の両方のQ値を出力しており
        # [torch.FloatTensor of size BATCH_SIZEx2]になっている。
        # ここから実行したアクションa_tに対応するQ値を求めるため、action_batchで行った行動a_tが右か左かのindexを求め
        # それに対応するQ値をgatherでひっぱり出す。
        state_action_values = self.model(state_batch).gather(1, action_batch)

        # 3.3 max{Q(s_t+1, a)}値を求める。ただし次の状態があるかに注意。

        # cartpoleがdoneになっておらず、next_stateがあるかをチェックするインデックスマスクを作成
        non_final_mask = torch.ByteTensor(tuple(map(lambda s: s is not None,
                                                    batch.next_state)))
        # まずは全部0にしておく
        next_state_values = torch.zeros(BATCH_SIZE)

        # 次の状態があるindexの最大Q値を求める
        # 出力にアクセスし、max(1)で列方向の最大値の[値、index]を求めます
        # そしてそのQ値（index=0）を出力します
        # detachでその値を取り出します
        next_state_values[non_final_mask] = self.model(
            non_final_next_states).max(1)[0].detach()

        # 3.4 教師となるQ(s_t, a_t)値を、Q学習の式から求める
        expected_state_action_values = reward_batch + GAMMA * next_state_values

        # -----------------------------------------
        # 4. 結合パラメータの更新
        # -----------------------------------------
        # 4.1 ネットワークを訓練モードに切り替える
        self.model.train()

        # 4.2 損失関数を計算する（smooth_l1_lossはHuberloss）
        # expected_state_action_valuesは
        # sizeが[minbatch]になっているので、unsqueezeで[minibatch x 1]へ
        loss = F.smooth_l1_loss(state_action_values,
                                expected_state_action_values.unsqueeze(1))

        # 4.3 結合パラメータを更新する
        self.optimizer.zero_grad()  # 勾配をリセット
        loss.backward()  # バックプロパゲーションを計算
        self.optimizer.step()  # 結合パラメータを更新

    def decide_action(self, state, episode):
        &#039;&#039;&#039;現在の状態に応じて、行動を決定する&#039;&#039;&#039;
        # ε-greedy法で徐々に最適行動のみを採用する
        epsilon = 0.5 * (1 / (episode + 1))

        if epsilon &lt;= np.random.uniform(0, 1):
            self.model.eval()  # ネットワークを推論モードに切り替える
            with torch.no_grad():
                action = self.model(state).max(1)[1].view(1, 1)
            # ネットワークの出力の最大値のindexを取り出します = max(1)[1]
            # .view(1,1)は[torch.LongTensor of size 1]　を size 1x1 に変換します

        else:
            # 0,1の行動をランダムに返す
            action = torch.LongTensor(
                [[random.randrange(self.num_actions)]])  # 0,1の行動をランダムに返す
            # actionは[torch.LongTensor of size 1x1]の形になります

        return action
            </code></pre>
            <p>関数replayでは4つのことを行っている。</p>
            <ol>
                <li>メモリサイズの確認</li>
                <ul>
                    <li>メモリサイズがミニバッチより小さい間は何もしない</li>
                </ul>
                <li>ミニバッチの作成</li>
                <ul>
                    <li>メモリからミニバッチ分のデータを取り出す</li>
                    <li>各変数をミニバッチに対応する形に変形</li>
                    <li>各変数の要素をミニバッチに対応する形に変形</li>
                    <ul>
                        <li>ミニバッチの作成はステップから成る。まずランダムにミニバッチ数分だけtransitionを取り出した変数transitionsを作成する。
                        transitionが1stepごとのデータを固めて格納しているため、transitionsのままではPyTorchのミニバッチとして扱えない。
                        そこで2段階の変形を行う。はじめに各変数（状態や行動など）をミニバッチに対応する形に変形する。
                        具体的には、<code2>(state, action, state_next, reward)×BATCH_SIZE</code2>となっている形を、<code2>(state×BATCH_SIZE, action×BATCH_SIZE, state_next×BATCH_SIZE, reward×BATCH_SIZE)</code2>にする。
                        次に各変数（状態や行動など）の要素（位置や速度など）をミニバッチで扱える形に変形する。
                        例えばstateの場合、torch.FloatTensor of size 1x4がBATCH_SIZE分並んでいるが、それをtorch.FloatTensor of size BATCH_SIZEx4になるように変換する。
                        なお次の状態があるのか終了状態なのかでQ学習の更新式が変わる。
                        そこで変数<code2>non_final_next_states</code2>という、次の状態が存在する状態だけを集めたミニバッチも別途用意する。</li>
                    </ul>
                </ul>
                <li>教師信号となる\(Q(s_t, a_t)\)値を求める</li>
                <ul>
                    <li>ネットワークを推論モードに切り替える</li>
                    <li>ネットワークが出力した\(Q(s_t, a_t)\)を求める</li>
                    <li>\(\max_a Q(s_{t+1}, a)\)の値を求める（次の状態がある場合のみ）</li>
                    <li>教師となる\(Q(s_t, a_t)\)の値をQ学習の式から求める</li>
                    <ul>
                        <li>状態のミニバッチ変数state_batchをネットワークに入力し、その出力から実際に行った行動のミニバッチ変数action_batchに対応するものを関数gatherを使って取り出す。
                        ここでは、Fixed Target Q-Networkをミニバッチ学習で代替している。
                        教師信号の計算で使用しているdetach()とはネットワークの出力の値を取り出すという意味である。PyTorchではdetach()することでその変数が保持しているそれまでの計算履歴を失い、バックプロパゲーションする際に微分を計算しなくなる。
                        結合パラメータの学習において、教師信号は固定されたものにしておく必要がある。そこでdetach()を行い、教師信号に微分操作が行われないようにする。
                        一方で実際にネットワークのが予測として出力した\(Q(s_t, a_t)\)は微分できるようにdetach()は行わない。
                        そしてこの\(Q(s_t, a_t)\)が教師信号に近づくように微分を求め、ネットワークの結合パラメータを更新する。</li>
                    </ul>
                </ul>
                <li>結合パラメータの更新</li>
                <ul>
                    <li>ネットワークを訓練モードに切り替える</li>
                    <li>損失関数の値を計算する</li>
                    <li>結合パラメータを更新する</li>
                </ul>
            </ol>
            <p>Agentクラスを定義する。関数memorizeでは、メモリオブジェクトに経験したデータ（transition）を格納する。</p>
            <pre><code>
# CartPoleで動くエージェントクラスです、棒付き台車そのものになります


class Agent:
    def __init__(self, num_states, num_actions):
        '''課題の状態と行動の数を設定する'''
        self.brain = Brain(num_states, num_actions)  # エージェントが行動を決定するための頭脳を生成

    def update_q_function(self):
        '''Q関数を更新する'''
        self.brain.replay()

    def get_action(self, state, episode):
        '''行動を決定する'''
        action = self.brain.decide_action(state, episode)
        return action

    def memorize(self, state, action, state_next, reward):
        '''memoryオブジェクトに、state, action, state_next, rewardの内容を保存する'''
        self.brain.memory.push(state, action, state_next, reward)
            </code></pre>
            <p>続いて、環境クラスを定義する。表形式表現のように離散化は行わない。また、直近10episodeの立ち続けたstep数を格納するリストを用意し、その平均値を見ることで学習の進捗を分かりやすくする。</p>
            <pre><code>
# CartPoleを実行する環境のクラスです


class Environment:

    def __init__(self):
        self.env = gym.make(ENV)  # 実行する課題を設定
        num_states = self.env.observation_space.shape[0]  # 課題の状態数4を取得
        num_actions = self.env.action_space.n  # CartPoleの行動（右に左に押す）の2を取得
        self.agent = Agent(num_states, num_actions)  # 環境内で行動するAgentを生成

        
    def run(self):
        &#039;&#039;&#039;実行&#039;&#039;&#039;
        episode_10_list = np.zeros(10)  # 10試行分の立ち続けたstep数を格納し、平均ステップ数を出力に利用
        complete_episodes = 0  # 195step以上連続で立ち続けた試行数
        episode_final = False  # 最後の試行フラグ
        frames = []  # 最後の試行を動画にするために画像を格納する変数

        for episode in range(NUM_EPISODES):  # 最大試行数分繰り返す
            observation = self.env.reset()  # 環境の初期化

            state = observation  # 観測をそのまま状態sとして使用
            state = torch.from_numpy(state).type(
                torch.FloatTensor)  # NumPy変数をPyTorchのテンソルに変換
            state = torch.unsqueeze(state, 0)  # size 4をsize 1x4に変換

            for step in range(MAX_STEPS):  # 1エピソードのループ

                if episode_final is True:  # 最終試行ではframesに各時刻の画像を追加していく
                    frames.append(self.env.render(mode=&#039;rgb_array&#039;))

                action = self.agent.get_action(state, episode)  # 行動を求める

                # 行動a_tの実行により、s_{t+1}とdoneフラグを求める
                # actionから.item()を指定して、中身を取り出す
                observation_next, _, done, _ = self.env.step(
                    action.item())  # rewardとinfoは使わないので_にする

                # 報酬を与える。さらにepisodeの終了評価と、state_nextを設定する
                if done:  # ステップ数が200経過するか、一定角度以上傾くとdoneはtrueになる
                    state_next = None  # 次の状態はないので、Noneを格納

                    # 直近10episodeの立てたstep数リストに追加
                    episode_10_list = np.hstack(
                        (episode_10_list[1:], step + 1))

                    if step &lt; 195:
                        reward = torch.FloatTensor(
                            [-1.0])  # 途中でこけたら罰則として報酬-1を与える
                        complete_episodes = 0  # 連続成功記録をリセット
                    else:
                        reward = torch.FloatTensor([1.0])  # 立ったまま終了時は報酬1を与える
                        complete_episodes = complete_episodes + 1  # 連続記録を更新
                else:
                    reward = torch.FloatTensor([0.0])  # 普段は報酬0
                    state_next = observation_next  # 観測をそのまま状態とする
                    state_next = torch.from_numpy(state_next).type(
                        torch.FloatTensor)  # numpy変数をPyTorchのテンソルに変換
                    state_next = torch.unsqueeze(state_next, 0)  # size 4をsize 1x4に変換

                # メモリに経験を追加
                self.agent.memorize(state, action, state_next, reward)

                # Experience ReplayでQ関数を更新する
                self.agent.update_q_function()

                # 観測の更新
                state = state_next

                # 終了時の処理
                if done:
                    print(&#039;%d Episode: Finished after %d steps：10試行の平均step数 = %.1lf&#039; % (
                        episode, step + 1, episode_10_list.mean()))
                    break

            if episode_final is True:
                # 動画を保存と描画
                display_frames_as_gif(frames)
                break

            # 10連続で200step経ち続けたら成功
            if complete_episodes &gt;= 10:
                print(&#039;10回連続成功&#039;)
                episode_final = True  # 次の試行を描画を行う最終試行とする
            </code></pre>
            <p>最後に実行する。</p>
            <pre><code>
# main クラス
cartpole_env = Environment()
cartpole_env.run()
            </code></pre>
        </section>
        <section id="ddqn">
            <h2>DDQN</h2>
            <p>DQNには、2013年バージョンｇと2015年Natureバージョンの2通りがある。</p>
        </section>
    </main>
</body>
</html>
