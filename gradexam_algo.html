<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【北海道大学|情報科学院|院試対策|アルゴリズムとデータ構造】走る作曲家のAIカフェ</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <header>
        <h1>走る作曲家のAIカフェ</h1>
        <nav>
            <ul>
                <li><a href="index.html">ホーム</a></li>
                <li><a href="study.html">勉強</a></li>
                <li><a href="music.html">音楽</a></li>
                <li><a href="sports.html">スポーツ</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section>
          <p>「北海道大学大学院情報科学院修士課程入学試験」（令和6年8月実施）の「<b>アルゴリズムとデータ構造</b>」対策ページです。</p>
        </section>
        <section>
          <h2>分野別対策</h2>
          <ul>
            <li><a href="gradexam.html">院試対策 ～はじめに～</a></li>
            <li><a href="gradexam_basicmath.html">院試対策 ～基礎数学編～</a></li>
            <li><a href="gradexam_infomath.html">院試対策 ～情報数学編～</a></li>
            <li><a href="gradexam_statistics.html">院試対策 ～確率・統計編～</a></li>
            <li><a href="gradexam_infotheory.html">院試対策 ～情報理論編～</a></li>
            <li><a href="gradexam_algo.html">院試対策 ～アルゴリズムとデータ構造編～</a></li>
            <li><a href="gradexam_ai.html">院試対策 ～人工知能編～</a></li>
            <li><a href="gradexam_cs.html">院試対策 ～コンピュータシステム編～</a></li>
          </ul>
        </section>
        <section id="algorithms-data-structures">
          <h2>アルゴリズムとデータ構造</h2>
            <h3>計算量、オーダー表記</h3>
            <p>参考にしたサイトは以下のとおり。</p>
            <p><a href="https://www.momoyama-usagi.com/entry/calc-order">プログラムの計算量、オーダー表記 O( ) の求め方のまとめ _ 工業大学生ももやまのうさぎ塾.html</a></p>
            <ul>
                <li>項の強さを弱い順に左から並べると、以下のとおりである。</li>
                <ul>
                    <li>\(logn, \sqrt{n}, n, nlogn, n^2, n^3, 2^n, n!\)</li>
                </ul>
            </ul>
            <h3>最小全域木</h3>
            <p>参考にしたサイトは以下のとおり。</p>
            <p><a href="https://www.momoyama-usagi.com/entry/math-risan13">うさぎでもわかる離散数学（グラフ理論）　第13羽　最小全域木の求め方（クラスカル法・プリム法） _ 工業大学生ももやまのうさぎ塾.html</a></p>
            <ul>
                <li><b>全域木</b>とは、もとのグラフのすべての点を含み、さらに選んだ辺が木となっているようなグラフである。</li>
                <li><b>最小全域木</b>とは、選んだ辺の重みの合計が一番小さい全域木のことである。</li>
                <li>最小全域木を求めるアルゴリズム①「<b>クラスカル法</b>」は以下のとおりである。</li>
                <ol>
                    <li>重みが小さい順に辺をチェックする。</li>
                    <li>チェックした辺を追加しても閉路ができなければ辺を追加する。追加して閉路ができてしまう場合は無視する。</li>
                    <li>すべての辺をチェックし終わったときに追加された辺が最小全域木である。</li>
                </ol>
                <li>最小全域木を求めるアルゴリズム②「<b>プリム法</b>」は以下のとおりである。</li>
                <ol>
                    <li>スタートの点を１つ決める（どこでも良い）。</li>
                    <li>スタート点から辿れる辺の中で最も重みが小さい辺を追加する（最も重みが小さい辺が複数ある場合は、重みが小さいどの辺を選んでも良い）。</li>
                    <li>追加した辺につながっているすべての点から辿れる辺かつ追加しても閉路とならない辺の中から最も重みが小さい辺を追加する。</li>
                    <li>追加できる辺がなくなったとき、最小全域木である。</li>
                </ol>
            </ul>
            <h3>ダイクストラ法</h3>
            <p>参考にしたサイトは以下のとおり。</p>
            <p><a href="https://algo-logic.info/dijkstra/">ダイクストラ法による単一始点最短経路を求めるアルゴリズム _ アルゴリズムロジック.html</a></p>
            <ul>
                <li>ダイクストラ法は、ネットワークにおいて、すべての頂点\(v\)に対して、指定された頂点\(s\)から頂点\(v\)への最短路長\(D(v)\)を求めるアルゴリズムである。</li>
                <li>アルゴリズムは以下のとおりである。</li>
                <ol>
                    <li>始点\(s\)を「既に最短距離が確定した頂点」、他の頂点を「まだ最短距離が確定していない頂点」とする。</li>
                    <li>以下をすべての頂点の最短距離が確定するまで繰り返す。</li>
                    <ol>
                        <li>すべての「既に最短距離が確定した頂点\(u\)」から「まだ最短距離が確定していない頂点\(v\)」へ伸びるすべての辺\(e=(u, v)\)について、「\(v\)と\(D(v)\)の候補」をまとめておく。</li>
                        <li>候補の中から、\(D(v)\)が最小のものを選択し、\(v\)を「既に最短距離が確定した頂点」に加える。</li>
                    </ol>
                </ol>
            </ul>
            <h3>幅優先探索(BFS)、深さ優先探索(DFS)</h3>
            <p>参考にしたサイトは以下のとおり。</p>
            <p><a href="https://www.momoyama-usagi.com/entry/info-algo-tree-traverse">うさぎでもわかる2分探索木　後編　2分探索木における4つの走査方法 _ 工業大学生ももやまのうさぎ塾.html</a></p>
            <p><a href="https://manabitimes.jp/math/1247">深さ優先探索と幅優先探索 _ 高校数学の美しい物語.html</a></p>
            <p><b>幅優先探索 (BFS)</b></p>
            <ul>
                <li>概略
                <p>幅優先探索 (BFS) は、グラフや木の探索アルゴリズムであり、探索の開始点から近い順にすべての頂点やノードを探索する方法である。具体的には、最初にルートノードや開始ノードをキューに入れ、その後、キューから順にノードを取り出して、隣接するすべての未探索のノードをキューに追加していく。この過程をキューが空になるまで繰り返す。</p>
                </li>
                <li>特徴
                <ul>
                    <li><strong>最短経路:</strong> BFSは、探索を開始するノードから他のすべてのノードへの最短経路を見つけることができる。特に無加重のグラフにおいて、最短経路の問題に適している。</li>
                    <li><strong>使用するデータ構造:</strong> キュー（FIFO）を使用して、探索するノードを管理する。</li>
                    <li><strong>メモリ効率:</strong> BFSは探索のすべてのレベルのノードをキューに保持するため、メモリ使用量が大きくなることがある。特に、広いグラフや木では、キューのサイズが非常に大きくなる可能性がある。</li>
                    <li><strong>用途:</strong> 幅優先探索は、迷路問題、ネットワークルーティング、ウェブクローリングなど、探索の深さよりも幅を優先する問題でよく使われる。</li>
                </ul>
                </li>
            </ul>
    
            <p><b>深さ優先探索 (DFS)</b></p>
            <ul>
                <li>概略
                <p>深さ優先探索 (DFS) は、グラフや木の探索アルゴリズムであり、探索の開始点からできるだけ深く進み、行き止まりに達したらバックトラックして他の未探索のノードを探索する方法である。具体的には、ルートノードや開始ノードをスタックに入れ、スタックからノードを取り出して、その隣接ノードをスタックに追加していく。スタックが空になるまでこの過程を繰り返す。</p>
                </li>
                <li>特徴
                <ul>
                    <li><strong>メモリ効率:</strong> DFSは、探索中のノードとその子ノードのみをスタックに保持するため、BFSに比べてメモリ使用量が少なく済む。特に、深いグラフや木ではメモリ効率が良い。</li>
                    <li><strong>使用するデータ構造:</strong> スタック（LIFO）を使用して、探索するノードを管理する。再帰を用いて実装されることも多い。</li>
                    <li><strong>全体探索:</strong> DFSは、すべてのノードを探索する必要がある問題に適しており、木やグラフのすべてのノードを訪問することが保証される。</li>
                    <li><strong>用途:</strong> 深さ優先探索は、パズルの解決、コンポーネントの検出、トップソート、バックトラッキングアルゴリズムなど、探索の幅よりも深さを優先する問題でよく使われる。</li>
                </ul>
                </li>
            </ul>
    
            <p><b>幅優先探索と深さ優先探索の比較</b></p>
            <ul>
                <li><strong>経路の探索:</strong> BFSは最短経路を見つけるのに優れているが、DFSは一つの経路を見つけるのに優れている。</li>
                <li><strong>メモリ使用量:</strong> BFSはメモリ使用量が多くなりがちであるが、DFSは比較的少なく済む。</li>
                <li><strong>時間効率:</strong> 両者の時間計算量は、最悪の場合は同じであるが、問題の特性によってどちらが効率的かが異なる。</li>
                <li><strong>用途の違い:</strong> BFSは最短経路探索やレベルごとの探索に適し、DFSは完全探索やバックトラッキングに適している。</li>
            </ul>

            <h3>二分探索木</h3>
            <ul>
                <li>具体例</li>
                <div class="example">
                    <p><b>問題</b></p>
                    <p>二分探索木 (binary search tree) は、全順序 (total ordering) をもつ \(n\) 個の要素からなる集合を格納するためのデータ構造である。
                        このデータ構造について簡潔に説明せよ。
                        また、空の二分探索木に、ランダムに選ばれた \(n\) 個の要素を、二分探索木の構造を保ちながら一つずつ挿入する場合に、
                        要素一つあたりの挿入 (insert) にかかる平均時間計算量を \(O(\log n)\) とするための方法について説明せよ。</p>
                    <p><b>解答</b></p>
                    <p>
                        二分探索木 (Binary Search Tree, BST) は、全順序 (total ordering) を持つ要素からなるデータ構造である。
                        具体的には、以下の条件を満たすように構造化されている。
                    </p>
                    <ul>
                        <li>各ノードには値が格納されており、全てのノードは最大2つの子ノードを持つことができる。</li>
                        <li>任意のノード \(N\) について、その左の子ノードに格納されている全ての値は \(N\) の値より小さく、右の子ノードに格納されている全ての値は \(N\) の値より大きい。</li>
                        <li>左の子ノードと右の子ノードに対しても、同様の性質が再帰的に適用される。</li>
                    </ul>
                    <p>
                        これにより、任意の値に対する探索、挿入、削除といった操作を効率的に行うことが可能である。
                    </p>
                    <p>
                        空の二分探索木にランダムに選ばれた \(n\) 個の要素を挿入していく場合、それぞれの挿入操作は次の手順に従う。
                    </p>
                    <ol>
                        <li>ルートノードから開始し、挿入する値が現在のノードの値よりも小さい場合は左の子ノードへ、大きい場合は右の子ノードへ進む。</li>
                        <li>進む先の子ノードが存在しない場合、その場所に新しいノードを作成して値を挿入する。</li>
                    </ol>
                    <p>
                        各挿入操作において、BSTの高さに依存する比較が行われる。ランダムに選ばれた要素を挿入する場合、木の高さは平均して \(O(\log n)\) となるため、各要素の挿入にかかる平均時間は \(O(\log n)\) となる。
                    </p>
                </div>
            </ul>
            
            <h3>単純グラフ</h3>
            <ul>
                <li>具体例</li>
                <div class="example">
                    <b>問題</b>
                        <p>\(n\)個の頂点と\(m\)個の辺からなる無向グラフ \(G(V, E)\) について、以下の問いに答えよ。なお、ループ（自己閉路）も多重辺も含まないグラフを単純グラフという。</p>
                        <ol>
                            <li>
                                <p>以下の定義を答えよ。</p>
                                <ol>
                                    <li><strong>頂点の次数</strong></li>
                                    <p>頂点の次数とは、その頂点に接続している辺の数のことを指す。</p>
                                    <li><strong>完全グラフ</strong></li>
                                    <p>完全グラフとは、任意の2つの異なる頂点の間に辺が存在するグラフのことを指す。 \( n \) 頂点の完全グラフは \( K_n \) と表され、その辺の数は \( \frac{n(n-1)}{2} \) である。</p>
                                </ol>
                            </li>
                            <li>
                                <p>単純グラフ \(G(V, E)\) のすべての頂点の次数が \( \frac{n-1}{2} \) 以上であるとき、 \(G(V, E)\) は連結であることを示せ。</p>
                                <p>証明:</p>
                                <ol>
                                    <li>連結でないと仮定して、背理法によって証明する。</li>
                                    <li>つまり、\(G\)を\(G_1\)と\(G_2\)に分離可能だと仮定する。</li>
                                    <li>このとき、\(G_1\)に含まれる頂点 \(v\) は \( \frac{n-1}{2} \) 個以上の頂点と接続されている。</li>
                                    <li>\(v\) と接続されていない\(G_2\)に含まれる頂点の数は \( n - 1 - \frac{n-1}{2} = \frac{n-1}{2} \) 以下である。</li>
                                    <li>頂点数が \( \frac{n-1}{2} \) 以下の頂点群における最大次数は\( \frac{n-1}{2} - 1 \)以下である。</li>
                                    <li>したがって、\(G_2\)に含まれる頂点の次数が\( \frac{n-1}{2} \) 以上にならず、矛盾する。</li>
                                </ol>
                            </li>
                            <li>
                                <p>辺の数が \( m = \frac{(n-1)(n-2)}{2} \) であるような、連結ではない単純グラフが存在することを示せ。</p>
                                <p>証明:</p>
                                <ul>
                                    <li>１個の頂点だけが連結でない単純グラフでは、連結な\(n-1\)個の頂点から２頂点を選ぶと辺が存在するため、辺の数が\( m = \frac{(n-1)(n-2)}{2} \)となる。</li>
                                </ul>
                            </li>
                            <li>
                                <p>単純グラフ \( G(V, E) \) の辺の数が \( m \geq \frac{(n-1)(n-2)}{2} + 1 \) であるとき、 \( G(V, E) \) は連結であることを示せ。</p>
                                <p>証明:</p>
                                <ol>
                                    <li>\( m = \frac{(n-1)(n-2)}{2} \) のとき、グラフは１個の頂点だけが連結でない単純グラフであることを示した。</li>
                                    <li>しかし、\( m \geq \frac{(n-1)(n-2)}{2} + 1 \) であれば、少なくとも1つの追加の辺が存在する。</li>
                                    <li>この追加の辺は、連結でない１個の頂点を結びつける役割を果たすため、グラフ全体が連結になる。</li>
                                    <li>したがって、\( G(V, E) \) は連結であることが示された。</li>
                                </ol>
                            </li>
                        </ol>
                </div>
            </ul>
            <h3>ユークリッドの互除法</h3>
            <p>参考にしたサイトは以下のとおり。</p>
            <p><a href="http://www.dais.is.tohoku.ac.jp/~shioura/teaching/ad09/ad09-01.pdf">アルゴリズムとデータ構造 - Tohoku University</a></p>
            <ul>
                <li>具体例</li>
                <b>問題</b>
                <div class="example">
                    <p>正整数 \(a, b (a \geq b)\) を入力とし、それらの最大公約数を出力するユークリッドの互除法によるアルゴリズム \(GCD(a, b)\) について、以下の問いに答えよ。</p>
                    <ol>
                        <li>
                            <p>正整数 \(a, b (a \geq b)\) に対し、 \(a\) を \(b\) で割った商を \(q\)、余りを \(r\) とする。このとき、\(b,q,r\) を用いて\(a\)を表せ。</p>
                            <p>
                                \( a = bq + r \quad \text{(ただし、} 0 \leq r < b \text{)} \)
                            </p>
                        </li>
                        <li>
                            <p>(1) において \(r \neq 0\) のとき、ユークリッドの互除法では \(GCD(a, b)\) の出力が、何と同じであることを用いて計算するのか答えよ。</p>
                            <p>
                                \( GCD(a, b) = GCD(b, r) \)
                            </p>
                        </li>
                        <li>
                            <p>アルゴリズム GCD(a, b) の擬似コードを再帰アルゴリズムで書け。</p>
                            <pre>
                                <code>
def GCD(a, b):
    if b == 0:
        return a
    else:
        return GCD(b, a % b)
                                </code>
                            </pre>
                        </li>
                        <li>
                            <p>(3) の再帰アルゴリズムにおいて、\(GCD(a, b)\) が実行時の再帰回数が \(O(log a)\) であることを示せ。</p>
                            <p>証明:</p>
                            <ol>
                                <li>\(a > b > r, q \geq 1\)より、\(a = bq + r > 2r\)である。</li>
                                <li>つまり、互除法は各ステップで少なくとも半分に値が減少するため、最大で \( \log_2 a \) 回のステップが必要である。</li>
                                <li>したがって、再帰の深さは \( O(\log a) \) である。</li>
                            </ol>
                        </li>
                        <li>
                            <p>\(GCD(a, b)\) が \(O(log a)\) の多項式時間で計算できることを示せ。ただし、正整数 \(a, b (a \geq b)\) に対し、\(a\) を \(b\)で割った余りは \(O((\log_2 a)^2)\) 時間で計算できることを用いること。</p>
                            <p>証明:</p>
                            <ol>
                                <li>ユークリッドの互除法では、各ステップで \( a \) と \( b \) の割り算を行う。</li>
                                <li>割り算の計算量は \( O((\log_2 a)^2) \) であるため、1ステップあたりの計算量は \( O(\log a) \) である。</li>
                                <li>各ステップで少なくとも半分に値が減少するため、最大で \( \log_2 a \) 回のステップが必要である。</li>
                                <li>したがって、全体の計算量は <div class="scroll">\( O((\log_2 a)^2) \times O(\log_2 a) = O((\log a)^3) \)</div> となる。</li>
                                <li>これにより、GCD(a, b) は \( O(\log_2 a) \) の多項式時間で計算できることが示された。</li>
                            </ol>
                        </li>
                    </ol>                    
                </div>
            </ul>
            <h3>ネットワークフロー問題</h3>
            <p>参考にしたサイトは以下のとおり。</p>
            <p><a href="https://www.momoyama-usagi.com/entry/math-risan15#i-4">うさぎでもわかる離散数学（グラフ理論）　第15羽　最大フロー・最小カットの求め方 _ 工業大学生ももやまのうさぎ塾.html</a></p>
            <ul>
                <li>具体例</li>
                <div class="example">
                    <p><b>問題</b></p>
                    <p>グラフ理論において、有向連結グラフの各有向辺に非負の実数が割り当てられたものをネットワークと呼ぶ。
                    ネットワークフロー問題（最大フロー問題ともいう）について概略を述べよ、さらに、この問題に関する「最大フロー量と最小カット容量は等しい」という性質について説明せよ。</p>
                    <p><b>解答</b></p>
                    <b>ネットワークフロー問題（最大フロー問題）の概略</b>
                    <p>
                        ネットワークフロー問題とは、グラフ理論における問題の一つで、特に有向連結グラフ（ネットワーク）において、フローを最適化する問題である。この問題では、グラフの各辺にキャパシティ（容量）が割り当てられており、フローを源（ソース）からシンク（吸収点）まで最大化することが目的となる。
                    </p>
                    <p>
                        ネットワークフロー問題は、以下の要素から構成される：
                    </p>
                    <ul>
                        <li><strong>ネットワーク:</strong> グラフ \( G = (V, E) \) は、頂点の集合 \( V \) と辺の集合 \( E \) からなる。各辺 \( e \in E \) には非負の容量 \( c(e) \) が割り当てられている。</li>
                        <li><strong>ソースとシンク:</strong> 特定の始点であるソース \( s \) と終点であるシンク \( t \) が指定される。フローはソースからシンクに向けて流れる。</li>
                        <li><strong>フロー:</strong> 各辺 \( e \) に対して、フロー \( f(e) \) が存在し、これはその辺に流れる量を示す。このフローは、以下の2つの制約を満たさなければならない：
                            <ul>
                                <li><strong>容量制約:</strong> 各辺のフローは、その辺の容量を超えない。すなわち、\( 0 \leq f(e) \leq c(e) \)。</li>
                                <li><strong>フロー保存則:</strong> ソースとシンクを除くすべての頂点 \( v \in V \) では、入ってくるフローの合計と出ていくフローの合計が等しい。</li>
                            </ul>
                        </li>
                        <li><strong>目的:</strong> ソースからシンクに流れるフローの総量（ネットワーク全体のフロー量）を最大化する。</li>
                    </ul>
                    <p>
                        この問題を解くための代表的なアルゴリズムとしては、フォード-ファルカーソン法、エドモンズ-カープ法、プッシュ-リレーベル法などがある。
                    </p>
                
                    <b>最大フロー最小カット定理</b>
                    <p>
                        「最大フロー量と最小カット容量は等しい」という性質は、ネットワークフロー問題における最も重要な理論の一つである。これを <strong>最大フロー最小カット定理</strong> と呼ぶ。
                    </p>
                
                    <b>定理の説明</b>
                    <p>
                        この定理は、以下のように述べることができる：
                    </p>
                    <p>
                        あるネットワークにおいて、ソースからシンクに流れる最大フロー量は、ソースとシンクを分ける最小のカット（カットセット）の容量に等しい。
                    </p>
                    <p>
                        ここで、<strong>カット（cut）</strong> とは、グラフの頂点集合 \( V \) を2つの部分集合 \( S \) と \( T \) に分けることで、\( S \) にソース \( s \) が含まれ、\( T \) にシンク \( t \) が含まれるようにするものを指す。このとき、カットに含まれるすべての辺の容量の合計をカット容量と呼ぶ。
                    </p>
                    <ul>
                        <li><strong>最小カット容量:</strong> \( S \) と \( T \) の間にある辺の容量の総和が最も小さいカットを「最小カット」と呼び、その容量を「最小カット容量」と呼ぶ。</li>
                    </ul>
                    <p>
                        最大フロー最小カット定理は、以下のことを保証している：
                    </p>
                    <ol>
                        <li>ソースからシンクに流れることができる最大のフロー量は、そのネットワークにおいて存在するすべてのカットの中で、最小カットの容量と一致する。</li>
                        <li>逆に、最小カット容量を持つカットは、そのカットを越えてこれ以上フローを増加させることができない。</li>
                    </ol>
                    <p>
                        この定理の意味するところは、ネットワークの限界（つまり、フローの最大量）は、最も弱い部分（最小カット）によって決定されるということである。この定理は、ネットワークフローの理論において非常に強力な結果であり、フローの最適化問題やその応用において重要な役割を果たしている。
                    </p>
                
                    <b>まとめ</b>
                    <p>
                        ネットワークフロー問題は、ソースからシンクに至るフローの最大化を目指す問題であり、最大フロー最小カット定理は、この問題におけるフローの最大量がネットワークの最も制限された部分（最小カット）の容量によって決定されることを示す重要な結果である。
                    </p>
                </div>
            </ul>
            <h3>ソート</h3>
            <p>参考にしたサイトは以下のとおり。</p>
            <p><a href="https://avinton.com/blog/2020/04/engineering-basics-sorting-algorithm/">基本情報技術者　ソートのアルゴリズムとは？ - Avinton Japan.html</a></p>
            <ul>
                <li>具体例</li>
                <div class="example">
                    <p><b>問題</b></p>
                    <p>
                        平均時間計算量と最悪時間計算量について説明せよ。次に、「挿入ソート（整列済みの配列部分に、新しく読み込んだデータを順次挿入する）」、「マージソート（配列を再帰的に2分割した上で、分割した配列を順次整列しながらマージする）」、「クイックソート（ピボットとなる数を選び、その数より小さいデータとそれ以外に分割していき、最終的に、これらの配列をまとめ上げる）」の3種類のアルゴリズムを、これらの計算量の概念を使って比較せよ。
                    </p>
                    <p><b>解答</b></p>
                    <b>平均時間計算量と最悪時間計算量について</b>
                    <p>
                        <strong>平均時間計算量</strong>とは、アルゴリズムが与えられた問題を解くのにかかる平均的な時間を表すものである。これは、あらゆる入力ケースを考慮し、それらのケースでの計算時間の平均を取ることで得られる。
                    </p>
                    <p>
                        <strong>最悪時間計算量</strong>とは、アルゴリズムが最も時間がかかるケースに対して必要とする最大の計算時間を表すものである。この計算量は、特定のアルゴリズムが最悪の状況下でどの程度の時間を要するかを評価するために使用される。
                    </p>
                
                    <b>ソートアルゴリズムの計算量比較</b>
                    <ol>
                        <li>
                            <strong>挿入ソート (Insertion Sort)</strong>
                            <ul>
                                <li><strong>アルゴリズムの概要:</strong> 挿入ソートは、未ソートのデータを順次取り出し、すでにソートされた部分に正しい位置に挿入していくことでソートを行う。</li>
                                <li><strong>平均時間計算量:</strong> \(O(n^2)\)</li>
                                <li><strong>最悪時間計算量:</strong> \(O(n^2)\)</li>
                                <li><strong>解説:</strong> 挿入ソートは、データがほぼソートされている場合に効率的であるが、逆にソートがまったくされていない場合は非常に非効率である。平均および最悪の計算量は二次時間計算量である。</li>
                            </ul>
                        </li>
                        <li>
                            <strong>マージソート (Merge Sort)</strong>
                            <ul>
                                <li><strong>アルゴリズムの概要:</strong> マージソートは、与えられた配列を再帰的に2つに分割し、それぞれをソートした後にマージすることでソートを行う。</li>
                                <li><strong>平均時間計算量:</strong> \(O(n \log n)\)</li>
                                <li><strong>最悪時間計算量:</strong> \(O(n \log n)\)</li>
                                <li><strong>解説:</strong> マージソートは、分割と統治法を使用しており、常に安定した効率性を持っている。データの分割と統合のステップがログ時間計算量をもたらし、全体としては線形対数時間計算量になる。</li>
                            </ul>
                        </li>
                        <li>
                            <strong>クイックソート (Quick Sort)</strong>
                            <ul>
                                <li><strong>アルゴリズムの概要:</strong> クイックソートは、配列からピボットを選び、ピボットより小さい要素と大きい要素に分割し、それぞれを再帰的にソートすることで全体をソートする。</li>
                                <li><strong>平均時間計算量:</strong> \(O(n \log n)\)</li>
                                <li><strong>最悪時間計算量:</strong> \(O(n^2)\)</li>
                                <li><strong>解説:</strong> クイックソートは、選択されたピボットが適切であれば効率的であるが、最悪の場合、選択が偏ってしまうと二次時間計算量に悪化する可能性がある。</li>
                            </ul>
                        </li>
                    </ol>
                
                    <b>アルゴリズムの比較</b>
                    <p>
                        <strong>効率性:</strong> クイックソートとマージソートは平均計算量が共に \(O(n \log n)\) であるため、効率的である。ただし、クイックソートはデータ分割がうまくいかないと最悪計算量が \(O(n^2)\) になるリスクがある。一方、マージソートは常に \(O(n \log n)\) で安定している。
                    </p>
                    <p>
                        <strong>安定性:</strong> 挿入ソートはデータがほぼソートされている場合に適しており、少量のデータセットに対しては効果的である。しかし、大量のデータや無秩序なデータに対しては非効率的である。
                    </p>
                    <p>
                        <strong>実用性:</strong> クイックソートは最悪ケースに注意を払いつつも、一般に最も実用的であると考えられている。マージソートは、安定性が求められる場面や一定の効率性が常に保証される場合に適している。
                    </p>
                
                    <p>
                        これらのソートアルゴリズムは、データの性質や問題の要件に応じて使い分けるべきである。
                    </p>
                </div>
            </ul>
            <h3>動的計画法</h3>
            <p>参考にしたサイトは以下のとおり。</p>
            <p><a href="https://www.momoyama-usagi.com/entry/info-algo-dp">うさぎでもわかるアルゴリズム　動的計画法 _ 工業大学生ももやまのうさぎ塾.html</a></p>
            <p><a href="https://sikepuri-algorithm.github.io/docs/algorithms/dp/">動的計画法 _ アルゴリズム入門.html</a></p>
            <ul>
                <li>具体例</li>
                <div class="example">
                    <p><b>問題</b></p>
                    <p>アルゴリズムの技法の1つである動的計画法とは、どのような原理によって計算の効率化を図る技法であるかを説明せよ。具体的な例題として、10円、20円、30円、40円、50円、60円の6種類の額面の切手をそれぞれ1枚ずつ持っている場合に、このうち何枚かを組み合わせてちょうど100円にする組合せが何通りあるかを求める問題を考え、この問題を動的計画法により解いた場合の計算過程を図または表で示して、どのように計算時間が節約されるかを説明せよ。</p>
                    <p><b>解答</b></p>
                    <p>
                        この問題は、部分問題に分割して解くことができる。具体的には、「合計が100円になる組み合わせが何通りあるか？」という問題を、
                        より小さな合計金額についての問題に帰着させる。
                    </p>
                    <p>部分問題の定義:</p>
                    <p>\( dp[i] \) を「合計が \( i \) 円になる組み合わせの数」と定義する。</p>
                    <p>初期条件:</p>
                    <p>
                        何も選ばない状態、つまり合計が0円である場合は、1通りの組み合わせがあるとする。したがって、\( dp[0] = 1 \) である。
                    </p>
                    <p>遷移方程式:</p>
                    <p>
                        各額面 \( a \) について、金額 \( i \) を超えない範囲で以下のように遷移する：
                    </p>
                    <p>\( dp[i] += dp[i - a] \)</p>
                    <p>
                        これは、「現在の金額 \( i \) から額面 \( a \) を引いた金額 \( i - a \) で作れる組み合わせに、額面 \( a \) を追加する」ことを意味する。
                    </p>
                    <p>計算過程:</p>
                    <p>
                        まず、金額 \( i \) に対して \( dp[i] \) をすべて0で初期化し、初期条件 \( dp[0] = 1 \) を設定する。そして、各額面に対して上記の遷移を行う。
                    </p>
                    <p>実際の計算過程:</p>
                    <div class="scroll">
                    <table>
                        <tr>
                            <th>金額 i</th>
                            <th>0</th>
                            <th>10</th>
                            <th>20</th>
                            <th>30</th>
                            <th>40</th>
                            <th>50</th>
                            <th>60</th>
                            <th>70</th>
                            <th>80</th>
                            <th>90</th>
                            <th>100</th>
                        </tr>
                        <tr>
                            <td>初期状態</td>
                            <td>1</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>10円追加</td>
                            <td>1</td>
                            <td>1</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>20円追加</td>
                            <td>1</td>
                            <td>1</td>
                            <td>1</td>
                            <td>1</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>30円追加</td>
                            <td>1</td>
                            <td>1</td>
                            <td>1</td>
                            <td>2</td>
                            <td>1</td>
                            <td>1</td>
                            <td>1</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>40円追加</td>
                            <td>1</td>
                            <td>1</td>
                            <td>1</td>
                            <td>2</td>
                            <td>2</td>
                            <td>2</td>
                            <td>2</td>
                            <td>2</td>
                            <td>1</td>
                            <td>1</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>50円追加</td>
                            <td>1</td>
                            <td>1</td>
                            <td>1</td>
                            <td>2</td>
                            <td>2</td>
                            <td>3</td>
                            <td>3</td>
                            <td>3</td>
                            <td>3</td>
                            <td>3</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>60円追加</td>
                            <td>1</td>
                            <td>1</td>
                            <td>1</td>
                            <td>2</td>
                            <td>2</td>
                            <td>3</td>
                            <td>4</td>
                            <td>4</td>
                            <td>4</td>
                            <td>5</td>
                            <td>5</td>
                        </tr>
                    </table>
                    </div>
                    <p>最終結果:</p>
                    <p>上記の計算から、ちょうど100円にする組み合わせの数は5通りであることがわかる。</p>
                    <p>（実際、(60, 40), (60, 30, 10), (50, 40, 10), (50, 30, 20), (40, 30, 20, 10)の5通りである。）</p>
                
                    <p>計算時間の節約:</p>
                    <p>
                        このように動的計画法を用いることで、各金額に対しての計算を順次積み重ねていくため、
                        全ての組み合わせを直接調べるよりも計算効率が大幅に向上する。
                        具体的には、全探索の場合はある切手を「追加する」「追加しない」によって2分木を構築できるため、計算量は\(O(2^n)\)となる。
                        一方で、動的計画法の場合は上の表を埋めるだけでよいので、\(\text{縦} \times \text{横} = 6 \times 10 = 60\)より、\(O(60)\)で済む。
                    </p>
                </div>
            </ul>
        </section>
    </main>
</body>
</html>
