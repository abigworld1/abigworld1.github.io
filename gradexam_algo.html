<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【院試対策|北海道大学 情報科学院】走る作曲家のAIカフェ～アルゴリズムとデータ構造編～</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <header>
        <h1>走る作曲家のAIカフェ</h1>
        <nav>
            <ul>
                <li><a href="index.html">ホーム</a></li>
                <li><a href="study.html">勉強</a></li>
                <li><a href="music.html">音楽</a></li>
                <li><a href="sports.html">スポーツ</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section>
          <p>「北海道大学大学院情報科学院修士課程入学試験」（令和6年8月実施）の「<b>アルゴリズムとデータ構造</b>」対策ページです。</p>
        </section>
        <section>
          <h2>分野別対策</h2>
          <ul>
            <li><a href="gradexam.html">院試対策 ～はじめに～</a></li>
            <li><a href="gradexam_basicmath.html">院試対策 ～基礎数学編～</a></li>
            <li><a href="gradexam_infomath.html">院試対策 ～情報数学編～</a></li>
            <li><a href="gradexam_statistics.html">院試対策 ～確率・統計編～</a></li>
            <li><a href="gradexam_infotheory.html">院試対策 ～情報理論編～</a></li>
            <li><a href="gradexam_algo.html">院試対策 ～アルゴリズムとデータ構造編～</a></li>
            <li><a href="gradexam_ai.html">院試対策 ～人工知能編～</a></li>
            <li><a href="gradexam_cs.html">院試対策 ～コンピュータシステム編～</a></li>
          </ul>
        </section>
        <section id="algorithms-data-structures">
          <h2>アルゴリズムとデータ構造</h2>
            <h3>計算量、オーダー表記</h3>
            <p>参考にしたサイトは以下のとおり。</p>
            <p><a href="https://www.momoyama-usagi.com/entry/calc-order">プログラムの計算量、オーダー表記 O( ) の求め方のまとめ _ 工業大学生ももやまのうさぎ塾.html</a></p>
            <ul>
                <li>項の強さを弱い順に左から並べると、以下のとおりである。</li>
                <ul>
                    <li>\(logn, \sqrt{n}, n, nlogn, n^2, n^3, 2^n, n!\)</li>
                </ul>
            </ul>
            <h3>最小全域木</h3>
            <p>参考にしたサイトは以下のとおり。</p>
            <p><a href="https://www.momoyama-usagi.com/entry/math-risan13">うさぎでもわかる離散数学（グラフ理論）　第13羽　最小全域木の求め方（クラスカル法・プリム法） _ 工業大学生ももやまのうさぎ塾.html</a></p>
            <ul>
                <li><b>全域木</b>とは、もとのグラフのすべての点を含み、さらに選んだ辺が木となっているようなグラフである。</li>
                <li><b>最小全域木</b>とは、選んだ辺の重みの合計が一番小さい全域木のことである。</li>
                <li>最小全域木を求めるアルゴリズム①「<b>クラスカル法</b>」は以下のとおりである。</li>
                <ol>
                    <li>重みが小さい順に辺をチェックする。</li>
                    <li>チェックした辺を追加しても閉路ができなければ辺を追加する。追加して閉路ができてしまう場合は無視する。</li>
                    <li>すべての辺をチェックし終わったときに追加された辺が最小全域木である。</li>
                </ol>
                <li>最小全域木を求めるアルゴリズム②「<b>プリム法</b>」は以下のとおりである。</li>
                <ol>
                    <li>スタートの点を１つ決める（どこでも良い）。</li>
                    <li>スタート点から辿れる辺の中で最も重みが小さい辺を追加する（最も重みが小さい辺が複数ある場合は、重みが小さいどの辺を選んでも良い）。</li>
                    <li>追加した辺につながっているすべての点から辿れる辺かつ追加しても閉路とならない辺の中から最も重みが小さい辺を追加する。</li>
                    <li>追加できる辺がなくなったとき、最小全域木である。</li>
                </ol>
            </ul>
            <h3>ダイクストラ法</h3>
            <p>参考にしたサイトは以下のとおり。</p>
            <p><a href="https://algo-logic.info/dijkstra/">ダイクストラ法による単一始点最短経路を求めるアルゴリズム _ アルゴリズムロジック.html</a></p>
            <ul>
                <li>ダイクストラ法は、ネットワークにおいて、すべての頂点\(v\)に対して、指定された頂点\(s\)から頂点\(v\)への最短路長\(D(v)\)を求めるアルゴリズムである。</li>
                <li>アルゴリズムは以下のとおりである。</li>
                <ol>
                    <li>始点\(s\)を「既に最短距離が確定した頂点」、他の頂点を「まだ最短距離が確定していない頂点」とする。</li>
                    <li>以下をすべての頂点の最短距離が確定するまで繰り返す。</li>
                    <ol>
                        <li>すべての「既に最短距離が確定した頂点\(u\)」から「まだ最短距離が確定していない頂点\(v\)」へ伸びるすべての辺\(e=(u, v)\)について、「\(v\)と\(D(v)\)の候補」をまとめておく。</li>
                        <li>候補の中から、\(D(v)\)が最小のものを選択し、\(v\)を「既に最短距離が確定した頂点」に加える。</li>
                    </ol>
                </ol>
            </ul>
            <h3>幅優先探索(BFS)、深さ優先探索(DFS)</h3>
            <p>参考にしたサイトは以下のとおり。</p>
            <p><a href="https://www.momoyama-usagi.com/entry/info-algo-tree-traverse">うさぎでもわかる2分探索木　後編　2分探索木における4つの走査方法 _ 工業大学生ももやまのうさぎ塾.html</a></p>
            <p><a href="https://manabitimes.jp/math/1247">深さ優先探索と幅優先探索 _ 高校数学の美しい物語.html</a></p>
            <p><b>幅優先探索 (BFS)</b></p>
            <ul>
                <li>概略
                <p>幅優先探索 (BFS) は、グラフや木の探索アルゴリズムであり、探索の開始点から近い順にすべての頂点やノードを探索する方法である。具体的には、最初にルートノードや開始ノードをキューに入れ、その後、キューから順にノードを取り出して、隣接するすべての未探索のノードをキューに追加していく。この過程をキューが空になるまで繰り返す。</p>
                </li>
                <li>特徴
                <ul>
                    <li><strong>最短経路:</strong> BFSは、探索を開始するノードから他のすべてのノードへの最短経路を見つけることができる。特に無加重のグラフにおいて、最短経路の問題に適している。</li>
                    <li><strong>使用するデータ構造:</strong> キュー（FIFO）を使用して、探索するノードを管理する。</li>
                    <li><strong>メモリ効率:</strong> BFSは探索のすべてのレベルのノードをキューに保持するため、メモリ使用量が大きくなることがある。特に、広いグラフや木では、キューのサイズが非常に大きくなる可能性がある。</li>
                    <li><strong>用途:</strong> 幅優先探索は、迷路問題、ネットワークルーティング、ウェブクローリングなど、探索の深さよりも幅を優先する問題でよく使われる。</li>
                </ul>
                </li>
            </ul>
    
            <p><b>深さ優先探索 (DFS)</b></p>
            <ul>
                <li>概略
                <p>深さ優先探索 (DFS) は、グラフや木の探索アルゴリズムであり、探索の開始点からできるだけ深く進み、行き止まりに達したらバックトラックして他の未探索のノードを探索する方法である。具体的には、ルートノードや開始ノードをスタックに入れ、スタックからノードを取り出して、その隣接ノードをスタックに追加していく。スタックが空になるまでこの過程を繰り返す。</p>
                </li>
                <li>特徴
                <ul>
                    <li><strong>メモリ効率:</strong> DFSは、探索中のノードとその子ノードのみをスタックに保持するため、BFSに比べてメモリ使用量が少なく済む。特に、深いグラフや木ではメモリ効率が良い。</li>
                    <li><strong>使用するデータ構造:</strong> スタック（LIFO）を使用して、探索するノードを管理する。再帰を用いて実装されることも多い。</li>
                    <li><strong>全体探索:</strong> DFSは、すべてのノードを探索する必要がある問題に適しており、木やグラフのすべてのノードを訪問することが保証される。</li>
                    <li><strong>用途:</strong> 深さ優先探索は、パズルの解決、コンポーネントの検出、トップソート、バックトラッキングアルゴリズムなど、探索の幅よりも深さを優先する問題でよく使われる。</li>
                </ul>
                </li>
            </ul>
    
            <p><b>幅優先探索と深さ優先探索の比較</b></p>
            <ul>
                <li><strong>経路の探索:</strong> BFSは最短経路を見つけるのに優れているが、DFSは一つの経路を見つけるのに優れている。</li>
                <li><strong>メモリ使用量:</strong> BFSはメモリ使用量が多くなりがちであるが、DFSは比較的少なく済む。</li>
                <li><strong>時間効率:</strong> 両者の時間計算量は、最悪の場合は同じであるが、問題の特性によってどちらが効率的かが異なる。</li>
                <li><strong>用途の違い:</strong> BFSは最短経路探索やレベルごとの探索に適し、DFSは完全探索やバックトラッキングに適している。</li>
            </ul>

            <h3>二分探索木</h3>
            <ul>
                <li>具体例</li>
                <div class="example">
                    <p><b>問題</b></p>
                    <p>二分探索木 (binary search tree) は、全順序 (total ordering) をもつ \(n\) 個の要素からなる集合を格納するためのデータ構造である。
                        このデータ構造について簡潔に説明せよ。
                        また、空の二分探索木に、ランダムに選ばれた \(n\) 個の要素を、二分探索木の構造を保ちながら一つずつ挿入する場合に、
                        要素一つあたりの挿入 (insert) にかかる平均時間計算量を \(O(\log n)\) とするための方法について説明せよ。</p>
                    <p><b>解答</b></p>
                    <p>
                        二分探索木 (Binary Search Tree, BST) は、全順序 (total ordering) を持つ要素からなるデータ構造である。
                        具体的には、以下の条件を満たすように構造化されている。
                    </p>
                    <ul>
                        <li>各ノードには値が格納されており、全てのノードは最大2つの子ノードを持つことができる。</li>
                        <li>任意のノード \(N\) について、その左の子ノードに格納されている全ての値は \(N\) の値より小さく、右の子ノードに格納されている全ての値は \(N\) の値より大きい。</li>
                        <li>左の子ノードと右の子ノードに対しても、同様の性質が再帰的に適用される。</li>
                    </ul>
                    <p>
                        これにより、任意の値に対する探索、挿入、削除といった操作を効率的に行うことが可能である。
                    </p>
                    <p>
                        空の二分探索木にランダムに選ばれた \(n\) 個の要素を挿入していく場合、それぞれの挿入操作は次の手順に従う。
                    </p>
                    <ol>
                        <li>ルートノードから開始し、挿入する値が現在のノードの値よりも小さい場合は左の子ノードへ、大きい場合は右の子ノードへ進む。</li>
                        <li>進む先の子ノードが存在しない場合、その場所に新しいノードを作成して値を挿入する。</li>
                    </ol>
                    <p>
                        各挿入操作において、BSTの高さに依存する比較が行われる。ランダムに選ばれた要素を挿入する場合、木の高さは平均して \(O(\log n)\) となるため、各要素の挿入にかかる平均時間は \(O(\log n)\) となる。
                    </p>
                </div>
            </ul>
            
            <h3>単純グラフ</h3>
            <ul>
                <li>具体例</li>
                <div class="example">
                    <b>問題</b>
                        <p>\(n\)個の頂点と\(m\)個の辺からなる無向グラフ \(G(V, E)\) について、以下の問いに答えよ。なお、ループ（自己閉路）も多重辺も含まないグラフを単純グラフという。</p>
                        <ol>
                            <li>
                                <p>以下の定義を答えよ。</p>
                                <ol>
                                    <li><strong>頂点の次数</strong></li>
                                    <p>頂点の次数とは、その頂点に接続している辺の数のことを指す。</p>
                                    <li><strong>完全グラフ</strong></li>
                                    <p>完全グラフとは、任意の2つの異なる頂点の間に辺が存在するグラフのことを指す。 \( n \) 頂点の完全グラフは \( K_n \) と表され、その辺の数は \( \frac{n(n-1)}{2} \) である。</p>
                                </ol>
                            </li>
                            <li>
                                <p>単純グラフ \(G(V, E)\) のすべての頂点の次数が \( \frac{n-1}{2} \) 以上であるとき、 \(G(V, E)\) は連結であることを示せ。</p>
                                <p>証明:</p>
                                <ol>
                                    <li>連結でないと仮定して、背理法によって証明する。</li>
                                    <li>つまり、\(G\)を\(G_1\)と\(G_2\)に分離可能だと仮定する。</li>
                                    <li>このとき、\(G_1\)に含まれる頂点 \(v\) は \( \frac{n-1}{2} \) 個以上の頂点と接続されている。</li>
                                    <li>\(v\) と接続されていない\(G_2\)に含まれる頂点の数は \( n - 1 - \frac{n-1}{2} = \frac{n-1}{2} \) 以下である。</li>
                                    <li>頂点数が \( \frac{n-1}{2} \) 以下の頂点群における最大次数は\( \frac{n-1}{2} - 1 \)以下である。</li>
                                    <li>したがって、\(G_2\)に含まれる頂点の次数が\( \frac{n-1}{2} \) 以上にならず、矛盾する。</li>
                                </ol>
                            </li>
                            <li>
                                <p>辺の数が \( m = \frac{(n-1)(n-2)}{2} \) であるような、連結ではない単純グラフが存在することを示せ。</p>
                                <p>証明:</p>
                                <ul>
                                    <li>１個の頂点だけが連結でない単純グラフでは、連結な\(n-1\)個の頂点から２頂点を選ぶと辺が存在するため、辺の数が\( m = \frac{(n-1)(n-2)}{2} \)となる。</li>
                                </ul>
                            </li>
                            <li>
                                <p>単純グラフ \( G(V, E) \) の辺の数が \( m \geq \frac{(n-1)(n-2)}{2} + 1 \) であるとき、 \( G(V, E) \) は連結であることを示せ。</p>
                                <p>証明:</p>
                                <ol>
                                    <li>\( m = \frac{(n-1)(n-2)}{2} \) のとき、グラフは１個の頂点だけが連結でない単純グラフであることを示した。</li>
                                    <li>しかし、\( m \geq \frac{(n-1)(n-2)}{2} + 1 \) であれば、少なくとも1つの追加の辺が存在する。</li>
                                    <li>この追加の辺は、連結でない１個の頂点を結びつける役割を果たすため、グラフ全体が連結になる。</li>
                                    <li>したがって、\( G(V, E) \) は連結であることが示された。</li>
                                </ol>
                            </li>
                        </ol>
                </div>
            </ul>
            <h3>ユークリッドの互除法</h3>
            <p>参考にしたサイトは以下のとおり。</p>
            <p><a href="http://www.dais.is.tohoku.ac.jp/~shioura/teaching/ad09/ad09-01.pdf">アルゴリズムとデータ構造 - Tohoku University</a></p>
            <ul>
                <li>具体例</li>
                <b>問題</b>
                <div class="example">
                    <p>正整数 \(a, b (a \geq b)\) を入力とし、それらの最大公約数を出力するユークリッドの互除法によるアルゴリズム \(GCD(a, b)\) について、以下の問いに答えよ。</p>
                    <ol>
                        <li>
                            <p>正整数 \(a, b (a \geq b)\) に対し、 \(a\) を \(b\) で割った商を \(q\)、余りを \(r\) とする。このとき、\(b,q,r\) を用いて\(a\)を表せ。</p>
                            <p>
                                \( a = bq + r \quad \text{(ただし、} 0 \leq r < b \text{)} \)
                            </p>
                        </li>
                        <li>
                            <p>(1) において \(r \neq 0\) のとき、ユークリッドの互除法では \(GCD(a, b)\) の出力が、何と同じであることを用いて計算するのか答えよ。</p>
                            <p>
                                \( GCD(a, b) = GCD(b, r) \)
                            </p>
                        </li>
                        <li>
                            <p>アルゴリズム GCD(a, b) の擬似コードを再帰アルゴリズムで書け。</p>
                            <pre>
                                <code>
def GCD(a, b):
    if b == 0:
        return a
    else:
        return GCD(b, a % b)
                                </code>
                            </pre>
                        </li>
                        <li>
                            <p>(3) の再帰アルゴリズムにおいて、\(GCD(a, b)\) が実行時の再帰回数が \(O(log a)\) であることを示せ。</p>
                            <p>証明:</p>
                            <ol>
                                <li>\(a > b > r, q \geq 1\)より、\(a = bq + r > 2r\)である。</li>
                                <li>つまり、互除法は各ステップで少なくとも半分に値が減少するため、最大で \( \log_2 a \) 回のステップが必要である。</li>
                                <li>したがって、再帰の深さは \( O(\log a) \) である。</li>
                            </ol>
                        </li>
                        <li>
                            <p>\(GCD(a, b)\) が \(O(log a)\) の多項式時間で計算できることを示せ。ただし、正整数 \(a, b (a \geq b)\) に対し、\(a\) を \(b\)で割った余りは \(O((\log_2 a)^2)\) 時間で計算できることを用いること。</p>
                            <p>証明:</p>
                            <ol>
                                <li>ユークリッドの互除法では、各ステップで \( a \) と \( b \) の割り算を行う。</li>
                                <li>割り算の計算量は \( O((\log_2 a)^2) \) であるため、1ステップあたりの計算量は \( O(\log a) \) である。</li>
                                <li>各ステップで少なくとも半分に値が減少するため、最大で \( \log_2 a \) 回のステップが必要である。</li>
                                <li>したがって、全体の計算量は <div class="scroll">\( O((\log_2 a)^2) \times O(\log_2 a) = O((\log a)^3) \)</div> となる。</li>
                                <li>これにより、GCD(a, b) は \( O(\log_2 a) \) の多項式時間で計算できることが示された。</li>
                            </ol>
                        </li>
                    </ol>                    
                </div>
            </ul>
        </section>
    </main>
</body>
</html>
