<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【March Machine Learning Mania 2025 | Kaggle】走る作曲家のAIカフェ</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1050827580219099"
     crossorigin="anonymous"></script>
</head>
<body>
    <header>
        <h1>走る作曲家のAIカフェ</h1>
        <nav>
            <ul>
                <li><a href="index.html">ホーム</a></li>
                <li><a href="study.html">勉強</a></li>
                <li><a href="music.html">音楽</a></li>
                <li><a href="sports.html">スポーツ</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section>
            <h2>March Machine Learning Mania 2025</h2>
            <p><a href="https://www.kaggle.com/competitions/march-machine-learning-mania-2025">March Machine Learning Mania 2025</a></p>
        </section>
        <section>
          <h2>Overview</h2>
          <p>2025年の大学バスケットボールの男子・女子両方のトーナメントの結果を予測し、考え得るすべての試合の予測を提出する。</p>
        </section>
        <section>
          <h2>Description</h2>
          <p>このコンペティションでは、過去のNCAAの試合データが提供され、NCAA男子および女子のディビジョン1バスケットボールトーナメントの結果を予測する。</p>
          <p>トーナメント開始前のリーダーボードは2021～2024年のスコアのみを反映する。2025年の試合が始まり次第、Kaggle は結果を随時反映し、スコアを更新していく。</p>
        </section>
        <section>
          <h2>Evaluation</h2>
          <p>提出物は、予測した確率と実際の試合結果との間の<a href="https://qiita.com/Derek/items/e382c087afd616a0053e">Brier Score</a>に基づいて評価される（このコンテキストでは平均二乗誤差（Mean Squared Error）と同等）。</p>
          <p>各試合にはユニークなIDが付与されており、以下の形式で作成される：</p>
          <pre><code>
[シーズン]_[チームID1]_[チームID2]
          </code></pre>
          <p>たとえば「2025_1101_1102」であれば、2025年におけるチーム1101と1102の対戦を表す。</p>
          <p>提出時は、チームIDが小さい方を先に記述し、そのチームが勝つ確率（0〜1）を予測する。</p>
          <p>男子チームと女子チームの TeamID は重複しないので、1つのファイルで男女混合の予測を提出できる。</p>
          <p>提出ファイルの例：</p>
          <pre><code>
ID,Pred
2025_1101_1102,0.5
2025_1101_1103,0.5
2025_1101_1104,0.5
...
          </code></pre>
          <p><code>Pred</code>には、TeamID が小さい方のチームが勝つ確率（0〜1）を記載する。</p>
          <p>2025年のトーナメントが始まるまでは、提出ファイルのフォーマットが正しいか確認する目的でスコアが0.0で表示される。試合結果が反映され次第リーダーボードが再計算される。</p>
        </section>
        <section>
            <h2>Dataset Description</h2>
            <p>毎シーズン、NCAA®ディビジョンIの大学バスケットボールチーム同士による数千試合が行われ、3月中旬から4月上旬にかけて開催される March Madness®（全米選手権） 男子・女子トーナメントにつながる。本コンペでは、過去の膨大な試合データを提供し、それを用いて March Madness® の試合結果を独自に予測できる。</p>
            <p>データファイルには男子（Men’s）と女子（Women’s）の両方が含まれる。</p>
            <ul>
                <li>男子データのみ含むファイル：ファイル名が <code>M</code> で始まる（例：<code>MRegularSeasonCompactResults.csv</code>）</li>
                <li>女子データのみ含むファイル：ファイル名が <code>W</code> で始まる（例：<code>WRegularSeasonCompactResults.csv</code>）</li>
                <li>男女共通のファイル：<code>Cities.csv</code> や <code>Conferences.csv</code> など</li>
            </ul>
            <p>外部のデータとコンペのデータをマッチングするために、以下のファイルが提供されている：</p>
            <ul>
                <li><code>MTeamSpellings.csv</code>（男子用）</li>
                <li><code>WTeamSpellings.csv</code>（女子用）</li>
            </ul>
            <p>これらを利用し、外部で参照されるチーム名を本コンペの TeamID に対応づけられる。</p>
            <p>すべてのファイルは今シーズン（2024-25）の1月28日までのデータを含む。3月中旬頃に残りの試合を反映した更新ファイルが提供される見込み。</p>
        </section>
        <section>
            <h2>Data Section 1 - 基本データ</h2>
            <p>ここでは、シンプルな予測モデルを構築し、予測を提出するために必要なすべての情報を提供している。</p>
            <p>チームIDとチーム名<br>
            1984-85シーズン以降のトーナメントシード<br>
            1984-85シーズン以降の全レギュラーシーズン、カンファレンストーナメント、NCAA®トーナメントの最終スコア<br>
            シーズンに関する詳細（試合日やリージョン情報など）<br>
            ステージ1の提出例ファイル</p>
            <p>慣例として、特定のシーズンを識別する際は開始年ではなく終了年で表現する。</p>

            <h3>Data Section 1 ファイル: MTeams.csv と WTeams.csv</h3>
            <p>これらのファイルには、データセットに含まれる各大学チームに関する情報が含まれている。</p>
            <ul>
                <li><strong>TeamID</strong>：4桁のID。NCAA®男子または女子チームを一意に識別する。男子チームは1000〜1999、女子チームは3000〜3999の範囲。</li>
                <li><strong>TeamName</strong>：16文字以内でコンパクトに表記されたチーム名。</li>
                <li><strong>FirstD1Season</strong>：このデータセットで、そのチームが初めてディビジョンIとして登録されているシーズン（男子のみのカラム）。</li>
                <li><strong>LastD1Season</strong>：同データセットで、そのチームが最後にディビジョンIとして登録されているシーズン（男子のみのカラム）。現在もディビジョンIに属するチームは 2025 が記載される。</li>
            </ul>

            <h3>Data Section 1 ファイル: MSeasons.csv と WSeasons.csv</h3>
            <p>過去のシーズン情報、およびシーズン単位での追加情報（例：DayZero, 地域名）を含むファイル。</p>
            <ul>
                <li><strong>Season</strong>：その年のトーナメントが行われた年。</li>
                <li><strong>DayZero</strong>：各シーズンの DayNum=0 に対応する日付。すべての試合日付を同一の枠組みに合わせており、男子トーナメントの決勝戦は毎年 DayNum=154（月曜日）と定義される。<br>
                （例：あるシーズンの DayZero が 10/31 なら、DayNum=7 は 11/07 にあたる、など）</li>
                <li><strong>RegionW, RegionX, RegionY, RegionZ</strong>：最終トーナメントにおける4つの地域（リージョン）に、W, X, Y, Z のラベルを付与する。アルファベット順で最も早い地域がW、そのWと対戦する地域がX、残り2地域のうちアルファベット順で早いほうがY、遅いほうがZ として割り当てる。</li>
            </ul>

            <h3>Data Section 1 ファイル: MNCAATourneySeeds.csv と WNCAATourneySeeds.csv</h3>
            <p>各NCAA®トーナメントでのシード情報を示すファイル。各シーズン64～68チーム分のシード（プレーインがある場合など）を掲載。近年は計68チーム（4試合のプレーインを含む）が定着している。実際のトーナメントシードや参加チームが確定するのは2025年のセレクションサンデー（3/16, DayNum=132）以降。</p>
            <ul>
                <li><strong>Season</strong>：そのトーナメントが行われた年。</li>
                <li><strong>Seed</strong>：3～4文字で構成されるシード。最初の文字 W/X/Y/Z は地域を表し、次の2桁がシード番号（01〜16）。プレーインの場合は最後に a, b が付与され、同じ3文字のシードを持つチーム同士が対戦する。a, b は TeamID の小さい順で割り当て。</li>
                <li><strong>TeamID</strong>：MTeams.csv や WTeams.csv で定義されるチームID。</li>
            </ul>

            <h3>Data Section 1 ファイル: MRegularSeasonCompactResults.csv と WRegularSeasonCompactResults.csv</h3>
            <p>過去シーズンにおけるレギュラーシーズン（DayNum 0〜132）の試合結果をまとめたファイル。男子は1985シーズン（64チーム制の初年）から、女子は1998シーズンから。</p>
            <ul>
                <li><strong>Season</strong>：MSeasons.csv/WSeasons.csv の年（最終的なトーナメントが行われる年）。</li>
                <li><strong>DayNum</strong>：0〜132の範囲。DayZero からのオフセット。</li>
                <li><strong>WTeamID</strong>：試合に勝利したチーム（Home/Away/Neutral問わず）。</li>
                <li><strong>WScore</strong>：勝利チームの得点。</li>
                <li><strong>LTeamID</strong>：敗戦チーム。</li>
                <li><strong>LScore</strong>：敗戦チームの得点。</li>
                <li><strong>WLoc</strong>：勝利チームの会場区分（H=ホーム、A=アウェイ、N=中立）。</li>
                <li><strong>NumOT</strong>：延長回数（0以上の整数）。</li>
            </ul>

            <h3>Data Section 1 ファイル: MNCAATourneyCompactResults.csv と WNCAATourneyCompactResults.csv</h3>
            <p>過去シーズンにおけるNCAA®トーナメント試合結果ファイル。基本的には RegularSeasonCompactResults.csv と同じ形式で、男子の場合は全試合が中立（WLoc=N）として記載。女子は大会によっては中立ではない場合もある。</p>
            <p>男子の場合、DayNum からおおよそのラウンドが推定可能（ただし2021年など特異例もある）。一般的なスケジュールは：</p>
            <ul>
                <li>DayNum=134 or 135：火曜・水曜のプレーイン → 64チームに絞る</li>
                <li>DayNum=136 or 137：木曜・金曜の1回戦 → 64→32チーム</li>
                <li>DayNum=138 or 139：土曜・日曜の2回戦 → 32→16チーム</li>
                <li>DayNum=143 or 144：木曜・金曜の3回戦（スウィート16） → 16→8チーム</li>
                <li>DayNum=145 or 146：土曜・日曜の4回戦（エリート8） → 8→4チーム</li>
                <li>DayNum=152：土曜の5回戦（ファイナル4） → 4→2チーム</li>
                <li>DayNum=154：月曜の6回戦（決勝） → 2→優勝1チーム</li>
            </ul>

            <h3>Data Section 1 ファイル: SampleSubmissionStage1.csv</h3>
            <p>ステージ1コンペの提出ファイル形式を示したサンプル。全試合の勝率を50%とする場合の例が掲載されている。</p>
            <p>必要な予測を把握するには、このサンプルファイルの行をパースすればよい。</p>
            <ul>
                <li><strong>ID</strong>：<code>SSSS_XXXX_YYYY</code> 形式の14文字列。SSSSはシーズン、XXXXはTeamIDが小さい方、YYYYは大きい方。</li>
                <li><strong>Pred</strong>：IDで指定された「小さい方のTeamIDのチームが勝つ確率」を記載。</li>
            </ul>
        </section>

        <section>
            <h2>Data Section 2 - チーム別ボックススコア</h2>
            <p>2003シーズン（男子）または2010シーズン（女子）以降のレギュラーシーズン、カンファレンストーナメント、NCAA®トーナメントの試合におけるチーム単位の詳細スタッツを記録している（フリースロー試投数、ディフェンスリバウンド数、ターンオーバー数など）。</p>
            <p>ボックススコアは「Detailed Results」ファイルに含まれ、「Compact Results」ファイルの拡張版といえる。</p>
            <p>Detailed Resultsファイルでは、最初の8列（Season, DayNum, WTeamID, WScore, LTeamID, LScore, WLoc, NumOT）はCompact Resultsと同じだが、追加のカラムが多数含まれる。カラム名の頭文字 “W” または “L” は勝利チーム・敗戦チームを示す。</p>
            <ul>
                <li>WFGM（勝チームのフィールドゴール成功数）</li>
                <li>WFGA（勝チームのフィールドゴール試投数）</li>
                <li>WFGM3（勝チームの3ポイント成功数）</li>
                <li>WFGA3（勝チームの3ポイント試投数）</li>
                <li>WFTM（勝チームのフリースロー成功数）</li>
                <li>WFTA（勝チームのフリースロー試投数）</li>
                <li>WOR（勝チームのオフェンスリバウンド数）</li>
                <li>WDR（勝チームのディフェンスリバウンド数）</li>
                <li>WAst（勝チームのアシスト数）</li>
                <li>WTO（勝チームのターンオーバー）</li>
                <li>WStl（勝チームのスティール）</li>
                <li>WBlk（勝チームのブロック）</li>
                <li>WPF（勝チームのパーソナルファウル）</li>
                <li>... 敗戦チームについてもLFGM ～ LPF の同様のカラムがある</li>
            </ul>
            <p>注：フィールドゴール成功数 (WFGM/LFGM) は、2ポイントと3ポイントの合計。3ポイントだけを知りたい場合は (WFGM - WFGM3) で2ポイントを求めるなど工夫が必要。総得点は 2×FGM + FGM3 + FTM で計算可能。</p>

            <h3>Data Section 2 ファイル: MRegularSeasonDetailedResults.csv と WRegularSeasonDetailedResults.csv</h3>
            <p>レギュラーシーズンのチーム別ボックススコア。男子は2003シーズン以降、女子は2010シーズン以降。CompactResults に含まれる試合は、これらの DetailedResults にも含まれる。</p>
            <p>女子データでは初期のシーズン（2010～2012）で約1.5%の試合データが欠損。2013年以降はほぼ完全。過去に一部シーズンでパーソナルファウルが0になっていた試合があったが、現在は修正済。</p>

            <h3>Data Section 2 ファイル: MNCAATourneyDetailedResults.csv と WNCAATourneyDetailedResults.csv</h3>
            <p>NCAA®トーナメントのチーム別ボックススコア。男子は2003シーズン以降、女子は2010シーズン以降。CompactResults と同じ試合が DetailedResults にも対応して存在する。</p>
        </section>

        <section>
            <h2>Data Section 3 - 地理情報</h2>
            <p>2010シーズン以降のレギュラーシーズン、カンファレンストーナメント、NCAA®トーナメントの試合が行われた都市情報を提供する。</p>

            <h3>Data Section 3 ファイル: Cities.csv</h3>
            <p>試合が開催された都市のマスタ一覧。Cities や Conferences は男女共通のため、M/Wで分けられていない。CityID は過去のデータとも対応。</p>
            <ul>
                <li><strong>CityID</strong>：4桁のID。都市を一意に識別。</li>
                <li><strong>City</strong>：都市名。</li>
                <li><strong>State</strong>：州の略称。米国50州以外の場合は別の略称を使用（例：メキシコ・カンクン＝MX）。</li>
            </ul>

            <h3>Data Section 3 ファイル: MGameCities.csv と WGameCities.csv</h3>
            <p>2010シーズン以降のすべての試合について、実際に行われた都市を示すファイル。レギュラーシーズン、NCAA®トーナメント、二次的なトーナメント（NIT等）が含まれる。2009シーズン以前の試合は未掲載。女子では2010～2012シーズンの約1～2%が欠損の場合あり。2013年以降は100%カバー。</p>
            <ul>
                <li><strong>Season, DayNum, WTeamID, LTeamID</strong>：これら4つで試合を一意に識別。他の情報（スコア等）はCompactResultsやDetailedResultsを参照。</li>
                <li><strong>CRType</strong>：Regular / NCAA / Secondary（セカンダリートーナメント）の別。</li>
                <li><strong>CityID</strong>：Cities.csv の CityID。</li>
            </ul>
        </section>

        <section>
            <h2>Data Section 4 - 公開ランキング</h2>
            <p>2003シーズン以降の男子チームの週次ランキング。Pomeroy, Sagarin, RPI, ESPN など多数のシステムを含む。</p>

            <h3>Data Section 4 ファイル: MMasseyOrdinals.csv</h3>
            <p>ケネス・マッセイ（Kenneth Massey）のサイトで集計された多数のランキングシステムによる男子チームの順位（#1, #2, #3 ...）を一覧化したファイル。</p>
            <ul>
                <li><strong>Season</strong>：MSeasons.csv のシーズン。</li>
                <li><strong>RankingDayNum</strong>：0～133の整数。DayZero と同じ基準で定義。RankingDayNum ＝ 110 なら DayNum 109 までの試合結果を反映し、DayNum 110 以降の試合予測に用いる、などの指針。</li>
                <li><strong>SystemName</strong>：各ランキングシステムを表す3文字程度の略称。年によって多少変化あり。</li>
                <li><strong>TeamID</strong>：MTeams.csv のTeamID。</li>
                <li><strong>OrdinalRank</strong>：そのシステムにおける順位（#1～#351 など）。年によってはチーム数が増えて最大ランクも変化する。</li>
            </ul>
            <p>注：これらのランキングを予測に利用する場合、リリース時期などによっては最新データが間に合わない場合もある点に注意。</p>
        </section>

        <section>
            <h2>Data Section 5 - 補足情報</h2>
            <p>コーチ情報、カンファレンス所属、チーム名の別表記、ブラケット構造、NITなどの二次トーナメント試合結果などを含む。</p>

            <h3>Data Section 5 ファイル: MTeamCoaches.csv</h3>
            <p>シーズンごとのヘッドコーチ情報。シーズン途中の交代がある場合は DayNum の範囲で管理。長期在任コーチは複数行にわたって記載されることもある。</p>
            <ul>
                <li><strong>Season</strong>：MSeasons.csv のシーズン。</li>
                <li><strong>TeamID</strong>：対象チームのID。</li>
                <li><strong>FirstDayNum, LastDayNum</strong>：そのコーチがヘッドコーチを務めた期間を表す DayNum の範囲。</li>
                <li><strong>CoachName</strong>：ヘッドコーチ名を <code>first_last</code> のようにアンダースコアで区切った小文字表記。</li>
            </ul>

            <h3>Data Section 5 ファイル: Conferences.csv</h3>
            <p>1985年以降に存在したディビジョンIカンファレンスの一覧。略称と正式名称のみ記載。合併や名称変更などの履歴は追跡していない。</p>
            <ul>
                <li><strong>ConfAbbrev</strong>：カンファレンスの略称。他のファイルで参照。</li>
                <li><strong>Description</strong>：カンファレンスの正式名称。</li>
            </ul>

            <h3>Data Section 5 ファイル: MTeamConferences.csv と WTeamConferences.csv</h3>
            <p>シーズンごとのチームとカンファレンスの対応表。年ごとに所属が変更されるケースも反映されている。</p>
            <ul>
                <li><strong>Season</strong>：対応する MSeasons.csv / WSeasons.csv のシーズン。</li>
                <li><strong>TeamID</strong>：チームのID。</li>
                <li><strong>ConfAbbrev</strong>：上記 Conferences.csv で定義された略称。</li>
            </ul>

            <h3>Data Section 5 ファイル: MConferenceTourneyGames.csv と WConferenceTourneyGames.csv</h3>
            <p>各年のカンファレンストーナメント（セレクションサンデー以前に終了）の試合情報。男子は2001シーズン、女子は2002シーズンから。</p>
            <ul>
                <li><strong>ConfAbbrev</strong>：どのカンファレンスのトーナメントか。</li>
                <li><strong>Season, DayNum, WTeamID, LTeamID</strong>：試合を一意に識別。他の詳細は RegularSeasonCompactResults および DetailedResults で確認。</li>
            </ul>

            <h3>Data Section 5 ファイル: MSecondaryTourneyTeams.csv と WSecondaryTourneyTeams.csv</h3>
            <p>NCAA®トーナメント以外の男子・女子のポストシーズントーナメント（NITなど）に参加したチームの一覧。</p>
            <ul>
                <li><strong>Season</strong>：本ファイル上のシーズン年。</li>
                <li><strong>SecondaryTourney</strong>：トーナメント略称（NIT や WNITなど）。</li>
                <li><strong>TeamID</strong>：該当チームのID。</li>
            </ul>

            <h3>Data Section 5 ファイル: MSecondaryTourneyCompactResults.csv と WSecondaryTourneyCompactResults.csv</h3>
            <p>二次ポストシーズントーナメント（NIT, CBI, CIT, V16, TBC など）の試合結果。基本的には他の Compact Results と同様だが、SecondaryTourney カラムが付加されている。DayNum=132以降の試合なので RegularSeasonCompactResults には含まれない。</p>
            <ul>
                <li><strong>SecondaryTourney</strong>：NIT / CBI / CIT / V16（Vegas16）/ TBC（The Basketball Classic）など。</li>
            </ul>

            <h3>Data Section 5 ファイル: MTeamSpellings.csv と WTeamSpellings.csv</h3>
            <p>チーム名の別表記を示す。外部データのチーム名を本コンペの TeamID にひも付ける用途に使う。</p>
            <ul>
                <li><strong>TeamNameSpelling</strong>：すべて小文字で表記されたチーム名表記。</li>
                <li><strong>TeamID</strong>：対応する MTeams.csv / WTeams.csv の TeamID。</li>
            </ul>

            <h3>Data Section 5 ファイル: MNCAATourneySlots と WNCAATourneySlots</h3>
            <p>NCAA®トーナメントで、各シードがどのように対戦相手と組まれていくかを示すファイル。トーナメントの各ラウンドごとに<strong>Slot</strong>を使って表現。</p>
            <ul>
                <li><strong>Season</strong>：MSeasons.csv / WSeasons.csv のシーズン。</li>
                <li><strong>Slot</strong>：トーナメントゲームを一意に示すID。プレーイン用は3文字（例：W16, Z13）、通常ラウンドは4文字（例：R1W1など）。</li>
                <li><strong>StrongSeed</strong>：本来シードが上位のチームが入る枠。Round 1 なら W01 などのチームシード、Round2 以降は別の Slot が指定される。</li>
                <li><strong>WeakSeed</strong>：シード下位のチームが入る枠。</li>
            </ul>

            <h3>Data Section 5 ファイル: MNCAATourneySeedRoundSlots.csv</h3>
            <p>男子のトーナメント構造を一元的に表したファイル。プレーインシードの位置に関わらず、各シードがどのラウンドでどの Slot を使い、どの DayNum（早い/遅い）に試合をする可能性があるかを示す。女子はスケジュールが大きく異なる年が多いため対応ファイルはない。2021年の男子は特例的なスケジュールだった。</p>
            <ul>
                <li><strong>Seed</strong>：チームのトーナメントシード。</li>
                <li><strong>GameRound</strong>：0（プレーイン）～6までのラウンド番号。0=プレーイン、1/2=1週目、3/4=2週目、5/6=準決勝/決勝。</li>
                <li><strong>GameSlot</strong>：そのラウンドでの試合 Slot。</li>
                <li><strong>EarlyDayNum, LateDayNum</strong>：そのラウンドが行われうる最も早い日、最も遅い日の DayNum。ラウンドによって2日間設定されることがある。</li>
            </ul>
        </section>
<section>
    <h2>Simple starter notebook for March Mania 2025</h2>
    <p><a href="https://www.kaggle.com/code/paultimothymooney/simple-starter-notebook-for-march-mania-2025">Simple starter notebook for March Mania 2025</a></p>
    <h3>大会の目的</h3>
    <p>この大会の目的は、より小さい TeamID があるマッチアップに勝利する確率を予測することである。過去4年間におけるあらゆる可能なチーム同士の全試合について、その確率を予測する。提出用のサンプルファイルでは、ID にはマッチアップの年と両方のチームIDが含まれている。例えば「2025_1101_1104」という ID は、2025年トーナメントにおける TeamID 1101 と TeamID 1104 の対戦を示す。「Pred」に 0.75 と提出すると、TeamID 1101 がこの対戦に勝つ確率が 0.75 だと考えていることを意味する。</p>

    <h3>提出戦略の概要</h3>
    <p>このスターターノートブックでは、簡単な提出を行う。</p>
    <p>試合の勝者を予測するにあたり、対戦する両チームのランキングのみを考慮する。最大の差は 15 (1位と16位の差) なので、簡易的な式として「0.5 + 0.03 × (シードの差)」を用い、予測確率を 5% から 95% の範囲で算出する。より高いシード（つまり数字が小さいチーム、1～16）を持つチームが勝ちやすいとみなし、50%以上の確率を割り当てる形である。</p>

    <h3>スターターコード</h3>
    <h4>ステップ1: Python パッケージのインポート</h4>
    <pre><code>import numpy as np
import pandas as pd
from sklearn.metrics import brier_score_loss, mean_squared_error
</code></pre>

    <h4>ステップ2: データの確認</h4>
    <pre><code>w_seed = pd.read_csv('/kaggle/input/march-machine-learning-mania-2025/WNCAATourneySeeds.csv')
m_seed = pd.read_csv('/kaggle/input/march-machine-learning-mania-2025/MNCAATourneySeeds.csv')
seed_df = pd.concat([m_seed, w_seed], axis=0).fillna(0.05)
submission_df = pd.read_csv('/kaggle/input/march-machine-learning-mania-2025/SampleSubmissionStage2.csv')
</code></pre>
    <p>チームのランキングは <strong>WNCAATourneySeeds.csv</strong> と <strong>MNCAATourneySeeds.csv</strong> に含まれている。</p>
    <ul>
        <li><strong>Season</strong>: 年度を示すカラム</li>
        <li><strong>Seed</strong>: カンファレンスにおけるランク (W01 はカンファレンスWで1位)</li>
        <li><strong>TeamID</strong>: 各チームに付与された固有の識別子</li>
    </ul>
    <p><strong>seed_df.head()</strong></p>
    <pre>
Season  Seed  TeamID
0   1985    W01   1207
1   1985    W02   1210
2   1985    W03   1228
3   1985    W04   1260
4   1985    W05   1374
    </pre>

    <p><strong>sample_submission.csv</strong> には、<em>year_teamID1_teamID2</em> というフォーマットの "ID" カラムが含まれている。</p>

    <p><strong>submission_df.head()</strong></p>
    <pre>
                ID      Pred
0   2025_1101_1102    0.5
1   2025_1101_1103    0.5
2   2025_1101_1104    0.5
3   2025_1101_1105    0.5
4   2025_1101_1106    0.5
    </pre>

    <h4>ステップ3: 試合情報とチームのランクを抽出</h4>
    <pre><code>def extract_game_info(id_str):
    # 年とチームIDを抽出
    parts = id_str.split('_')
    year = int(parts[0])
    teamID1 = int(parts[1])
    teamID2 = int(parts[2])
    return year, teamID1, teamID2

def extract_seed_value(seed_str):
    # シード値を抽出
    try:
        return int(seed_str[1:])
    # 選抜されなかったチームやエラーの場合は16を割り当て
    except ValueError:
        return 16

# データの再整形
submission_df[['Season', 'TeamID1', 'TeamID2']] = submission_df['ID'].apply(extract_game_info).tolist()
seed_df['SeedValue'] = seed_df['Seed'].apply(extract_seed_value)

# TeamID1 のシード情報をマージ
submission_df = pd.merge(submission_df, seed_df[['Season', 'TeamID', 'SeedValue']],
                         left_on=['Season', 'TeamID1'], right_on=['Season', 'TeamID'],
                         how='left')
submission_df = submission_df.rename(columns={'SeedValue': 'SeedValue1'}).drop(columns=['TeamID'])

# TeamID2 のシード情報をマージ
submission_df = pd.merge(submission_df, seed_df[['Season', 'TeamID', 'SeedValue']],
                         left_on=['Season', 'TeamID2'], right_on=['Season', 'TeamID'],
                         how='left')
submission_df = submission_df.rename(columns={'SeedValue': 'SeedValue2'}).drop(columns=['TeamID'])
</code></pre>

    <h4>ステップ4: 予測の作成</h4>
    <pre><code># シード差を計算
submission_df['SeedDiff'] = submission_df['SeedValue1'] - submission_df['SeedValue2']

# 'Pred' カラムの更新
submission_df['Pred'] = 0.5 + (0.03 * submission_df['SeedDiff'])

# 不要なカラムを削除
submission_df = submission_df[['ID', 'Pred']].fillna(0.5)

# 提出データのプレビュー
submission_df.head()
</code></pre>

    <pre>
                ID      Pred
0   2025_1101_1102    0.5
1   2025_1101_1103    0.5
2   2025_1101_1104    0.5
3   2025_1101_1105    0.5
4   2025_1101_1106    0.5
    </pre>

    <pre>
count    131407.0
mean          0.5
std           0.0
min           0.5
25%           0.5
50%           0.5
75%           0.5
max           0.5
Name: Pred, dtype: float64
    </pre>

    <h4>ステップ5: 評価指標を理解する</h4>
    <p>実際の試合結果は分からないため、便宜上、<strong>ID</strong> に先に記載されたチーム(TeamID1) がすべて勝利したと仮定する。これを「真の値 (true value)」と呼ぶ。次に、提出した確率とこの真の値の平均二乗誤差を計算する。これを Brier Score と呼ぶ。詳しくは <a href="https://en.wikipedia.org/wiki/Brier_score">https://en.wikipedia.org/wiki/Brier_score</a> を参照せよ。</p>

    <pre><code># 真の値を格納したデータフレームを作成
solution_df = submission_df.copy()
solution_df['Pred'] = 1

# Brier Score を計算
y_true = solution_df['Pred']
y_pred = submission_df['Pred']
brier_score = brier_score_loss(y_true, y_pred)
print(f"Brier Score: {brier_score}")
</code></pre>

    <pre>
Brier Score: 0.25
    </pre>

    <h4>ステップ6: 提出を作成</h4>
    <pre><code>submission_df.to_csv('/kaggle/working/submission.csv', index=False)
</code></pre>
</section>
<section>
    <h2>March ML Mania 2025 - Brier Score Prediction</h2>
    <p><a href="https://www.kaggle.com/code/jocelyndumlao/march-ml-mania-2025-brier-score-prediction">March ML Mania 2025 - Brier Score Prediction</a></p>
    <h3>目的:</h3>
    <p>このコンペティションの評価指標である Brier スコアを最小化すること。</p>

    <h3>アプローチ:</h3>
    <ul>
        <li>まずはシードの差を利用した単純なモデルから始める。</li>
        <li>徐々に高度な特徴量や手法を組み込んでいく。</li>
    </ul>

    <h3>Brier スコア</h3>
    <p>Brier スコアは、確率的予測の精度を測定するための厳密に適切 (strictly proper) なスコアリングルールである。単一次元の予測においては、予測確率に適用される平均二乗誤差（MSE）と本質的に同値である。</p>
    <p>Brier スコアは、互いに排他的な離散的な結果またはクラスに対して予測が確率を割り当てなければならないタスクに適用可能である。可能な結果の集合は二値または多クラスのいずれかであり、これらの確率は 0～1 の範囲にある必要があり、かつすべての合計が 1 となるように割り当てられる必要がある。これは 1950 年に Glenn W. Brier によって提案された。</p>
    <p>Brier スコアはコスト関数と考えることができる。より正確には、<code>i ∈ 1...N</code> 個の予測セットに対して、Brier スコアは以下の差の二乗平均を測定する:</p>
    <ul>
        <li>アイテム <code>i</code> に割り当てられた可能な結果への予測確率</li>
        <li>アイテム <code>i</code> の実際の結果 <code>o<sub>i</sub></code></li>
    </ul>
    <p>したがって、Brier スコアが低いほど、予測が適切にキャリブレーションされていることを意味します。一般的な形式では、このスコアは 0 から 1 の間の値をとります。これは、予測確率（0～1 のみ）と実際の結果（0 か 1 のみ）との最大差を平方した値が 1 になるためです。オリジナルの(1950 年) Brier スコアの定義では、この範囲が 0 から 2 の間でした。</p>
    <p>Brier スコアは、真偽 (true/false) のいずれかとなるバイナリ・カテゴリカルな結果には適切ですが、3 種類以上の値を取る順序変数 (ordinal) には不向きです。</p>
    <p>リンク: <a href="https://en.wikipedia.org/wiki/Brier_score">https://en.wikipedia.org/wiki/Brier_score</a></p>

    <h3>ライブラリのインポート</h3>
    <pre><code>import glob
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, cross_val_score, KFold
from sklearn.preprocessing import StandardScaler
from sklearn.impute import SimpleImputer
from sklearn.metrics import log_loss, brier_score_loss, mean_squared_error, roc_curve, auc
from sklearn.ensemble import RandomForestRegressor

import warnings
warnings.filterwarnings("ignore")
</code></pre>

    <h3>データの読み込み</h3>
    <pre><code>data_dir = '/kaggle/input/march-machine-learning-mania-2025/**'
class TournamentPredictor:
    def __init__(self, data_dir):
        self.data_path = data_dir
        self.data = None
        self.teams = None
        self.seeds = None
        self.games = None
        self.sub = None
        self.gb = None
        self.col = None
        self.model = None # declare model here.
        self.calibration_model = None # declare calibration model here.
        self.imputer = SimpleImputer(strategy='mean')
        self.scaler = StandardScaler()

    def load_data(self):
        files = glob.glob(self.data_path)
        self.data = {p.split('/')[-1].split('.')[0]: pd.read_csv(p, encoding='latin-1') for p in files}

        teams = pd.concat([self.data['MTeams'], self.data['WTeams']])
        teams_spelling = pd.concat([self.data['MTeamSpellings'], self.data['WTeamSpellings']])
        teams_spelling = teams_spelling.groupby(by='TeamID', as_index=False)['TeamNameSpelling'].count()
        teams_spelling.columns = ['TeamID', 'TeamNameCount']
        self.teams = pd.merge(teams, teams_spelling, how='left', on=['TeamID'])

        season_cresults = pd.concat([self.data['MRegularSeasonCompactResults'], self.data['WRegularSeasonCompactResults']])
        season_dresults = pd.concat([self.data['MRegularSeasonDetailedResults'], self.data['WRegularSeasonDetailedResults']])
        tourney_cresults = pd.concat([self.data['MNCAATourneyCompactResults'], self.data['WNCAATourneyCompactResults']])
        tourney_dresults = pd.concat([self.data['MNCAATourneyDetailedResults'], self.data['WNCAATourneyDetailedResults']])

        seeds_df = pd.concat([self.data['MNCAATourneySeeds'], self.data['WNCAATourneySeeds']])
        self.seeds = {'_'.join(map(str, [int(k1), k2])): int(v[1:3]) for k1, v, k2 in seeds_df[['Season', 'Seed', 'TeamID']].values}

        self.sub = self.data['SampleSubmissionStage1']

        season_cresults['ST'] = 'S'
        season_dresults['ST'] = 'S'
        tourney_cresults['ST'] = 'T'
        tourney_dresults['ST'] = 'T'

        self.games = pd.concat((season_dresults, tourney_dresults), axis=0, ignore_index=True)
        self.games['WLoc'] = self.games['WLoc'].map({'A': 1, 'H': 2, 'N': 3})

        self.games['ID'] = self.games.apply(lambda r: '_'.join(map(str, [r['Season']] + sorted([r['WTeamID'], r['LTeamID']]))), axis=1)
        self.games['IDTeams'] = self.games.apply(lambda r: '_'.join(map(str, sorted([r['WTeamID'], r['LTeamID']]))), axis=1)
        self.games['Team1'] = self.games.apply(lambda r: sorted([r['WTeamID'], r['LTeamID']])[0], axis=1)
        self.games['Team2'] = self.games.apply(lambda r: sorted([r['WTeamID'], r['LTeamID']])[1], axis=1)
        self.games['IDTeam1'] = self.games.apply(lambda r: '_'.join(map(str, [r['Season'], r['Team1']])), axis=1)
        self.games['IDTeam2'] = self.games.apply(lambda r: '_'.join(map(str, [r['Season'], r['Team2']])), axis=1)
        self.games['Team1Seed'] = self.games['IDTeam1'].map(self.seeds).fillna(0)
        self.games['Team2Seed'] = self.games['IDTeam2'].map(self.seeds).fillna(0)
        self.games['ScoreDiff'] = self.games['WScore'] - self.games['LScore']
        self.games['Pred'] = self.games.apply(lambda r: 1.0 if sorted([r['WTeamID'], r['LTeamID']])[0] == r['WTeamID'] else 0.0, axis=1)
        self.games['ScoreDiffNorm'] = self.games.apply(lambda r: r['ScoreDiff'] * -1 if r['Pred'] == 0.0 else r['ScoreDiff'], axis=1)
        self.games['SeedDiff'] = self.games['Team1Seed'] - self.games['Team2Seed']
        self.games = self.games.fillna(-1)

        c_score_col = ['NumOT', 'WFGM', 'WFGA', 'WFGM3', 'WFGA3', 'WFTM', 'WFTA', 'WOR', 'WDR', 'WAst', 'WTO', 'WStl', 'WBlk', 'WPF', 'LFGM', 'LFGA', 'LFGM3', 'LFGA3', 'LFTM', 'LFTA', 'LOR', 'LDR', 'LAst', 'LTO', 'LStl', 'LBlk', 'LPF']
        c_score_agg = ['sum', 'mean', 'median', 'max', 'min', 'std', 'skew', 'nunique']
        self.gb = self.games.groupby(by=['IDTeams']).agg({k: c_score_agg for k in c_score_col}).reset_index()
        self.gb.columns = [''.join(c) + '_c_score' for c in self.gb.columns]

        self.games = self.games[self.games['ST'] == 'T']

        self.sub['WLoc'] = 3
        self.sub['Season'] = self.sub['ID'].map(lambda x: x.split('_')[0]).astype(int)
        self.sub['Team1'] = self.sub['ID'].map(lambda x: x.split('_')[1])
        self.sub['Team2'] = self.sub['ID'].map(lambda x: x.split('_')[2])
        self.sub['IDTeams'] = self.sub.apply(lambda r: '_'.join(map(str, [r['Team1'], r['Team2']])), axis=1)
        self.sub['IDTeam1'] = self.sub.apply(lambda r: '_'.join(map(str, [r['Season'], r['Team1']])), axis=1)
        self.sub['IDTeam2'] = self.sub.apply(lambda r: '_'.join(map(str, [r['Season'], r['Team2']])), axis=1)
        self.sub['Team1Seed'] = self.sub['IDTeam1'].map(self.seeds).fillna(0)
        self.sub['Team2Seed'] = self.sub['IDTeam2'].map(self.seeds).fillna(0)
        self.sub['SeedDiff'] = self.sub['Team1Seed'] - self.sub['Team2Seed']
        self.sub = self.sub.fillna(-1)

        self.games = pd.merge(self.games, self.gb, how='left', left_on='IDTeams', right_on='IDTeams_c_score')
        self.sub = pd.merge(self.sub, self.gb, how='left', left_on='IDTeams', right_on='IDTeams_c_score')

        exclude_cols = ['ID', 'DayNum', 'ST', 'Team1', 'Team2', 'IDTeams', 'IDTeam1', 'IDTeam2', 'WTeamID', 'WScore', 'LTeamID', 'LScore', 'NumOT', 'Pred', 'ScoreDiff', 'ScoreDiffNorm', 'WLoc'] + c_score_col
        self.col = [c for c in self.games.columns if c not in exclude_cols]
        print("Data loading and preprocessing completed.")

    def create_models(self):
      # Create the models here with the same parameters.
      self.model = RandomForestRegressor(
          n_estimators=235,
          random_state=42,
          max_depth=15,
          min_samples_split=2,
          max_features='sqrt',
          n_jobs=-1
      )
      self.calibration_model = RandomForestRegressor(n_estimators=100, random_state=42, n_jobs=-1, max_depth=10)



    def train_model(self):
        X = self.games[self.col].fillna(-1)
        X_imputed = self.imputer.fit_transform(X)
        X_scaled = self.scaler.fit_transform(X_imputed)
        y = self.games['Pred']

        X_train, X_cal, y_train, y_cal = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

        self.model.fit(X_train, y_train)
        train_preds = self.model.predict(X_train).clip(0.001, 0.999)

        cal_preds = self.model.predict(X_cal).clip(0.001, 0.999)
        self.calibration_model.fit(cal_preds.reshape(-1, 1), y_cal)

        train_preds_calibrated = self.calibration_model.predict(train_preds.reshape(-1, 1)).clip(0.001, 0.999)

        print(f'Log Loss (Train): {log_loss(y_train, train_preds_calibrated):.4f}')
        print(f'Brier Score (Train): {brier_score_loss(y_train, train_preds_calibrated):.4f}')
        print(f'MSE (Train): {mean_squared_error(y_train, train_preds_calibrated):.4f}')

        # Plot ROC Curve for the calibration set.
        self.plot_roc_curve(y_cal, cal_preds, "Calibration Set ROC Curve")

        kf = KFold(n_splits=5, shuffle=True, random_state=42)
        cv_mse_scores = []
        cv_logloss_scores = []
        for train_index, val_index in kf.split(X_scaled):
            X_train, X_val = X_scaled[train_index], X_scaled[val_index]
            y_train, y_val = y[train_index], y[val_index]

            self.model.fit(X_train, y_train)
            val_preds = self.model.predict(X_val).clip(0.001, 0.999)

            self.calibration_model.fit(val_preds.reshape(-1, 1), y_val)
            val_preds_calibrated = self.calibration_model.predict(val_preds.reshape(-1, 1)).clip(0.001, 0.999)

            mse = mean_squared_error(y_val, val_preds_calibrated)
            logloss = log_loss(y_val, val_preds_calibrated)

            cv_mse_scores.append(mse)
            cv_logloss_scores.append(logloss)

        print(f'Cross-validated MSE: {np.mean(cv_mse_scores):.4f}')
        print(f'Cross-validated LogLoss: {np.mean(cv_logloss_scores):.4f}')

        feature_importances = self.model.feature_importances_
        feature_names = self.col
        self.plot_feature_importance(feature_importances, feature_names)

        self.plot_calibration_curve(y_cal, cal_preds)

        # Plot the distribution of calibrated predictions.
        self.plot_prediction_distribution(train_preds_calibrated, "Distribution of Calibrated Training Predictions")

    def predict_submission(self, output_file='submission.csv'):
        sub_X = self.sub[self.col].fillna(-1)
        sub_X_imputed = self.imputer.transform(sub_X)
        sub_X_scaled = self.scaler.transform(sub_X_imputed)

        preds = self.model.predict(sub_X_scaled).clip(0.001, 0.999)
        preds_calibrated = self.calibration_model.predict(preds.reshape(-1, 1)).clip(0.001, 0.999)

        self.sub['Pred'] = preds_calibrated
        self.sub[['ID', 'Pred']].to_csv(output_file, index=False)
        print(f"Submission file saved to {output_file}")

    def plot_feature_importance(self, importances, feature_names, top_n=20):
        feature_importance_df = pd.DataFrame({'feature': feature_names, 'importance': importances})
        feature_importance_df = feature_importance_df.sort_values('importance', ascending=False).head(top_n)

        plt.figure(figsize=(10, 6))
        sns.barplot(x='importance', y='feature', data=feature_importance_df, palette='viridis')
        plt.title('Top {} Feature Importances'.format(top_n))
        plt.xlabel('Importance')
        plt.ylabel('Feature')
        plt.tight_layout()
        plt.show()

    def plot_calibration_curve(self, y_true, y_proba, n_bins=10):

        combined = np.stack([y_proba, y_true], axis=-1)
        combined = combined[np.argsort(combined[:, 0])]
        sorted_probas = combined[:, 0]
        sorted_true = combined[:, 1]

        bins = np.linspace(0, 1, n_bins + 1)
        bin_midpoints = bins[:-1] + (bins[1] - bins[0]) / 2
        bin_assignments = np.digitize(sorted_probas, bins) - 1

        bin_sums = np.bincount(bin_assignments, weights=sorted_probas, minlength=n_bins)
        bin_true = np.bincount(bin_assignments, weights=sorted_true, minlength=n_bins)
        bin_total = np.bincount(bin_assignments, minlength=n_bins)

        fraction_of_positives = bin_true / bin_total
        fraction_of_positives[np.isnan(fraction_of_positives)] = 0

        plt.figure(figsize=(8, 6))
        plt.plot(bin_midpoints, fraction_of_positives, marker='o', label='Calibration Curve')
        plt.plot([0, 1], [0, 1], linestyle='--', color='gray', label='Perfectly Calibrated')

        plt.xlabel('Predicted Probability')
        plt.ylabel('Fraction of Positives')
        plt.title('Calibration Curve')
        plt.xlim(0, 1)
        plt.ylim(0, 1)
        plt.legend()
        plt.tight_layout()
        plt.show()

    def plot_prediction_distribution(self, predictions, title="Distribution of Predictions"):
        """Plots the distribution of model predictions."""
        plt.figure(figsize=(8, 6))
        sns.histplot(predictions, kde=True, color='skyblue')
        plt.title(title)
        plt.xlabel('Predicted Probability')
        plt.ylabel('Frequency')
        plt.tight_layout()
        plt.show()

    def plot_roc_curve(self, y_true, y_proba, title="ROC Curve"):
      """Plots the Receiver Operating Characteristic (ROC) curve."""
      fpr, tpr, thresholds = roc_curve(y_true, y_proba)
      roc_auc = auc(fpr, tpr)

      plt.figure(figsize=(8, 6))
      plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = {:.2f})'.format(roc_auc))
      plt.plot([0, 1], [0, 1], color='gray', linestyle='--')
      plt.xlabel('False Positive Rate')
      plt.ylabel('True Positive Rate')
      plt.title(title)
      plt.xlim([0.0, 1.0])
      plt.ylim([0.0, 1.05])
      plt.legend(loc="lower right")
      plt.tight_layout()
      plt.show()


    def run_all(self):
        self.load_data()
        self.create_models()
        self.train_model()
        self.predict_submission()

# Example usage:
if __name__ == "__main__":
    data_dir = '/kaggle/input/march-machine-learning-mania-2025/**'  # Or a local dir
    predictor = TournamentPredictor(data_dir)
    predictor.run_all()
</code></pre>

    <pre>
Data loading and preprocessing completed.
Log Loss (Train): 0.2075
Brier Score (Train): 0.0664
MSE (Train): 0.0664

Cross-validated MSE: 0.0802
Cross-validated LogLoss: 0.2823



Submission file saved to submission.csv
    </pre>
</section>


    </main>
</body>
</html>
