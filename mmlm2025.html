<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【March Machine Learning Mania 2025 | Kaggle】走る作曲家のAIカフェ</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1050827580219099"
     crossorigin="anonymous"></script>
</head>
<body>
    <header>
        <h1>走る作曲家のAIカフェ</h1>
        <nav>
            <ul>
                <li><a href="index.html">ホーム</a></li>
                <li><a href="study.html">勉強</a></li>
                <li><a href="music.html">音楽</a></li>
                <li><a href="sports.html">スポーツ</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section>
            <h2>March Machine Learning Mania 2025</h2>
            <p><a href="https://www.kaggle.com/competitions/march-machine-learning-mania-2025">March Machine Learning Mania 2025</a></p>
        </section>
        <section>
          <h2>Overview</h2>
          <p>2025年の大学バスケットボールの男子・女子両方のトーナメントの結果を予測し、考え得るすべての試合の予測を提出する。</p>
        </section>
        <section>
          <h2>Description</h2>
          <p>このコンペティションでは、過去のNCAAの試合データが提供され、NCAA男子および女子のディビジョン1バスケットボールトーナメントの結果を予測する。</p>
          <p>トーナメント開始前のリーダーボードは2021～2024年のスコアのみを反映する。2025年の試合が始まり次第、Kaggle は結果を随時反映し、スコアを更新していく。</p>
        </section>
        <section>
          <h2>Evaluation</h2>
          <p>提出物は、予測した確率と実際の試合結果との間の<a href="https://qiita.com/Derek/items/e382c087afd616a0053e">Brier Score</a>に基づいて評価される（このコンテキストでは平均二乗誤差（Mean Squared Error）と同等）。</p>
          <p>各試合にはユニークなIDが付与されており、以下の形式で作成される：</p>
          <pre><code>
[シーズン]_[チームID1]_[チームID2]
          </code></pre>
          <p>たとえば「2025_1101_1102」であれば、2025年におけるチーム1101と1102の対戦を表す。</p>
          <p>提出時は、チームIDが小さい方を先に記述し、そのチームが勝つ確率（0〜1）を予測する。</p>
          <p>男子チームと女子チームの TeamID は重複しないので、1つのファイルで男女混合の予測を提出できる。</p>
          <p>提出ファイルの例：</p>
          <pre><code>
ID,Pred
2025_1101_1102,0.5
2025_1101_1103,0.5
2025_1101_1104,0.5
...
          </code></pre>
          <p><code>Pred</code>には、TeamID が小さい方のチームが勝つ確率（0〜1）を記載する。</p>
          <p>2025年のトーナメントが始まるまでは、提出ファイルのフォーマットが正しいか確認する目的でスコアが0.0で表示される。試合結果が反映され次第リーダーボードが再計算される。</p>
        </section>
        <section>
            <h2>Dataset Description</h2>
            <p>毎シーズン、NCAA®ディビジョンIの大学バスケットボールチーム同士による数千試合が行われ、3月中旬から4月上旬にかけて開催される March Madness®（全米選手権） 男子・女子トーナメントにつながる。本コンペでは、過去の膨大な試合データを提供し、それを用いて March Madness® の試合結果を独自に予測できる。</p>
            <p>データファイルには男子（Men’s）と女子（Women’s）の両方が含まれる。</p>
            <ul>
                <li>男子データのみ含むファイル：ファイル名が <code>M</code> で始まる（例：<code>MRegularSeasonCompactResults.csv</code>）</li>
                <li>女子データのみ含むファイル：ファイル名が <code>W</code> で始まる（例：<code>WRegularSeasonCompactResults.csv</code>）</li>
                <li>男女共通のファイル：<code>Cities.csv</code> や <code>Conferences.csv</code> など</li>
            </ul>
            <p>外部のデータとコンペのデータをマッチングするために、以下のファイルが提供されている：</p>
            <ul>
                <li><code>MTeamSpellings.csv</code>（男子用）</li>
                <li><code>WTeamSpellings.csv</code>（女子用）</li>
            </ul>
            <p>これらを利用し、外部で参照されるチーム名を本コンペの TeamID に対応づけられる。</p>
            <p>すべてのファイルは今シーズン（2024-25）の1月28日までのデータを含む。3月中旬頃に残りの試合を反映した更新ファイルが提供される見込み。</p>
        </section>
        <section>
            <h2>Data Section 1 - 基本データ</h2>
            <p>ここでは、シンプルな予測モデルを構築し、予測を提出するために必要なすべての情報を提供している。</p>
            <p>チームIDとチーム名<br>
            1984-85シーズン以降のトーナメントシード<br>
            1984-85シーズン以降の全レギュラーシーズン、カンファレンストーナメント、NCAA®トーナメントの最終スコア<br>
            シーズンに関する詳細（試合日やリージョン情報など）<br>
            ステージ1の提出例ファイル</p>
            <p>慣例として、特定のシーズンを識別する際は開始年ではなく終了年で表現する。</p>

            <h3>Data Section 1 ファイル: MTeams.csv と WTeams.csv</h3>
            <p>これらのファイルには、データセットに含まれる各大学チームに関する情報が含まれている。</p>
            <ul>
                <li><strong>TeamID</strong>：4桁のID。NCAA®男子または女子チームを一意に識別する。男子チームは1000〜1999、女子チームは3000〜3999の範囲。</li>
                <li><strong>TeamName</strong>：16文字以内でコンパクトに表記されたチーム名。</li>
                <li><strong>FirstD1Season</strong>：このデータセットで、そのチームが初めてディビジョンIとして登録されているシーズン（男子のみのカラム）。</li>
                <li><strong>LastD1Season</strong>：同データセットで、そのチームが最後にディビジョンIとして登録されているシーズン（男子のみのカラム）。現在もディビジョンIに属するチームは 2025 が記載される。</li>
            </ul>

            <h3>Data Section 1 ファイル: MSeasons.csv と WSeasons.csv</h3>
            <p>過去のシーズン情報、およびシーズン単位での追加情報（例：DayZero, 地域名）を含むファイル。</p>
            <ul>
                <li><strong>Season</strong>：その年のトーナメントが行われた年。</li>
                <li><strong>DayZero</strong>：各シーズンの DayNum=0 に対応する日付。すべての試合日付を同一の枠組みに合わせており、男子トーナメントの決勝戦は毎年 DayNum=154（月曜日）と定義される。<br>
                （例：あるシーズンの DayZero が 10/31 なら、DayNum=7 は 11/07 にあたる、など）</li>
                <li><strong>RegionW, RegionX, RegionY, RegionZ</strong>：最終トーナメントにおける4つの地域（リージョン）に、W, X, Y, Z のラベルを付与する。アルファベット順で最も早い地域がW、そのWと対戦する地域がX、残り2地域のうちアルファベット順で早いほうがY、遅いほうがZ として割り当てる。</li>
            </ul>

            <h3>Data Section 1 ファイル: MNCAATourneySeeds.csv と WNCAATourneySeeds.csv</h3>
            <p>各NCAA®トーナメントでのシード情報を示すファイル。各シーズン64～68チーム分のシード（プレーインがある場合など）を掲載。近年は計68チーム（4試合のプレーインを含む）が定着している。実際のトーナメントシードや参加チームが確定するのは2025年のセレクションサンデー（3/16, DayNum=132）以降。</p>
            <ul>
                <li><strong>Season</strong>：そのトーナメントが行われた年。</li>
                <li><strong>Seed</strong>：3～4文字で構成されるシード。最初の文字 W/X/Y/Z は地域を表し、次の2桁がシード番号（01〜16）。プレーインの場合は最後に a, b が付与され、同じ3文字のシードを持つチーム同士が対戦する。a, b は TeamID の小さい順で割り当て。</li>
                <li><strong>TeamID</strong>：MTeams.csv や WTeams.csv で定義されるチームID。</li>
            </ul>

            <h3>Data Section 1 ファイル: MRegularSeasonCompactResults.csv と WRegularSeasonCompactResults.csv</h3>
            <p>過去シーズンにおけるレギュラーシーズン（DayNum 0〜132）の試合結果をまとめたファイル。男子は1985シーズン（64チーム制の初年）から、女子は1998シーズンから。</p>
            <ul>
                <li><strong>Season</strong>：MSeasons.csv/WSeasons.csv の年（最終的なトーナメントが行われる年）。</li>
                <li><strong>DayNum</strong>：0〜132の範囲。DayZero からのオフセット。</li>
                <li><strong>WTeamID</strong>：試合に勝利したチーム（Home/Away/Neutral問わず）。</li>
                <li><strong>WScore</strong>：勝利チームの得点。</li>
                <li><strong>LTeamID</strong>：敗戦チーム。</li>
                <li><strong>LScore</strong>：敗戦チームの得点。</li>
                <li><strong>WLoc</strong>：勝利チームの会場区分（H=ホーム、A=アウェイ、N=中立）。</li>
                <li><strong>NumOT</strong>：延長回数（0以上の整数）。</li>
            </ul>

            <h3>Data Section 1 ファイル: MNCAATourneyCompactResults.csv と WNCAATourneyCompactResults.csv</h3>
            <p>過去シーズンにおけるNCAA®トーナメント試合結果ファイル。基本的には RegularSeasonCompactResults.csv と同じ形式で、男子の場合は全試合が中立（WLoc=N）として記載。女子は大会によっては中立ではない場合もある。</p>
            <p>男子の場合、DayNum からおおよそのラウンドが推定可能（ただし2021年など特異例もある）。一般的なスケジュールは：</p>
            <ul>
                <li>DayNum=134 or 135：火曜・水曜のプレーイン → 64チームに絞る</li>
                <li>DayNum=136 or 137：木曜・金曜の1回戦 → 64→32チーム</li>
                <li>DayNum=138 or 139：土曜・日曜の2回戦 → 32→16チーム</li>
                <li>DayNum=143 or 144：木曜・金曜の3回戦（スウィート16） → 16→8チーム</li>
                <li>DayNum=145 or 146：土曜・日曜の4回戦（エリート8） → 8→4チーム</li>
                <li>DayNum=152：土曜の5回戦（ファイナル4） → 4→2チーム</li>
                <li>DayNum=154：月曜の6回戦（決勝） → 2→優勝1チーム</li>
            </ul>

            <h3>Data Section 1 ファイル: SampleSubmissionStage1.csv</h3>
            <p>ステージ1コンペの提出ファイル形式を示したサンプル。全試合の勝率を50%とする場合の例が掲載されている。</p>
            <p>必要な予測を把握するには、このサンプルファイルの行をパースすればよい。</p>
            <ul>
                <li><strong>ID</strong>：<code>SSSS_XXXX_YYYY</code> 形式の14文字列。SSSSはシーズン、XXXXはTeamIDが小さい方、YYYYは大きい方。</li>
                <li><strong>Pred</strong>：IDで指定された「小さい方のTeamIDのチームが勝つ確率」を記載。</li>
            </ul>
        </section>

        <section>
            <h2>Data Section 2 - チーム別ボックススコア</h2>
            <p>2003シーズン（男子）または2010シーズン（女子）以降のレギュラーシーズン、カンファレンストーナメント、NCAA®トーナメントの試合におけるチーム単位の詳細スタッツを記録している（フリースロー試投数、ディフェンスリバウンド数、ターンオーバー数など）。</p>
            <p>ボックススコアは「Detailed Results」ファイルに含まれ、「Compact Results」ファイルの拡張版といえる。</p>
            <p>Detailed Resultsファイルでは、最初の8列（Season, DayNum, WTeamID, WScore, LTeamID, LScore, WLoc, NumOT）はCompact Resultsと同じだが、追加のカラムが多数含まれる。カラム名の頭文字 “W” または “L” は勝利チーム・敗戦チームを示す。</p>
            <ul>
                <li>WFGM（勝チームのフィールドゴール成功数）</li>
                <li>WFGA（勝チームのフィールドゴール試投数）</li>
                <li>WFGM3（勝チームの3ポイント成功数）</li>
                <li>WFGA3（勝チームの3ポイント試投数）</li>
                <li>WFTM（勝チームのフリースロー成功数）</li>
                <li>WFTA（勝チームのフリースロー試投数）</li>
                <li>WOR（勝チームのオフェンスリバウンド数）</li>
                <li>WDR（勝チームのディフェンスリバウンド数）</li>
                <li>WAst（勝チームのアシスト数）</li>
                <li>WTO（勝チームのターンオーバー）</li>
                <li>WStl（勝チームのスティール）</li>
                <li>WBlk（勝チームのブロック）</li>
                <li>WPF（勝チームのパーソナルファウル）</li>
                <li>... 敗戦チームについてもLFGM ～ LPF の同様のカラムがある</li>
            </ul>
            <p>注：フィールドゴール成功数 (WFGM/LFGM) は、2ポイントと3ポイントの合計。3ポイントだけを知りたい場合は (WFGM - WFGM3) で2ポイントを求めるなど工夫が必要。総得点は 2×FGM + FGM3 + FTM で計算可能。</p>

            <h3>Data Section 2 ファイル: MRegularSeasonDetailedResults.csv と WRegularSeasonDetailedResults.csv</h3>
            <p>レギュラーシーズンのチーム別ボックススコア。男子は2003シーズン以降、女子は2010シーズン以降。CompactResults に含まれる試合は、これらの DetailedResults にも含まれる。</p>
            <p>女子データでは初期のシーズン（2010～2012）で約1.5%の試合データが欠損。2013年以降はほぼ完全。過去に一部シーズンでパーソナルファウルが0になっていた試合があったが、現在は修正済。</p>

            <h3>Data Section 2 ファイル: MNCAATourneyDetailedResults.csv と WNCAATourneyDetailedResults.csv</h3>
            <p>NCAA®トーナメントのチーム別ボックススコア。男子は2003シーズン以降、女子は2010シーズン以降。CompactResults と同じ試合が DetailedResults にも対応して存在する。</p>
        </section>

        <section>
            <h2>Data Section 3 - 地理情報</h2>
            <p>2010シーズン以降のレギュラーシーズン、カンファレンストーナメント、NCAA®トーナメントの試合が行われた都市情報を提供する。</p>

            <h3>Data Section 3 ファイル: Cities.csv</h3>
            <p>試合が開催された都市のマスタ一覧。Cities や Conferences は男女共通のため、M/Wで分けられていない。CityID は過去のデータとも対応。</p>
            <ul>
                <li><strong>CityID</strong>：4桁のID。都市を一意に識別。</li>
                <li><strong>City</strong>：都市名。</li>
                <li><strong>State</strong>：州の略称。米国50州以外の場合は別の略称を使用（例：メキシコ・カンクン＝MX）。</li>
            </ul>

            <h3>Data Section 3 ファイル: MGameCities.csv と WGameCities.csv</h3>
            <p>2010シーズン以降のすべての試合について、実際に行われた都市を示すファイル。レギュラーシーズン、NCAA®トーナメント、二次的なトーナメント（NIT等）が含まれる。2009シーズン以前の試合は未掲載。女子では2010～2012シーズンの約1～2%が欠損の場合あり。2013年以降は100%カバー。</p>
            <ul>
                <li><strong>Season, DayNum, WTeamID, LTeamID</strong>：これら4つで試合を一意に識別。他の情報（スコア等）はCompactResultsやDetailedResultsを参照。</li>
                <li><strong>CRType</strong>：Regular / NCAA / Secondary（セカンダリートーナメント）の別。</li>
                <li><strong>CityID</strong>：Cities.csv の CityID。</li>
            </ul>
        </section>

        <section>
            <h2>Data Section 4 - 公開ランキング</h2>
            <p>2003シーズン以降の男子チームの週次ランキング。Pomeroy, Sagarin, RPI, ESPN など多数のシステムを含む。</p>

            <h3>Data Section 4 ファイル: MMasseyOrdinals.csv</h3>
            <p>ケネス・マッセイ（Kenneth Massey）のサイトで集計された多数のランキングシステムによる男子チームの順位（#1, #2, #3 ...）を一覧化したファイル。</p>
            <ul>
                <li><strong>Season</strong>：MSeasons.csv のシーズン。</li>
                <li><strong>RankingDayNum</strong>：0～133の整数。DayZero と同じ基準で定義。RankingDayNum ＝ 110 なら DayNum 109 までの試合結果を反映し、DayNum 110 以降の試合予測に用いる、などの指針。</li>
                <li><strong>SystemName</strong>：各ランキングシステムを表す3文字程度の略称。年によって多少変化あり。</li>
                <li><strong>TeamID</strong>：MTeams.csv のTeamID。</li>
                <li><strong>OrdinalRank</strong>：そのシステムにおける順位（#1～#351 など）。年によってはチーム数が増えて最大ランクも変化する。</li>
            </ul>
            <p>注：これらのランキングを予測に利用する場合、リリース時期などによっては最新データが間に合わない場合もある点に注意。</p>
        </section>

        <section>
            <h2>Data Section 5 - 補足情報</h2>
            <p>コーチ情報、カンファレンス所属、チーム名の別表記、ブラケット構造、NITなどの二次トーナメント試合結果などを含む。</p>

            <h3>Data Section 5 ファイル: MTeamCoaches.csv</h3>
            <p>シーズンごとのヘッドコーチ情報。シーズン途中の交代がある場合は DayNum の範囲で管理。長期在任コーチは複数行にわたって記載されることもある。</p>
            <ul>
                <li><strong>Season</strong>：MSeasons.csv のシーズン。</li>
                <li><strong>TeamID</strong>：対象チームのID。</li>
                <li><strong>FirstDayNum, LastDayNum</strong>：そのコーチがヘッドコーチを務めた期間を表す DayNum の範囲。</li>
                <li><strong>CoachName</strong>：ヘッドコーチ名を <code>first_last</code> のようにアンダースコアで区切った小文字表記。</li>
            </ul>

            <h3>Data Section 5 ファイル: Conferences.csv</h3>
            <p>1985年以降に存在したディビジョンIカンファレンスの一覧。略称と正式名称のみ記載。合併や名称変更などの履歴は追跡していない。</p>
            <ul>
                <li><strong>ConfAbbrev</strong>：カンファレンスの略称。他のファイルで参照。</li>
                <li><strong>Description</strong>：カンファレンスの正式名称。</li>
            </ul>

            <h3>Data Section 5 ファイル: MTeamConferences.csv と WTeamConferences.csv</h3>
            <p>シーズンごとのチームとカンファレンスの対応表。年ごとに所属が変更されるケースも反映されている。</p>
            <ul>
                <li><strong>Season</strong>：対応する MSeasons.csv / WSeasons.csv のシーズン。</li>
                <li><strong>TeamID</strong>：チームのID。</li>
                <li><strong>ConfAbbrev</strong>：上記 Conferences.csv で定義された略称。</li>
            </ul>

            <h3>Data Section 5 ファイル: MConferenceTourneyGames.csv と WConferenceTourneyGames.csv</h3>
            <p>各年のカンファレンストーナメント（セレクションサンデー以前に終了）の試合情報。男子は2001シーズン、女子は2002シーズンから。</p>
            <ul>
                <li><strong>ConfAbbrev</strong>：どのカンファレンスのトーナメントか。</li>
                <li><strong>Season, DayNum, WTeamID, LTeamID</strong>：試合を一意に識別。他の詳細は RegularSeasonCompactResults および DetailedResults で確認。</li>
            </ul>

            <h3>Data Section 5 ファイル: MSecondaryTourneyTeams.csv と WSecondaryTourneyTeams.csv</h3>
            <p>NCAA®トーナメント以外の男子・女子のポストシーズントーナメント（NITなど）に参加したチームの一覧。</p>
            <ul>
                <li><strong>Season</strong>：本ファイル上のシーズン年。</li>
                <li><strong>SecondaryTourney</strong>：トーナメント略称（NIT や WNITなど）。</li>
                <li><strong>TeamID</strong>：該当チームのID。</li>
            </ul>

            <h3>Data Section 5 ファイル: MSecondaryTourneyCompactResults.csv と WSecondaryTourneyCompactResults.csv</h3>
            <p>二次ポストシーズントーナメント（NIT, CBI, CIT, V16, TBC など）の試合結果。基本的には他の Compact Results と同様だが、SecondaryTourney カラムが付加されている。DayNum=132以降の試合なので RegularSeasonCompactResults には含まれない。</p>
            <ul>
                <li><strong>SecondaryTourney</strong>：NIT / CBI / CIT / V16（Vegas16）/ TBC（The Basketball Classic）など。</li>
            </ul>

            <h3>Data Section 5 ファイル: MTeamSpellings.csv と WTeamSpellings.csv</h3>
            <p>チーム名の別表記を示す。外部データのチーム名を本コンペの TeamID にひも付ける用途に使う。</p>
            <ul>
                <li><strong>TeamNameSpelling</strong>：すべて小文字で表記されたチーム名表記。</li>
                <li><strong>TeamID</strong>：対応する MTeams.csv / WTeams.csv の TeamID。</li>
            </ul>

            <h3>Data Section 5 ファイル: MNCAATourneySlots と WNCAATourneySlots</h3>
            <p>NCAA®トーナメントで、各シードがどのように対戦相手と組まれていくかを示すファイル。トーナメントの各ラウンドごとに<strong>Slot</strong>を使って表現。</p>
            <ul>
                <li><strong>Season</strong>：MSeasons.csv / WSeasons.csv のシーズン。</li>
                <li><strong>Slot</strong>：トーナメントゲームを一意に示すID。プレーイン用は3文字（例：W16, Z13）、通常ラウンドは4文字（例：R1W1など）。</li>
                <li><strong>StrongSeed</strong>：本来シードが上位のチームが入る枠。Round 1 なら W01 などのチームシード、Round2 以降は別の Slot が指定される。</li>
                <li><strong>WeakSeed</strong>：シード下位のチームが入る枠。</li>
            </ul>

            <h3>Data Section 5 ファイル: MNCAATourneySeedRoundSlots.csv</h3>
            <p>男子のトーナメント構造を一元的に表したファイル。プレーインシードの位置に関わらず、各シードがどのラウンドでどの Slot を使い、どの DayNum（早い/遅い）に試合をする可能性があるかを示す。女子はスケジュールが大きく異なる年が多いため対応ファイルはない。2021年の男子は特例的なスケジュールだった。</p>
            <ul>
                <li><strong>Seed</strong>：チームのトーナメントシード。</li>
                <li><strong>GameRound</strong>：0（プレーイン）～6までのラウンド番号。0=プレーイン、1/2=1週目、3/4=2週目、5/6=準決勝/決勝。</li>
                <li><strong>GameSlot</strong>：そのラウンドでの試合 Slot。</li>
                <li><strong>EarlyDayNum, LateDayNum</strong>：そのラウンドが行われうる最も早い日、最も遅い日の DayNum。ラウンドによって2日間設定されることがある。</li>
            </ul>
        </section>
<section>
    <h2>Simple starter notebook for March Mania 2025</h2>
    <p><a href="https://www.kaggle.com/code/paultimothymooney/simple-starter-notebook-for-march-mania-2025">Simple starter notebook for March Mania 2025</a></p>
    <h3>大会の目的</h3>
    <p>この大会の目的は、より小さい TeamID があるマッチアップに勝利する確率を予測することである。過去4年間におけるあらゆる可能なチーム同士の全試合について、その確率を予測する。提出用のサンプルファイルでは、ID にはマッチアップの年と両方のチームIDが含まれている。例えば「2025_1101_1104」という ID は、2025年トーナメントにおける TeamID 1101 と TeamID 1104 の対戦を示す。「Pred」に 0.75 と提出すると、TeamID 1101 がこの対戦に勝つ確率が 0.75 だと考えていることを意味する。</p>

    <h3>提出戦略の概要</h3>
    <p>このスターターノートブックでは、簡単な提出を行う。</p>
    <p>試合の勝者を予測するにあたり、対戦する両チームのランキングのみを考慮する。最大の差は 15 (1位と16位の差) なので、簡易的な式として「0.5 + 0.03 × (シードの差)」を用い、予測確率を 5% から 95% の範囲で算出する。より高いシード（つまり数字が小さいチーム、1～16）を持つチームが勝ちやすいとみなし、50%以上の確率を割り当てる形である。</p>

    <h3>スターターコード</h3>
    <h4>ステップ1: Python パッケージのインポート</h4>
    <pre><code>import numpy as np
import pandas as pd
from sklearn.metrics import brier_score_loss, mean_squared_error
</code></pre>

    <h4>ステップ2: データの確認</h4>
    <pre><code>w_seed = pd.read_csv('/kaggle/input/march-machine-learning-mania-2025/WNCAATourneySeeds.csv')
m_seed = pd.read_csv('/kaggle/input/march-machine-learning-mania-2025/MNCAATourneySeeds.csv')
seed_df = pd.concat([m_seed, w_seed], axis=0).fillna(0.05)
submission_df = pd.read_csv('/kaggle/input/march-machine-learning-mania-2025/SampleSubmissionStage2.csv')
</code></pre>
    <p>チームのランキングは <strong>WNCAATourneySeeds.csv</strong> と <strong>MNCAATourneySeeds.csv</strong> に含まれている。</p>
    <ul>
        <li><strong>Season</strong>: 年度を示すカラム</li>
        <li><strong>Seed</strong>: カンファレンスにおけるランク (W01 はカンファレンスWで1位)</li>
        <li><strong>TeamID</strong>: 各チームに付与された固有の識別子</li>
    </ul>
    <p><strong>seed_df.head()</strong></p>
    <pre>
Season  Seed  TeamID
0   1985    W01   1207
1   1985    W02   1210
2   1985    W03   1228
3   1985    W04   1260
4   1985    W05   1374
    </pre>

    <p><strong>sample_submission.csv</strong> には、<em>year_teamID1_teamID2</em> というフォーマットの "ID" カラムが含まれている。</p>

    <p><strong>submission_df.head()</strong></p>
    <pre>
                ID      Pred
0   2025_1101_1102    0.5
1   2025_1101_1103    0.5
2   2025_1101_1104    0.5
3   2025_1101_1105    0.5
4   2025_1101_1106    0.5
    </pre>

    <h4>ステップ3: 試合情報とチームのランクを抽出</h4>
    <pre><code>def extract_game_info(id_str):
    # 年とチームIDを抽出
    parts = id_str.split('_')
    year = int(parts[0])
    teamID1 = int(parts[1])
    teamID2 = int(parts[2])
    return year, teamID1, teamID2

def extract_seed_value(seed_str):
    # シード値を抽出
    try:
        return int(seed_str[1:])
    # 選抜されなかったチームやエラーの場合は16を割り当て
    except ValueError:
        return 16

# データの再整形
submission_df[['Season', 'TeamID1', 'TeamID2']] = submission_df['ID'].apply(extract_game_info).tolist()
seed_df['SeedValue'] = seed_df['Seed'].apply(extract_seed_value)

# TeamID1 のシード情報をマージ
submission_df = pd.merge(submission_df, seed_df[['Season', 'TeamID', 'SeedValue']],
                         left_on=['Season', 'TeamID1'], right_on=['Season', 'TeamID'],
                         how='left')
submission_df = submission_df.rename(columns={'SeedValue': 'SeedValue1'}).drop(columns=['TeamID'])

# TeamID2 のシード情報をマージ
submission_df = pd.merge(submission_df, seed_df[['Season', 'TeamID', 'SeedValue']],
                         left_on=['Season', 'TeamID2'], right_on=['Season', 'TeamID'],
                         how='left')
submission_df = submission_df.rename(columns={'SeedValue': 'SeedValue2'}).drop(columns=['TeamID'])
</code></pre>

    <h4>ステップ4: 予測の作成</h4>
    <pre><code># シード差を計算
submission_df['SeedDiff'] = submission_df['SeedValue1'] - submission_df['SeedValue2']

# 'Pred' カラムの更新
submission_df['Pred'] = 0.5 + (0.03 * submission_df['SeedDiff'])

# 不要なカラムを削除
submission_df = submission_df[['ID', 'Pred']].fillna(0.5)

# 提出データのプレビュー
submission_df.head()
</code></pre>

    <pre>
                ID      Pred
0   2025_1101_1102    0.5
1   2025_1101_1103    0.5
2   2025_1101_1104    0.5
3   2025_1101_1105    0.5
4   2025_1101_1106    0.5
    </pre>

    <pre>
count    131407.0
mean          0.5
std           0.0
min           0.5
25%           0.5
50%           0.5
75%           0.5
max           0.5
Name: Pred, dtype: float64
    </pre>

    <h4>ステップ5: 評価指標を理解する</h4>
    <p>実際の試合結果は分からないため、便宜上、<strong>ID</strong> に先に記載されたチーム(TeamID1) がすべて勝利したと仮定する。これを「真の値 (true value)」と呼ぶ。次に、提出した確率とこの真の値の平均二乗誤差を計算する。これを Brier Score と呼ぶ。詳しくは <a href="https://en.wikipedia.org/wiki/Brier_score">https://en.wikipedia.org/wiki/Brier_score</a> を参照せよ。</p>

    <pre><code># 真の値を格納したデータフレームを作成
solution_df = submission_df.copy()
solution_df['Pred'] = 1

# Brier Score を計算
y_true = solution_df['Pred']
y_pred = submission_df['Pred']
brier_score = brier_score_loss(y_true, y_pred)
print(f"Brier Score: {brier_score}")
</code></pre>

    <pre>
Brier Score: 0.25
    </pre>

    <h4>ステップ6: 提出を作成</h4>
    <pre><code>submission_df.to_csv('/kaggle/working/submission.csv', index=False)
</code></pre>
</section>
<section>
    <h2>March ML Mania 2025 - Brier Score Prediction</h2>
    <p><a href="https://www.kaggle.com/code/jocelyndumlao/march-ml-mania-2025-brier-score-prediction">March ML Mania 2025 - Brier Score Prediction</a></p>
    <p>このノートブックでは、NCAAディビジョンI男子・女子バスケットボールの過去データを活用し、March Madnessトーナメントの試合結果を予測する。提供されているデータセットには、チーム情報、試合結果、トーナメントのシード情報などが含まれる。データファイルの名前には男性（M）、女性（W）のプレフィックスが付与されており、中には両方に適用されるデータもある。</p>
    <h3>目的:</h3>
    <p>このコンペティションの評価指標である Brier スコアを最小化すること。</p>

    <h3>アプローチ:</h3>
    <ul>
        <li>まずはシードの差を利用した単純なモデルから始める。</li>
        <li>徐々に高度な特徴量や手法を組み込んでいく。</li>
    </ul>

    <h3>Brier スコア</h3>
    <p>Brier スコアは、確率的予測の精度を測定するための厳密に適切 (strictly proper) なスコアリングルールである。単一次元の予測においては、予測確率に適用される平均二乗誤差（MSE）と本質的に同値である。</p>
    <p>Brier スコアは、互いに排他的な離散的な結果またはクラスに対して予測が確率を割り当てなければならないタスクに適用可能である。可能な結果の集合は二値または多クラスのいずれかであり、これらの確率は 0～1 の範囲にある必要があり、かつすべての合計が 1 となるように割り当てられる必要がある。これは 1950 年に Glenn W. Brier によって提案された。</p>
    <p>Brier スコアはコスト関数と考えることができる。より正確には、<code>i ∈ 1...N</code> 個の予測セットに対して、Brier スコアは以下の差の二乗平均を測定する:</p>
    <ul>
        <li>アイテム <code>i</code> に割り当てられた可能な結果への予測確率</li>
        <li>アイテム <code>i</code> の実際の結果 <code>o<sub>i</sub></code></li>
    </ul>
    <p>したがって、Brier スコアが低いほど、予測が適切にキャリブレーションされていることを意味する。一般的な形式では、このスコアは 0 から 1 の間の値をとる。これは、予測確率（0～1 のみ）と実際の結果（0 か 1 のみ）との最大差を平方した値が 1 になるためである。オリジナルの(1950 年) Brier スコアの定義では、この範囲が 0 から 2 の間だった。</p>
    <p>Brier スコアは、真偽 (true/false) のいずれかとなるバイナリ・カテゴリカルな結果には適切だが、3 種類以上の値を取る順序変数 (ordinal) には不向きである。</p>
    <p>リンク: <a href="https://en.wikipedia.org/wiki/Brier_score">https://en.wikipedia.org/wiki/Brier_score</a></p>

    <h3>ライブラリのインポート</h3>
    <pre><code>import glob
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, cross_val_score, KFold
from sklearn.preprocessing import StandardScaler
from sklearn.impute import SimpleImputer
from sklearn.metrics import log_loss, brier_score_loss, mean_squared_error, roc_curve, auc
from sklearn.ensemble import RandomForestRegressor

import warnings
warnings.filterwarnings("ignore")
</code></pre>

    <h3>データの読み込み</h3>
    <pre><code>data_dir = '/kaggle/input/march-machine-learning-mania-2025/**'
class TournamentPredictor:
    def __init__(self, data_dir):
        self.data_path = data_dir
        self.data = None
        self.teams = None
        self.seeds = None
        self.games = None
        self.sub = None
        self.gb = None
        self.col = None
        self.model = None # declare model here.
        self.calibration_model = None # declare calibration model here.
        self.imputer = SimpleImputer(strategy='mean')
        self.scaler = StandardScaler()

    def load_data(self):
        files = glob.glob(self.data_path)
        self.data = {p.split('/')[-1].split('.')[0]: pd.read_csv(p, encoding='latin-1') for p in files}

        teams = pd.concat([self.data['MTeams'], self.data['WTeams']])
        teams_spelling = pd.concat([self.data['MTeamSpellings'], self.data['WTeamSpellings']])
        teams_spelling = teams_spelling.groupby(by='TeamID', as_index=False)['TeamNameSpelling'].count()
        teams_spelling.columns = ['TeamID', 'TeamNameCount']
        self.teams = pd.merge(teams, teams_spelling, how='left', on=['TeamID'])

        season_cresults = pd.concat([self.data['MRegularSeasonCompactResults'], self.data['WRegularSeasonCompactResults']])
        season_dresults = pd.concat([self.data['MRegularSeasonDetailedResults'], self.data['WRegularSeasonDetailedResults']])
        tourney_cresults = pd.concat([self.data['MNCAATourneyCompactResults'], self.data['WNCAATourneyCompactResults']])
        tourney_dresults = pd.concat([self.data['MNCAATourneyDetailedResults'], self.data['WNCAATourneyDetailedResults']])

        seeds_df = pd.concat([self.data['MNCAATourneySeeds'], self.data['WNCAATourneySeeds']])
        self.seeds = {'_'.join(map(str, [int(k1), k2])): int(v[1:3]) for k1, v, k2 in seeds_df[['Season', 'Seed', 'TeamID']].values}

        self.sub = self.data['SampleSubmissionStage1']

        season_cresults['ST'] = 'S'
        season_dresults['ST'] = 'S'
        tourney_cresults['ST'] = 'T'
        tourney_dresults['ST'] = 'T'

        self.games = pd.concat((season_dresults, tourney_dresults), axis=0, ignore_index=True)
        self.games['WLoc'] = self.games['WLoc'].map({'A': 1, 'H': 2, 'N': 3})

        self.games['ID'] = self.games.apply(lambda r: '_'.join(map(str, [r['Season']] + sorted([r['WTeamID'], r['LTeamID']]))), axis=1)
        self.games['IDTeams'] = self.games.apply(lambda r: '_'.join(map(str, sorted([r['WTeamID'], r['LTeamID']]))), axis=1)
        self.games['Team1'] = self.games.apply(lambda r: sorted([r['WTeamID'], r['LTeamID']])[0], axis=1)
        self.games['Team2'] = self.games.apply(lambda r: sorted([r['WTeamID'], r['LTeamID']])[1], axis=1)
        self.games['IDTeam1'] = self.games.apply(lambda r: '_'.join(map(str, [r['Season'], r['Team1']])), axis=1)
        self.games['IDTeam2'] = self.games.apply(lambda r: '_'.join(map(str, [r['Season'], r['Team2']])), axis=1)
        self.games['Team1Seed'] = self.games['IDTeam1'].map(self.seeds).fillna(0)
        self.games['Team2Seed'] = self.games['IDTeam2'].map(self.seeds).fillna(0)
        self.games['ScoreDiff'] = self.games['WScore'] - self.games['LScore']
        self.games['Pred'] = self.games.apply(lambda r: 1.0 if sorted([r['WTeamID'], r['LTeamID']])[0] == r['WTeamID'] else 0.0, axis=1)
        self.games['ScoreDiffNorm'] = self.games.apply(lambda r: r['ScoreDiff'] * -1 if r['Pred'] == 0.0 else r['ScoreDiff'], axis=1)
        self.games['SeedDiff'] = self.games['Team1Seed'] - self.games['Team2Seed']
        self.games = self.games.fillna(-1)

        c_score_col = ['NumOT', 'WFGM', 'WFGA', 'WFGM3', 'WFGA3', 'WFTM', 'WFTA', 'WOR', 'WDR', 'WAst', 'WTO', 'WStl', 'WBlk', 'WPF', 'LFGM', 'LFGA', 'LFGM3', 'LFGA3', 'LFTM', 'LFTA', 'LOR', 'LDR', 'LAst', 'LTO', 'LStl', 'LBlk', 'LPF']
        c_score_agg = ['sum', 'mean', 'median', 'max', 'min', 'std', 'skew', 'nunique']
        self.gb = self.games.groupby(by=['IDTeams']).agg({k: c_score_agg for k in c_score_col}).reset_index()
        self.gb.columns = [''.join(c) + '_c_score' for c in self.gb.columns]

        self.games = self.games[self.games['ST'] == 'T']

        self.sub['WLoc'] = 3
        self.sub['Season'] = self.sub['ID'].map(lambda x: x.split('_')[0]).astype(int)
        self.sub['Team1'] = self.sub['ID'].map(lambda x: x.split('_')[1])
        self.sub['Team2'] = self.sub['ID'].map(lambda x: x.split('_')[2])
        self.sub['IDTeams'] = self.sub.apply(lambda r: '_'.join(map(str, [r['Team1'], r['Team2']])), axis=1)
        self.sub['IDTeam1'] = self.sub.apply(lambda r: '_'.join(map(str, [r['Season'], r['Team1']])), axis=1)
        self.sub['IDTeam2'] = self.sub.apply(lambda r: '_'.join(map(str, [r['Season'], r['Team2']])), axis=1)
        self.sub['Team1Seed'] = self.sub['IDTeam1'].map(self.seeds).fillna(0)
        self.sub['Team2Seed'] = self.sub['IDTeam2'].map(self.seeds).fillna(0)
        self.sub['SeedDiff'] = self.sub['Team1Seed'] - self.sub['Team2Seed']
        self.sub = self.sub.fillna(-1)

        self.games = pd.merge(self.games, self.gb, how='left', left_on='IDTeams', right_on='IDTeams_c_score')
        self.sub = pd.merge(self.sub, self.gb, how='left', left_on='IDTeams', right_on='IDTeams_c_score')

        exclude_cols = ['ID', 'DayNum', 'ST', 'Team1', 'Team2', 'IDTeams', 'IDTeam1', 'IDTeam2', 'WTeamID', 'WScore', 'LTeamID', 'LScore', 'NumOT', 'Pred', 'ScoreDiff', 'ScoreDiffNorm', 'WLoc'] + c_score_col
        self.col = [c for c in self.games.columns if c not in exclude_cols]
        print("Data loading and preprocessing completed.")

    def create_models(self):
      # Create the models here with the same parameters.
      self.model = RandomForestRegressor(
          n_estimators=235,
          random_state=42,
          max_depth=15,
          min_samples_split=2,
          max_features='sqrt',
          n_jobs=-1
      )
      self.calibration_model = RandomForestRegressor(n_estimators=100, random_state=42, n_jobs=-1, max_depth=10)



    def train_model(self):
        X = self.games[self.col].fillna(-1)
        X_imputed = self.imputer.fit_transform(X)
        X_scaled = self.scaler.fit_transform(X_imputed)
        y = self.games['Pred']

        X_train, X_cal, y_train, y_cal = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

        self.model.fit(X_train, y_train)
        train_preds = self.model.predict(X_train).clip(0.001, 0.999)

        cal_preds = self.model.predict(X_cal).clip(0.001, 0.999)
        self.calibration_model.fit(cal_preds.reshape(-1, 1), y_cal)

        train_preds_calibrated = self.calibration_model.predict(train_preds.reshape(-1, 1)).clip(0.001, 0.999)

        print(f'Log Loss (Train): {log_loss(y_train, train_preds_calibrated):.4f}')
        print(f'Brier Score (Train): {brier_score_loss(y_train, train_preds_calibrated):.4f}')
        print(f'MSE (Train): {mean_squared_error(y_train, train_preds_calibrated):.4f}')

        # Plot ROC Curve for the calibration set.
        self.plot_roc_curve(y_cal, cal_preds, "Calibration Set ROC Curve")

        kf = KFold(n_splits=5, shuffle=True, random_state=42)
        cv_mse_scores = []
        cv_logloss_scores = []
        for train_index, val_index in kf.split(X_scaled):
            X_train, X_val = X_scaled[train_index], X_scaled[val_index]
            y_train, y_val = y[train_index], y[val_index]

            self.model.fit(X_train, y_train)
            val_preds = self.model.predict(X_val).clip(0.001, 0.999)

            self.calibration_model.fit(val_preds.reshape(-1, 1), y_val)
            val_preds_calibrated = self.calibration_model.predict(val_preds.reshape(-1, 1)).clip(0.001, 0.999)

            mse = mean_squared_error(y_val, val_preds_calibrated)
            logloss = log_loss(y_val, val_preds_calibrated)

            cv_mse_scores.append(mse)
            cv_logloss_scores.append(logloss)

        print(f'Cross-validated MSE: {np.mean(cv_mse_scores):.4f}')
        print(f'Cross-validated LogLoss: {np.mean(cv_logloss_scores):.4f}')

        feature_importances = self.model.feature_importances_
        feature_names = self.col
        self.plot_feature_importance(feature_importances, feature_names)

        self.plot_calibration_curve(y_cal, cal_preds)

        # Plot the distribution of calibrated predictions.
        self.plot_prediction_distribution(train_preds_calibrated, "Distribution of Calibrated Training Predictions")

    def predict_submission(self, output_file='submission.csv'):
        sub_X = self.sub[self.col].fillna(-1)
        sub_X_imputed = self.imputer.transform(sub_X)
        sub_X_scaled = self.scaler.transform(sub_X_imputed)

        preds = self.model.predict(sub_X_scaled).clip(0.001, 0.999)
        preds_calibrated = self.calibration_model.predict(preds.reshape(-1, 1)).clip(0.001, 0.999)

        self.sub['Pred'] = preds_calibrated
        self.sub[['ID', 'Pred']].to_csv(output_file, index=False)
        print(f"Submission file saved to {output_file}")

    def plot_feature_importance(self, importances, feature_names, top_n=20):
        feature_importance_df = pd.DataFrame({'feature': feature_names, 'importance': importances})
        feature_importance_df = feature_importance_df.sort_values('importance', ascending=False).head(top_n)

        plt.figure(figsize=(10, 6))
        sns.barplot(x='importance', y='feature', data=feature_importance_df, palette='viridis')
        plt.title('Top {} Feature Importances'.format(top_n))
        plt.xlabel('Importance')
        plt.ylabel('Feature')
        plt.tight_layout()
        plt.show()

    def plot_calibration_curve(self, y_true, y_proba, n_bins=10):

        combined = np.stack([y_proba, y_true], axis=-1)
        combined = combined[np.argsort(combined[:, 0])]
        sorted_probas = combined[:, 0]
        sorted_true = combined[:, 1]

        bins = np.linspace(0, 1, n_bins + 1)
        bin_midpoints = bins[:-1] + (bins[1] - bins[0]) / 2
        bin_assignments = np.digitize(sorted_probas, bins) - 1

        bin_sums = np.bincount(bin_assignments, weights=sorted_probas, minlength=n_bins)
        bin_true = np.bincount(bin_assignments, weights=sorted_true, minlength=n_bins)
        bin_total = np.bincount(bin_assignments, minlength=n_bins)

        fraction_of_positives = bin_true / bin_total
        fraction_of_positives[np.isnan(fraction_of_positives)] = 0

        plt.figure(figsize=(8, 6))
        plt.plot(bin_midpoints, fraction_of_positives, marker='o', label='Calibration Curve')
        plt.plot([0, 1], [0, 1], linestyle='--', color='gray', label='Perfectly Calibrated')

        plt.xlabel('Predicted Probability')
        plt.ylabel('Fraction of Positives')
        plt.title('Calibration Curve')
        plt.xlim(0, 1)
        plt.ylim(0, 1)
        plt.legend()
        plt.tight_layout()
        plt.show()

    def plot_prediction_distribution(self, predictions, title="Distribution of Predictions"):
        """Plots the distribution of model predictions."""
        plt.figure(figsize=(8, 6))
        sns.histplot(predictions, kde=True, color='skyblue')
        plt.title(title)
        plt.xlabel('Predicted Probability')
        plt.ylabel('Frequency')
        plt.tight_layout()
        plt.show()

    def plot_roc_curve(self, y_true, y_proba, title="ROC Curve"):
      """Plots the Receiver Operating Characteristic (ROC) curve."""
      fpr, tpr, thresholds = roc_curve(y_true, y_proba)
      roc_auc = auc(fpr, tpr)

      plt.figure(figsize=(8, 6))
      plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = {:.2f})'.format(roc_auc))
      plt.plot([0, 1], [0, 1], color='gray', linestyle='--')
      plt.xlabel('False Positive Rate')
      plt.ylabel('True Positive Rate')
      plt.title(title)
      plt.xlim([0.0, 1.0])
      plt.ylim([0.0, 1.05])
      plt.legend(loc="lower right")
      plt.tight_layout()
      plt.show()


    def run_all(self):
        self.load_data()
        self.create_models()
        self.train_model()
        self.predict_submission()

# Example usage:
if __name__ == "__main__":
    data_dir = '/kaggle/input/march-machine-learning-mania-2025/**'  # Or a local dir
    predictor = TournamentPredictor(data_dir)
    predictor.run_all()
</code></pre>

    <pre>
Data loading and preprocessing completed.
Log Loss (Train): 0.2075
Brier Score (Train): 0.0664
MSE (Train): 0.0664

Cross-validated MSE: 0.0802
Cross-validated LogLoss: 0.2823



Submission file saved to submission.csv
    </pre>
</section>
<section>
    <h2>🏀 BBall EDA Tutorial</h2>
    <p><a href="https://www.kaggle.com/code/clehmann10/bball-eda-tutorial">🏀 BBall EDA Tutorial</a></p>
    <p>ここでは、March Machine Learning Mania 2025 のデータに対して基本的な探索的データ分析 (EDA) を行う手順を紹介する。機械学習モデルを作成し始める前に、問題を理解するうえで重要となるステップである。</p>
    <p>この記事では、提供されているデータをどのように探索し、有用な可視化を作成するかを紹介する。</p>

    <h3>概要情報</h3>
    <h4>大会の構造とトーナメントについて</h4>
    <p><strong>トーナメント形式:</strong></p>
    <ul>
        <li>男子・女子トーナメントともにシングルエリミネーション形式を採用。</li>
        <li>例年3月から4月にかけて開催。</li>
        <li>男子・女子ともに64チーム（プレーインゲームを含めて64チームに絞られる）で行われる。</li>
        <li>シーディング（シード割り当て）は、レギュラーシーズンやカンファレンスの結果、対戦相手の強さなどを総合的に評価し、選考委員会が決定。</li>
    </ul>
    <p><strong>地域区分:</strong></p>
    <ul>
        <li>男子・女子の両大会は「東」「西」「南」「中西部」の4つの地域（リージョン）に分かれる。</li>
        <li>各リージョンには1〜16のシードで割り振られたチームが入り、高いシードのチームが優勢とされる。</li>
    </ul>
    <p><strong>対戦とアップセット:</strong></p>
    <ul>
        <li>対戦カード、シード、結果に関するデータは、歴史的に注目すべきトピック（例: 16番シードが1番シードに勝つなど）を分析する際の鍵となる。</li>
        <li>ラウンドの進行: 1回戦→2回戦→スウィート16→エリート8→ファイナル4→決勝。</li>
    </ul>
    <p><strong>過去のデータ:</strong></p>
    <ul>
        <li>チームの実績: 過去の優勝チーム、準優勝チーム、深いラウンドまで進んだチームのデータを見れば、シードやカンファレンス、特定チームの特徴などの傾向を分析可能。</li>
        <li>選手の成績: 得点、リバウンド、アシストなどを追跡すれば、選手の貢献度や試合結果への影響を把握できる。</li>
        <li>試合の統計: 得点、シュート成功率、ターンオーバー、ファウルなどから、勝敗に関わる要因を洗い出すことが可能。</li>
    </ul>

    <h3>データ分析の主な指標</h3>
    <p><strong>シードとパフォーマンスの関係:</strong> 高シードのチームは低シードよりもパフォーマンスが高い傾向があるが、時折番狂わせ（アップセット）が起こる。</p>
    <p><strong>歴史的傾向やパターン:</strong></p>
    <ul>
        <li>アップセット: 早いラウンドで起こる下位シードの勝利の数や頻度。</li>
        <li>スウィート16 / エリート8 進出率: 上位シードが後のラウンドにどの程度進むかを分析。</li>
        <li>ファイナル4や決勝: 特定のチームやカンファレンスが安定して良い成績を残すかを見る。</li>
    </ul>
    <p><strong>チームやカンファレンスのパフォーマンス:</strong></p>
    <ul>
        <li>カンファレンスの強さ: ACC、Big Ten、SEC など特定カンファレンスの大会全体や重要なラウンドでの成績。</li>
        <li>チームの特徴: 攻撃重視か守備重視か、ターンオーバー率、フィールドゴール成功率、ベンチ層の厚さなど。</li>
    </ul>

    <h3>NCAAとは？</h3>
    <p>NCAA（全米大学体育協会）においては、バスケットボールのようなトーナメント方式で、地域（リージョン）を設けてチームを振り分け、競技を進行させる。これは特に NCAA ディビジョンI男子バスケットボール大会（いわゆる March Madness）で顕著である。</p>
    <p>下記がリージョンについての概要である:</p>
    <ul>
        <li><strong>トーナメント構造:</strong> 68チーム（実質的にプレーインを含める）を4つのリージョンに分割。地理名（東、西、南、中西部など）が使われる。</li>
        <li><strong>シーディング:</strong> 各リージョンで1〜16シードに振り分けられ、レギュラーシーズン成績や各種評価指標に基づいて決定される。高シードチームは理論上、より簡単な組み合わせが与えられる。</li>
        <li><strong>進行:</strong> リージョン内で対戦を重ね、リージョンの勝者（地域優勝校）がファイナル4に進出する。</li>
    </ul>

    <h3>目的</h3>
    <p>2025年の March Madness における各試合の結果を、過去のデータのみを使って予測する。目標は、それぞれの対戦の勝利確率を推定するようなモデルを構築し、最終的にベストな全体スコアを得ることである。</p>

    <h3>⚙️ セットアップ</h3>
    <p>まずは必要なライブラリをインポートし、EDA に向けた設定やツールを準備する。</p>

    <pre><code># Essential Imports
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from tqdm import tqdm
import os
import ipywidgets as widgets
from IPython.display import display
import warnings

# Niche Imports
import chardet

warnings.filterwarnings("ignore")
</code></pre>

    <h3>📂 ファイルの準備</h3>
    <p>提供されたファイルをざっと確認してみる。各ファイルの説明は競技データページにも掲載されている（<a href="https://www.kaggle.com/competitions/march-machine-learning-mania-2025/data">https://www.kaggle.com/competitions/march-machine-learning-mania-2025/data</a>）。</p>
    <p>主催者は以下の5つのセクションに分割している:</p>
    <ol>
        <li>The Basics - 最小限の予測モデルを構築して提出するために必要な基本的なデータ。</li>
        <li>Team Box Scores - 1試合ごとのスタッツ (フリースロー数、リバウンド、ターンオーバーなど)。</li>
        <li>Geography - 試合の開催都市などの地理情報。</li>
        <li>Public Rankings - 週ごと(男子のみ)のランキングデータ (Pomeroy, Sagarin, RPI, ESPNなど)。</li>
        <li>Supplements - 追加の情報(コーチ、カンファレンス、チーム名のスペル、NITその他のデータなど)。</li>
    </ol>
    <p><strong>競技ディレクトリ:</strong> <code>/kaggle/input/march-machine-learning-mania-2025</code></p>
    <p>中には以下のファイルが含まれている（全てリストアップ）:</p>
    <ul>
        <li>(File) Conferences.csv, Size: 1643 bytes</li>
        <li>(File) SeedBenchmarkStage1.csv, Size: 10649275 bytes</li>
        <li>(File) WNCAATourneyDetailedResults.csv, Size: 89624 bytes</li>
        <li>(File) WRegularSeasonCompactResults.csv, Size: 3949227 bytes</li>
        <li>(File) MNCAATourneySeedRoundSlots.csv, Size: 15904 bytes</li>
        <li>(File) MRegularSeasonDetailedResults.csv, Size: 11613384 bytes</li>
        <li>(File) MNCAATourneyCompactResults.csv, Size: 75699 bytes</li>
        <li>(File) MGameCities.csv, Size: 2724091 bytes</li>
        <li>(File) WSecondaryTourneyCompactResults.csv, Size: 28919 bytes</li>
        <li>(File) WGameCities.csv, Size: 2621798 bytes</li>
        <li>(File) MSeasons.csv, Size: 1819 bytes</li>
        <li>(File) WNCAATourneySlots.csv, Size: 34266 bytes</li>
        <li>(File) MSecondaryTourneyTeams.csv, Size: 27572 bytes</li>
        <li>(File) Cities.csv, Size: 9612 bytes</li>
        <li>(File) MTeamSpellings.csv, Size: 22758 bytes</li>
        <li>(File) MRegularSeasonCompactResults.csv, Size: 5591072 bytes</li>
        <li>(File) MMasseyOrdinals.csv, Size: 119629314 bytes</li>
        <li>(File) MSecondaryTourneyCompactResults.csv, Size: 61633 bytes</li>
        <li>(File) WTeams.csv, Size: 6179 bytes</li>
        <li>(File) WConferenceTourneyGames.csv, Size: 160940 bytes</li>
        <li>(File) MNCAATourneySlots.csv, Size: 50374 bytes</li>
        <li>(File) MNCAATourneySeeds.csv, Size: 38514 bytes</li>
        <li>(File) WNCAATourneyCompactResults.csv, Size: 49594 bytes</li>
        <li>(File) WSeasons.csv, Size: 1468 bytes</li>
        <li>(File) WNCAATourneySeeds.csv, Size: 25184 bytes</li>
        <li>(File) MTeamCoaches.csv, Size: 403931 bytes</li>
        <li>(File) MConferenceTourneyGames.csv, Size: 171066 bytes</li>
        <li>(File) WRegularSeasonDetailedResults.csv, Size: 7925867 bytes</li>
        <li>(File) MNCAATourneyDetailedResults.csv, Size: 138174 bytes</li>
        <li>(File) WTeamSpellings.csv, Size: 22606 bytes</li>
        <li>(File) MTeamConferences.csv, Size: 230800 bytes</li>
        <li>(File) MTeams.csv, Size: 10030 bytes</li>
        <li>(File) WTeamConferences.csv, Size: 163878 bytes</li>
        <li>(File) SampleSubmissionStage1.csv, Size: 10142167 bytes</li>
        <li>(File) WSecondaryTourneyTeams.csv, Size: 13080 bytes</li>
    </ul>

    <h3>📊 データセクション 1 - The Basics</h3>
    <p>最も基本的な予測モデルの構築と提出に必要なデータが含まれている。</p>
    <ul>
        <li>チームIDとチーム名</li>
        <li>1984-85シーズン以降のトーナメントシード情報</li>
        <li>1984-85シーズン以降のレギュラーシーズン、カンファレンストーナメント、NCAAトーナメントの最終スコア</li>
        <li>シーズンレベルの詳細（日付やリージョン名など）</li>
        <li>ステージ1のサンプル提出ファイル</li>
    </ul>
    <p>シーズンを識別する際は、通常シーズンが終わる年（年度末）で呼ぶ慣習を踏襲する。</p>

    <h4>Teams</h4>
    <p><strong>ファイル:</strong> <code>MTeams.csv</code> および <code>WTeams.csv</code></p>
    <ul>
        <li><strong>TeamID:</strong> 各大学チームを識別する4桁の番号。男子は1000〜1999、女子は3000〜3999。</li>
        <li><strong>TeamName:</strong> チーム名を16文字以内で簡略表示したもの。</li>
        <li><strong>FirstD1Season, LastD1Season:</strong> データセットにおいて、その学校がディビジョンIだった初年度・最終年度（男子のみ）。女子には含まれない。</li>
    </ul>

    <pre><code>mens_df = load_csv(os.path.join(comp_dir, 'MTeams.csv'))
womens_df = load_csv(os.path.join(comp_dir, 'WTeams.csv'))
for gender in ['Mens', 'Womens']:
    print(f"Investigating {gender} Team")
    if gender == 'Mens':
        df = mens_df
    else:
        df = womens_df
    display(df.describe())
    display(df.head())
</code></pre>

    <p>このように、Women'sの方には <code>FirstD1Season</code> や <code>LastD1Season</code> がないことが確認できる。また男子と女子ではチーム数が若干異なる。</p>

    <pre><code># Find unique values in Team Names
series1 = mens_df['TeamName']
series2 = womens_df['TeamName']
unique_in_series1 = series1[~series1.isin(series2)]
unique_in_series2 = series2[~series2.isin(series1)]

unique_values = pd.concat([unique_in_series1, unique_in_series2])
print(unique_values)
</code></pre>

    <p>この結果、「Citadel」と「VMI」が男子のみで女子に含まれていないことが分かった。</p>

    <h4>Seasons</h4>
    <p><strong>ファイル:</strong> <code>MSeasons.csv</code> および <code>WSeasons.csv</code></p>
    <ul>
        <li><strong>Season:</strong> NCAAトーナメントが行われた年。</li>
        <li><strong>DayZero:</strong> DayNum=0 に対応する日付。<code>MSeasons.csv</code> と <code>WSeasons.csv</code> で同じ DayZero を共有している。</li>
        <li><strong>RegionW, RegionX, RegionY, RegionZ:</strong> 大会の4つの地域をアルファベット順に W, X, Y, Z で表すための名称。</li>
    </ul>

    <pre><code>mens_df = load_csv(os.path.join(comp_dir, 'MSeasons.csv'))
womens_df = load_csv(os.path.join(comp_dir, 'WSeasons.csv'))
for gender in ['Mens', 'Womens']:
    ...
</code></pre>

    <p>メンズは1985～2025、ウィメンズは1998～2025 と年度範囲が異なることに注意。</p>

    <h4>Tourney Seeds</h4>
    <p><strong>ファイル:</strong> <code>MNCAATourneySeeds.csv</code> および <code>WNCAATourneySeeds.csv</code></p>
    <ul>
        <li><strong>Season:</strong> 大会の年度</li>
        <li><strong>Seed:</strong> 「W01」「X02」「Y03」「Z16」など、先頭の文字がリージョン(W, X, Y, Z)、続く2桁がシード番号(01〜16)。プレーインの場合は最後に <code>a</code> や <code>b</code> が付く。</li>
        <li><strong>TeamID:</strong> チームを識別するID。</li>
    </ul>

    <pre><code>mens_df = load_csv(os.path.join(comp_dir, 'MNCAATourneySeeds.csv'))
womens_df = load_csv(os.path.join(comp_dir, 'WNCAATourneySeeds.csv'))
for gender in ['Mens', 'Womens']:
    ...
</code></pre>

    <p>このシード情報とリージョンの組み合わせが、本大会の対戦構造を把握する上で重要である。</p>

    <h4>Regular Season Results</h4>
    <p><strong>ファイル:</strong> <code>MRegularSeasonCompactResults.csv</code> および <code>WRegularSeasonCompactResults.csv</code></p>
    <ul>
        <li><strong>Season, DayNum:</strong> 試合年度と、シーズン中の日数（0〜132）。</li>
        <li><strong>WTeamID, WScore:</strong> 勝利チームのIDとスコア。</li>
        <li><strong>LTeamID, LScore:</strong> 敗北チームのIDとスコア。</li>
        <li><strong>WLoc:</strong> 勝利チームのホーム/アウェイ/中立地 (H, A, N)。</li>
        <li><strong>NumOT:</strong> 試合のオーバータイム回数。</li>
    </ul>

    <pre><code>mens_df = load_csv(os.path.join(comp_dir, 'MRegularSeasonCompactResults.csv'))
womens_df = load_csv(os.path.join(comp_dir, 'WRegularSeasonCompactResults.csv'))
for gender in ['Mens', 'Womens']:
    ...
</code></pre>

    <p>得点分布を可視化するなど、基礎的なEDAを行える。</p>

    <pre><code># Look at distributions of winning and losing scores across seasons
for gender in ['Mens', 'Womens']:
    ...
</code></pre>

    <h4>Tourney Results</h4>
    <p><strong>ファイル:</strong> <code>MNCAATourneyCompactResults.csv</code> および <code>WNCAATourneyCompactResults.csv</code></p>
    <ul>
        <li>NCAAトーナメントでの試合結果を示す。構造はレギュラーシーズンのCompactResultsと同じ。</li>
        <li>男子はすべて中立地(N)、女子は状況により中立地にならない場合がある。</li>
        <li>DayNum を見れば、大まかにどのラウンドかを推定できる（男子は134〜154、女子は変動あり）。</li>
    </ul>

    <pre><code>mens_df = load_csv(os.path.join(comp_dir, 'MNCAATourneyCompactResults.csv'))
womens_df = load_csv(os.path.join(comp_dir, 'WNCAATourneyCompactResults.csv'))
for gender in ['Mens', 'Womens']:
    ...
</code></pre>

    <h4>Sample Submission</h4>
    <p><strong>ファイル:</strong> <code>SampleSubmissionStage1.csv</code></p>
    <ul>
        <li>Stage 1 のサンプル提出フォーマット。すべての可能性のある対戦において勝率0.5を仮置きしている。</li>
        <li><strong>ID:</strong> <code>SSSS_XXXX_YYYY</code> の形式で、<code>SSSS</code> は年度、<code>XXXX</code> は小さい方のTeamID、<code>YYYY</code> は大きい方のTeamID。</li>
        <li><strong>Pred:</strong> <code>XXXX</code> 側チームの勝利確率。</li>
    </ul>

    <pre><code>ss_df = load_csv(os.path.join(comp_dir, 'SampleSubmissionStage1.csv'))
ss_df.head()
</code></pre>

    <h3>📊 データセクション 2 - Team Box Scores</h3>
    <p>2003年以降（男子）・2010年以降（女子）の全試合（レギュラーシーズン、カンファレンストーナメント、NCAAトーナメント）におけるチーム別の詳細スタッツを提供。</p>
    <p>Team Box Scores は "Detailed Results" ファイルに含まれている。Compact Results と同様の前8列 (Season, DayNum, WTeamID, WScore, LTeamID, LScore, WLoc, NumOT) に加えて、勝敗チーム別に多くの追加情報がある:</p>
    <ul>
        <li><strong>WFGM, WFGA:</strong> 勝利チームのフィールドゴール成功数と試投数</li>
        <li><strong>WFGM3, WFGA3:</strong> 勝利チームの3ポイント成功数と試投数</li>
        <li><strong>WFTM, WFTA:</strong> 勝利チームのフリースロー成功数と試投数</li>
        <li><strong>WOR, WDR:</strong> 勝利チームのオフェンスリバウンドとディフェンスリバウンド</li>
        <li><strong>WAst, WTO, WStl, WBlk, WPF:</strong> アシスト、ターンオーバー、スティール、ブロック、ファウルなど</li>
        <li>敗者側についても同様に LFGM, LFGA, ... LPF まで。</li>
    </ul>
    <p>2点シュートだけ見たい場合は、<code>FGM - FGM3</code> などの計算が必要である。得点合計は <code>(2 * FGM) + FGM3 + FTM</code> で求められる。</p>

    <h4>レギュラーシーズン Detailed Results</h4>
    <p><strong>ファイル:</strong> <code>MRegularSeasonDetailedResults.csv</code> および <code>WRegularSeasonDetailedResults.csv</code></p>
    <p>2003年(男子)・2010年(女子)以降の各試合に関する詳細スタッツが含まれる。</p>

    <pre><code>mens_df = load_csv(os.path.join(comp_dir, 'MRegularSeasonDetailedResults.csv'))
womens_df = load_csv(os.path.join(comp_dir, 'WRegularSeasonDetailedResults.csv'))
for gender in ['Mens', 'Womens']:
    ...
</code></pre>

    <p>特に興味深いのは、2003年以前(男子)・2010年以前(女子)だと、レギュラーシーズンのDetailedデータが存在しない点。</p>

    <pre><code>mens_df.columns
</code></pre>

    <p>上記のような列があり、それぞれ「W/L+要素名」という形式で記録されている。例えば、<code>WFGM</code> と <code>LFGM</code> は勝利チームと敗北チームのフィールドゴール成功数を表す。</p>

    <pre><code>prefix_dict = {
    'W': 'Winning Team',
    'L': 'Losing Team',
}
suffix_dict = {
    'FGM': 'Field goals made', 
    'FGA': 'Field goals attempted', 
    'FGM3': 'Three pointers made', 
    'FGA3': 'Three pointers attempted', 
    'FTM': 'Free throws made', 
    'FTA': 'Free throws attempted', 
    'OR': 'Offensive rebounds', 
    'DR': 'Defensive rebounds', 
    'Ast': 'Assists', 
    'TO': 'Turnovers committed', 
    'Stl': 'Steals', 
    'Blk': 'Blocks', 
    'PF': 'Personal fouls committed',
}

for gender in ['Mens', 'Womens']:
    ...
</code></pre>

    <p>上記コード例では、各要素について「勝利チーム - 敗北チーム」の差分を計算し、ヒストグラムを描画して分布を見ている。たとえばフィールドゴール成功数の差やターンオーバー数の差を比較することで、試合の特徴を把握できる。</p>

    <pre><code>fig, axes = plt.subplots(1, 2, figsize=(40, 20))
for i, gender in enumerate(['Mens', 'Womens']):
    ...
</code></pre>

    <p>このように、各チームがどの程度シュートを打ったか、オフェンスリバウンドを取れたか、ターンオーバーをどれくらいしたかなど、長期的な傾向を可視化できる。</p>
</section>
<section>
    <h2>goto_conversion 🥇🥈🥈🥉 winning solution</h2>
    <p><a href="https://www.kaggle.com/code/kaito510/goto-conversion-winning-solution"></a></p>
    <h3>概要</h3>
    <p>このソリューションは、2019年から2022年、そして2024年にわたってメダルを獲得するための鍵となったものである。特に2022年には金メダルも獲得した。</p>
    <p>このソリューションで使用する唯一のモデルは <em>goto_conversion</em> であり、使用しているデータは2024年まで利用できていた 538 のレーティング（2024年以降はペイウォールのため利用不可）だけである。そのため、ソリューションは非常にシンプルだが、リスクを取らない方法でも、メンズとウィメンズ両方の大会で毎年メダルを獲得できるほどの成績（2019年メンズ大会を除く）を挙げている。2019年メンズ大会でも、全参加者の85%より上に位置していたことが実験セクションの証拠からわかる。過度なフィッティングを避けるために、オッカムの剃刀を尊重してシンプルさを追求している。</p>
    <p>2024年大会においても、このソリューション単体でメダル獲得が可能だったが、大会の評価方法が大きく変わったにも関わらず、有効性が示された。実際、昨年の86位〜100位のリーダーボードスコアとこのソリューションのスコアを比べると、どちらも 0.06035 となっている。また、2024年に 538 のレーティングがペイウォール化されたため、昨年の提出に用いた確率行列は、<em>goto_conversion</em> を使ってベッティングオッズを確率に変換することで作成されている。これらは最初のコードブロックでインタラクティブに表示されており、CSVファイルとしても参照可能である。</p>
    <p>さらなる高精度を狙う場合、このソリューションをまるごと使うのではなく、複数の手法の一部として組み込むことを推奨する。実際、2024年には少なくとも金メダリスト2人（3位、4位）と銀メダリスト1人（38位）が、このソリューションを自身のソリューションに取り入れて成功したと公表している（一覧あり）。また、目標（例：金メダルか、あるいは何らかのメダル獲得か）によって戦略を変えるべきである点については、「What-If Leaderboard」セクションを参照せよ。</p>
    <p><em>goto_conversion</em> はもともと、ベッティングオッズを勝率に変換するためのライブラリとして設計されている。乗算ベース（逆数を正規化するだけ）の手法と比べて、このライブラリは「フェイバリット・ロングショット・バイアス（favourite-longshot bias）」を考慮しており、明らかに優位である。フェイバリット・ロングショット・バイアスとは、勝ちやすいイベントのオッズは期待損失が小さく、勝ちにくいイベントのオッズは期待損失が大きいという傾向のことである。Shin法やPower法などもこのバイアスを考慮しようとするが、<em>goto_conversion</em> のほうが高精度を発揮する。詳細は下記GitHubレポジトリにまとまっている。</p>
    <p><a href="https://github.com/gotoConversion/goto_conversion" target="_blank">https://github.com/gotoConversion/goto_conversion</a></p>
    <p>では、この「フェイバリット・ロングショット・バイアス」がなぜこのコンペに関係するのか。それは、538 のレーティングがレギュラーシーズンのデータからチームの強さを測定していることにある。強豪チームは、レギュラーシーズン中に主力選手を休ませたり、力を入れない“ガーベージ”な試合・時間帯があり、実際の最大パフォーマンスが数値化されにくいという問題がある。対戦相手の質を調整しても、March Madness のような本気度の高い試合では、より強いチームはレギュラーシーズン以上に支配的な成績を収める可能性が高いのである。これは、乗算ベースの変換を用いると強豪チームの勝率を過小評価するという、フェイバリット・ロングショット・バイアスと同型の問題である。</p>
    <p>例えば、2回戦で A チームと B チームが対戦する場合を考える。この試合の勝率を求めるにあたり、</p>
    <pre><code>P(Team A wins 2nd round match) = P(Team A reaching 3rd round) / P(Team A reaching 2nd round)
P(Team B wins 2nd round match) = P(Team B reaching 3rd round) / P(Team B reaching 2nd round)
</code></pre>
    <p>という計算をすると、<code>P(Team A wins 2nd round match)</code> と <code>P(Team B wins 2nd round match)</code> の合計が1にならない。これが問題の根本である。そこで、<em>goto_conversion</em> を使って「トーナメント進出確率」から「対戦勝率」へ変換し、それぞれの勝率和が1になるように補正する必要がある。</p>
    <pre><code>goto_conversion([1/P(Team A wins 2nd round match), 1/P(Team B wins 2nd round match)])
= [P(Team A beats Team B), P(Team B beats Team A)]
</code></pre>
    <p>乗算ベースの変換を使うと、強豪チーム（勝ちやすいチーム）の勝率が過小評価されるというフェイバリット・ロングショット・バイアスに陥りやすい。</p>
    <p>なお、<a href="https://fivethirtyeight.com/features/how-our-march-madness-predictions-work-2/" target="_blank">このリンク先</a>によれば、538自身も「March Madness はレギュラーシーズンよりもアップセット（番狂わせ）が起こりにくい」という傾向を発見している。これは、March Madness のほうが公正かつフェアな条件下で行われることが主な理由だと考えているようだ。</p>

    <h3>goto_conversion リポジトリから抽出した、538 スタイルの確率行列を表示</h3>
    <p><a href="https://github.com/gotoConversion/goto_conversion" target="_blank">https://github.com/gotoConversion/goto_conversion</a></p>
    <p>以下の行列は、<em>goto_conversion</em> を用いてベッティングオッズを勝率に変換した結果である。</p>
    <pre><code>import pandas as pd
import numpy as np
import plotly.express as px

class Percent(float):
    def __str__(self):
        return '{:.1%}'.format(self)

def get_heatMap(output_df, rounds_list, title):
    output_df = output_df.sort_values(by=output_df.columns.tolist()[-1], ascending=False)
    players_list = output_df.index.tolist()
    probabilities_npMatrix = [[Percent(e) for e in l] for l in output_df.values.tolist()]
    probabilitiesText_npMatrix = np.array(probabilities_npMatrix, dtype='str_')

    fig = px.imshow(probabilities_npMatrix, x=rounds_list, y=players_list, color_continuous_scale='Greens', aspect="auto", width=800, height=1600)
    fig.update_traces(text=probabilitiesText_npMatrix , texttemplate="%{text}")
    fig.update_xaxes(side="top")
    fig.update(layout_coloraxis_showscale=False)
    fig.update_layout(title=title)
    fig.show(renderer='iframe')
    
kaggleFolderPath = '/kaggle/input/march-machine-learning-mania-2025'
fivethirtyeightFolderPath = '/kaggle/input/538data'
#Display Mens Probability Matrix

mensProbabilities_df = pd.read_csv(fivethirtyeightFolderPath + '/mensProbabilitiesTable.csv', index_col = 'player') #source: https://github.com/gotoConversion/goto_conversion
mensProbabilities_df = mensProbabilities_df.drop('Elo_Rating', axis=1)
get_heatMap(mensProbabilities_df, rounds_list = ['Reach R2', 'Reach S16', 'Reach E8', 'Reach F4', 'Reach CG', 'Champion'], title = 'Mens March Madness 2024')

#Display Womens Probability Matrix

womensProbabilities_df = pd.read_csv(fivethirtyeightFolderPath + '/womensProbabilitiesTable.csv', index_col = 'player') #source: https://github.com/gotoConversion/goto_conversion
womensProbabilities_df = womensProbabilities_df.drop('Elo_Rating', axis=1)
get_heatMap(womensProbabilities_df, rounds_list = ['Reach R2', 'Reach S16', 'Reach E8', 'Reach F4', 'Reach CG', 'Champion'], title = 'Womens March Madness 2024')
</code></pre>

    <h3>実験</h3>
    <pre><code>#Install libraries

%pip install goto-conversion

#Load libraries

import goto_conversion
import math
import os
import statistics
import copy

#Import each year's 538 files before it went behind a paywall

both2019_df = pd.read_csv(fivethirtyeightFolderPath + '/fivethirtyeight_ncaa_forecasts (2).csv') #538 file for 2019
both2021_df = pd.read_csv(fivethirtyeightFolderPath + '/fivethirtyeight_ncaa_forecasts (3).csv') #538 file for 2021
both2022_df = pd.read_csv(fivethirtyeightFolderPath + '/fivethirtyeight_ncaa_forecasts (4).csv') #538 file for 2022
both2023_df = pd.read_csv(fivethirtyeightFolderPath + '/fivethirtyeight_ncaa_forecasts (5).csv') #538 file for 2023

#Import labels
mensLabels_df = pd.read_csv(kaggleFolderPath + '/MNCAATourneyDetailedResults.csv')
mensLabels_df = mensLabels_df.sort_values(by=['Season', 'DayNum']).reset_index(drop=True) #ensure ordering of labels to be safe (probably needless line)
womensLabels_df = pd.read_csv(kaggleFolderPath + '/WNCAATourneyDetailedResults.csv')
womensLabels_df = womensLabels_df.sort_values(by=['Season', 'DayNum']).reset_index(drop=True) #ensure ordering of labels to be safe (probably needless line)

#Import team spellings to TeamID map
mensTeamSpellings_df = pd.read_csv(kaggleFolderPath + '/MTeamSpellings.csv', encoding='cp1252')
womensTeamSpellings_df = pd.read_csv(kaggleFolderPath + '/WTeamSpellings.csv', encoding='cp1252')

#Compute head-to-head probabilities for all matches played in 2014 to 2022 for Mens
#and 2015 to 2022 for Womens

def get_round_from_index(i, year, gender):

    #Notice round 1 is the first four round,
    #round 2 is the round of 64 and so on.

    #Notice apart from 2022 and 2023,
    #Womens tournament did not have a first four round.

    if (gender == 'womens' and year < 2022): #no first four round
        return 2 + (i // 32) + (i // 48) + (i // 56) + (i // 60) + (i // 62) #e.g. last game of first round will be index 31, last game of tournament will be index 62
    else: #includes first four round
        if i <= 3: #first four round match
            return 1
        else:
            return 2 +  (i // 36) + (i // 52) + (i // 60) + (i // 64) + (i // 66)

def get_tourneyProb_from_teamID(teamID, givenYear_tourneyProb_df, spellings_df, year):

    givenTeamID_spellings_list = spellings_df.loc[spellings_df['TeamID'] == teamID,'TeamNameSpelling'].tolist()
    givenTeamID_tourneyProb_row = givenYear_tourneyProb_df.loc[[x in givenTeamID_spellings_list for x in givenYear_tourneyProb_df['team_name'].str.lower().tolist()]]

    return givenTeamID_tourneyProb_row

def preprocessed_goto_conversion(listOfOdds, total = 1):
    listOfProbabilities = [1/x for x in listOfOdds]
    isProbSumBelowTotal = sum(listOfProbabilities) < total
    if isProbSumBelowTotal: #input to goto_conversion must be odds where sum of inverse odds exceeds or equals 1
        reversedListOfOdds = [1/(1-x) for x in listOfProbabilities] #unfair odds of losing
        reversedListOfProbabilities = goto_conversion.goto_conversion(reversedListOfOdds, multiplicativeIfUnprudentOdds = True) #convert the unfair odds of losing to fair probabilities of losing
        outputListOfProbabilities = [1-x for x in reversedListOfProbabilities] #convert fair probabilities of losing to fair probabilities of winning
    else:
        outputListOfProbabilities = goto_conversion.goto_conversion(listOfOdds, multiplicativeIfUnprudentOdds = True)
    return outputListOfProbabilities

def convert_tourneyProb_to_h2hProb(tourneyProb_df, labels_df, spellings_df, year, gender):

    givenYear_labels_df = labels_df.loc[labels_df['Season'] == year]
    correctProbs_list = []

    if year >= 2016: #new format of 538 file from 2016 onwards
        givenYear_tourneyProb_df = tourneyProb_df.loc[tourneyProb_df['gender'] == gender,:]
    else:
        givenYear_tourneyProb_df = tourneyProb_df

    for i in range(givenYear_labels_df.shape[0]):

        tourneyMatch_row = givenYear_labels_df.iloc[i,:]
        tourneyMatch_round = get_round_from_index(i, year, gender)

        wteam_id = tourneyMatch_row['WTeamID']
        lteam_id = tourneyMatch_row['LTeamID']

        wteam_tourneyProb_row = get_tourneyProb_from_teamID(wteam_id, givenYear_tourneyProb_df, spellings_df, year)
        lteam_tourneyProb_row = get_tourneyProb_from_teamID(lteam_id, givenYear_tourneyProb_df, spellings_df, year)

        isMoreThanOneRow = year >= 2016
        if isMoreThanOneRow:

            wteam_firstMatchDay = min(wteam_tourneyProb_row['forecast_date'].tolist())
            lteam_firstMatchDay = min(lteam_tourneyProb_row['forecast_date'].tolist())

            wteam_tourneyProb_row = wteam_tourneyProb_row.loc[wteam_tourneyProb_row['forecast_date'] == wteam_firstMatchDay,:]
            lteam_tourneyProb_row = lteam_tourneyProb_row.loc[lteam_tourneyProb_row['forecast_date'] == lteam_firstMatchDay,:]

            if i == 0:
                print('Key error check to ensure leakage is prevented:')
                display(wteam_tourneyProb_row)
                display(lteam_tourneyProb_row)

        if tourneyMatch_round == 1:
            wteam_winGivenReach_prob = wteam_tourneyProb_row['rd' + str(tourneyMatch_round) + '_win'].values[0]
            lteam_winGivenReach_prob = lteam_tourneyProb_row['rd' + str(tourneyMatch_round) + '_win'].values[0]
        else:
            wteam_winGivenReach_prob = wteam_tourneyProb_row['rd' + str(tourneyMatch_round) + '_win'].values[0] / wteam_tourneyProb_row['rd' + str(tourneyMatch_round - 1) + '_win'].values[0]
            lteam_winGivenReach_prob = lteam_tourneyProb_row['rd' + str(tourneyMatch_round) + '_win'].values[0] / lteam_tourneyProb_row['rd' + str(tourneyMatch_round - 1) + '_win'].values[0]

        convertedProbs = preprocessed_goto_conversion([1/wteam_winGivenReach_prob, 1/lteam_winGivenReach_prob])
        correctProbs_list.append(convertedProbs[0])

    return correctProbs_list


#2022
mens2022_correctProbs_list = convert_tourneyProb_to_h2hProb(both2022_df, mensLabels_df, mensTeamSpellings_df, year = 2022, gender = 'mens')
womens2022_correctProbs_list = convert_tourneyProb_to_h2hProb(both2022_df, womensLabels_df, womensTeamSpellings_df, year = 2022, gender = 'womens')

#2021
mens2021_correctProbs_list = convert_tourneyProb_to_h2hProb(both2021_df, mensLabels_df, mensTeamSpellings_df, year = 2021, gender = 'mens')
womens2021_correctProbs_list = convert_tourneyProb_to_h2hProb(both2021_df, womensLabels_df, womensTeamSpellings_df, year = 2021, gender = 'womens')

#2019
mens2019_correctProbs_list = convert_tourneyProb_to_h2hProb(both2019_df, mensLabels_df, mensTeamSpellings_df, year = 2019, gender = 'mens')
womens2019_correctProbs_list = convert_tourneyProb_to_h2hProb(both2019_df, womensLabels_df, womensTeamSpellings_df, year = 2019, gender = 'womens')

print('='*50)
</code></pre>

    <pre><code>Key error check to ensure leakage is prevented:
gender	forecast_date	playin_flag	rd1_win	rd2_win	rd3_win	rd4_win	rd5_win	rd6_win	rd7_win	results_to	team_alive	team_id	team_name	team_rating	team_region	team_seed	team_slot
777	mens	2022-03-13	1	0.754715	0.300936	0.087731	0.042307	0.014924	0.004484	0.001805	0	1	84	Indiana	82.98	East	12b	43
gender	forecast_date	playin_flag	rd1_win	rd2_win	rd3_win	rd4_win	rd5_win	rd6_win	rd7_win	results_to	team_alive	team_id	team_name	team_rating	team_region	team_seed	team_slot
799	mens	2022-03-13	1	0.245285	0.075549	0.017249	0.005429	0.001224	0.000257	0.000077	0	1	2751	Wyoming	78.52	East	12a	42
Key error check to ensure leakage is prevented:
gender	forecast_date	playin_flag	rd1_win	rd2_win	rd3_win	rd4_win	rd5_win	rd6_win	rd7_win	results_to	team_alive	team_id	team_name	team_rating	team_region	team_seed	team_slot
1608	womens	2022-03-13	1	0.490711	0.182845	0.025318	0.006436	0.000326	0.000063	0.000009	0	1	2168	Dayton	80.91	Greensboro	11a	18
gender	forecast_date	playin_flag	rd1_win	rd2_win	rd3_win	rd4_win	rd5_win	rd6_win	rd7_win	results_to	team_alive	team_id	team_name	team_rating	team_region	team_seed	team_slot
1609	womens	2022-03-13	1	0.509289	0.193621	0.027463	0.00625	0.000276	0.000056	0.000008	0	1	305	DePaul	80.54	Greensboro	11b	19
Key error check to ensure leakage is prevented:
gender	forecast_date	playin_flag	rd1_win	rd2_win	rd3_win	rd4_win	rd5_win	rd6_win	rd7_win	results_to	team_alive	team_id	team_name	team_rating	team_region	team_seed	team_slot
731	mens	2021-03-14	1	0.399489	0.093369	0.03908	0.00831	0.001123	0.000348	0.000082	0	1	2181	Drake	77.58	West	11a	18
gender	forecast_date	playin_flag	rd1_win	rd2_win	rd3_win	rd4_win	rd5_win	rd6_win	rd7_win	results_to	team_alive	team_id	team_name	team_rating	team_region	team_seed	team_slot
725	mens	2021-03-14	1	0.600511	0.178177	0.08713	0.022539	0.003722	0.001349	0.00037	0	1	2724	Wichita State	79.9	West	11b	19
Key error check to ensure leakage is prevented:
gender	forecast_date	playin_flag	rd1_win	rd2_win	rd3_win	rd4_win	rd5_win	rd6_win	rd7_win	results_to	team_alive	team_id	team_name	team_rating	team_region	team_seed	team_slot
1327	womens	2021-03-14	0	1.0	0.994782	0.908748	0.779738	0.349553	0.252095	0.106927	1	1	239	Baylor	101.12	River Walk	2	124
gender	forecast_date	playin_flag	rd1_win	rd2_win	rd3_win	rd4_win	rd5_win	rd6_win	rd7_win	results_to	team_alive	team_id	team_name	team_rating	team_region	team_seed	team_slot
1382	womens	2021-03-14	0	1.0	0.005218	0.00054	0.000045	8.583790e-07	4.701400e-08	9.620000e-10	1	1	2296	Jackson State	68.54	River Walk	15	126
Key error check to ensure leakage is prevented:
gender	forecast_date	playin_flag	rd1_win	rd2_win	rd3_win	rd4_win	rd5_win	rd6_win	rd7_win	results_to	team_alive	team_id	team_name	team_rating	team_region	team_seed	team_slot
790	mens	2019-03-17	1	0.575381	0.216725	0.088893	0.021065	0.003717	0.000991	0.000279	0	1	2057	Belmont	80.67	East	11a	18
gender	forecast_date	playin_flag	rd1_win	rd2_win	rd3_win	rd4_win	rd5_win	rd6_win	rd7_win	results_to	team_alive	team_id	team_name	team_rating	team_region	team_seed	team_slot
795	mens	2019-03-17	1	0.424619	0.136819	0.049522	0.012512	0.002353	0.000542	0.000134	0	1	218	Temple	79.39	East	11b	19
Key error check to ensure leakage is prevented:
gender	forecast_date	playin_flag	rd1_win	rd2_win	rd3_win	rd4_win	rd5_win	rd6_win	rd7_win	results_to	team_alive	team_id	team_name	team_rating	team_region	team_seed	team_slot
1413	womens	2019-03-17	0	1.0	0.688352	0.255351	0.041718	0.008579	0.001428	0.000185	1	1	9	Arizona State	88.31	Portland	5	40
gender	forecast_date	playin_flag	rd1_win	rd2_win	rd3_win	rd4_win	rd5_win	rd6_win	rd7_win	results_to	team_alive	team_id	team_name	team_rating	team_region	team_seed	team_slot
1432	womens	2019-03-17	0	1.0	0.311648	0.073067	0.00342	0.000248	0.000029	0.000003	1	1	2116	Central Florida	79.89	Portland	12	42
==================================================
</code></pre>

    <p><strong>2022年メンズ大会でのノーリスク戦略によるブロンズ（63位相当）の証拠:</strong></p>
    <pre><code>#Measure 2022 mens comp score
#Leaderboard: https://www.kaggle.com/competitions/mens-march-mania-2022/leaderboard
#code below is a copy and paste so the logic behind the output score can be viewed without scrolling

logloss = []
for i in range(len(mens2022_correctProbs_list)):
    if i >= 4: #exclude first four matches
        logloss.append(math.log(mens2022_correctProbs_list[i]))
scoreWith01Boost = abs(statistics.mean(logloss) - math.log(0.5)/len(logloss)) #score with 0-1 strategy but no risks
print(scoreWith01Boost)
print('='*50)
</code></pre>
    <pre><code>0.6064976407396272
==================================================
</code></pre>

    <p><strong>2022年ウィメンズ大会でのノーリスク戦略によるブロンズ（58位相当）の証拠:</strong></p>
    <pre><code>#Measure 2022 womens comp score
#Leaderboard: https://www.kaggle.com/competitions/womens-march-mania-2022/leaderboard
#code below is a copy and paste so the logic behind the output score can be viewed without scrolling

logloss = []
for i in range(len(womens2022_correctProbs_list)):
    if i >= 4: #exclude first four matches
        logloss.append(math.log(womens2022_correctProbs_list[i]))
scoreWith01Boost = abs(statistics.mean(logloss) - math.log(0.5)/len(logloss)) #score with 0-1 strategy but no risks
print(scoreWith01Boost)
print('='*50)
</code></pre>
    <pre><code>0.42749291920371985
==================================================
</code></pre>

    <p><strong>2021年メンズ大会でのノーリスク戦略によるブロンズ（63位相当）の証拠:</strong></p>
    <pre><code>#Measure 2021 mens comp score
#Leaderboard: https://www.kaggle.com/competitions/ncaam-march-mania-2021/leaderboard
#code below is a copy and paste so the logic behind the output score can be viewed without scrolling

logloss = []
for i in range(len(mens2021_correctProbs_list)):
    if i >= 4: #exclude first four matches
        logloss.append(math.log(mens2021_correctProbs_list[i]))
scoreWith01Boost = abs(statistics.mean(logloss) - math.log(0.5)/len(logloss)) #score with 0-1 strategy but no risks
print(scoreWith01Boost)
print('='*50)
</code></pre>
    <pre><code>0.5930164132974177
==================================================
</code></pre>

    <p><strong>2021年ウィメンズ大会でのノーリスク戦略によるシルバー（11位相当）の証拠:</strong></p>
    <pre><code>#Measure 2021 womens comp score
#Leaderboard: https://www.kaggle.com/competitions/ncaaw-march-mania-2021/leaderboard
#code below is a copy and paste so the logic behind the output score can be viewed without scrolling

logloss = []
for i in range(len(womens2021_correctProbs_list)):
    logloss.append(math.log(womens2021_correctProbs_list[i]))
scoreWith01Boost = abs(statistics.mean(logloss) - math.log(0.5)/len(logloss)) #score with 0-1 strategy but no risks
print(scoreWith01Boost)
print('='*50)
</code></pre>
    <pre><code>0.40810687012546154
==================================================
</code></pre>

    <p><strong>2019年メンズ大会でのノーリスク戦略による上位15%（126位相当）の証拠:</strong></p>
    <pre><code>#Measure 2019 mens comp score
#Leaderboard: https://www.kaggle.com/competitions/mens-machine-learning-competition-2019/leaderboard
#code below is a copy and paste so the logic behind the output score can be viewed without scrolling

logloss = []
for i in range(len(mens2019_correctProbs_list)):
    if i >= 4: #exclude first four matches
        logloss.append(math.log(mens2019_correctProbs_list[i]))
scoreWith01Boost = abs(statistics.mean(logloss) - math.log(0.5)/len(logloss)) #score with 0-1 strategy but no risks
print(scoreWith01Boost)
print('='*50)
</code></pre>
    <pre><code>0.4645544313328942
==================================================
</code></pre>

    <p><strong>2019年ウィメンズ大会でのノーリスク戦略によるシルバー（22位相当）の証拠:</strong></p>
    <pre><code>#Measure 2019 womens comp score
#Leaderboard: https://www.kaggle.com/competitions/womens-machine-learning-competition-2019/leaderboard
#code below is a copy and paste so the logic behind the output score can be viewed without scrolling

logloss = []
for i in range(len(womens2019_correctProbs_list)):
    logloss.append(math.log(womens2019_correctProbs_list[i]))
scoreWith01Boost = abs(statistics.mean(logloss) - math.log(0.5)/len(logloss)) #score with 0-1 strategy but no risks
print(scoreWith01Boost)
print('='*50)
</code></pre>
    <pre><code>0.35257989400721657
==================================================
</code></pre>

    <h3>2023年のWhat-If Leaderboard</h3>
    <p>2023年は私がメダルを逃した唯一の年だった。しかし私は、リスクである「SDSU が男子決勝戦で UConn に勝利する」という仮定が当たっていれば金メダルを、リスクを取らなければブロンズメダルを獲得できていた。以下の What-If Leaderboard にその証拠が示されている。</p>
    <p>このセクションでは、そのリスク戦略が数値的・理論的に最適に近かったことを示す。他の過去金メダリストも「あと1試合当たっていれば金メダルだった」という似たようなエピソードを持ちうるだろう。</p>
    <pre><code>#Get Inputs
after125games_df = pd.read_csv('/kaggle/input/mwncaa-lb-raw/Leaderboard_History/march-machine-learning-mania-2023-publicleaderboard_62_63_1157_2023-04-03.csv')
after125games_df['SumScore'] = after125games_df['Score'] * 125

after126games_df = pd.read_csv('/kaggle/input/mwncaa-lb-raw/Leaderboard_History/march-machine-learning-mania-2023-publicleaderboard_63_63_0924_2023-04-04.csv')
after126games_df['SumScore'] = after126games_df['Score'] * 126

#Join Leaderboards
leaderboards_df = pd.merge(after125games_df, after126games_df, on='TeamId')
print('='*50)
print('TOP 10 OF 2023 ORIGINAL LEADERBOARD')
display(leaderboards_df.iloc[:10])

#Compute Leaderoard if Mens Championship Game was flipped
leaderboards_df['lastGameScore'] = leaderboards_df['SumScore_y'] - leaderboards_df['SumScore_x']
leaderboards_df['flippedLastGameScore'] = (1 - (leaderboards_df['lastGameScore'] ** 0.5)) ** 2
leaderboards_df['flippedLastGameLeaderboardScore'] = (leaderboards_df['SumScore_x'] + leaderboards_df['flippedLastGameScore'])/126
leaderboards_df = leaderboards_df.sort_values(by='flippedLastGameLeaderboardScore')
leaderboards_df = leaderboards_df.reset_index(drop=True)
print('='*50)
print('TOP 10 OF 2023 LEADERBOARD IF MENS CHAMPIONSHIP GAME WAS FLIPPED')
print('NOTICE kaito510 RANKS IN GOLD MEDAL ZONE (INSIDE TOP 10)')
print('THE FULL WHAT-IF LEADERBOARD IS AVAILABLE AS AN OUTPUT CSV FILE')
display(leaderboards_df.iloc[:10])
leaderboards_df.to_csv('WhatIfLeaderboard2023.csv', index_label='What-If Leaderboard Rank')
</code></pre>

    <pre><code>==================================================
TOP 10 OF 2023 ORIGINAL LEADERBOARD
TeamId	TeamName_x	SubmissionDate_x	Score_x	SumScore_x	TeamName_y	SubmissionDate_y	Score_y	SumScore_y
0	9989669	RustyB	2023-03-15 00:13:56	0.17365	21.70625	RustyB	2023-03-15 00:13:56	0.17371	21.88746
1	10057285	NicholasHilton	2023-03-16 14:57:18	0.17520	21.90000	NicholasHilton	2023-03-16 14:57:18	0.17557	22.12182
2	9961135	tihonby	2023-03-16 15:55:41	0.17521	21.90125	tihonby	2023-03-16 15:55:41	0.17525	22.08150
3	9963107	mbund1237	2023-03-16 09:47:48	0.17562	21.95250	mbund1237	2023-03-16 09:47:48	0.17619	22.19994
4	9960844	Matthias	2023-03-16 04:36:40	0.17580	21.97500	Matthias	2023-03-16 04:36:40	0.17522	22.07772
5	9906483	David Scott	2023-03-14 00:02:27	0.17662	22.07750	David Scott	2023-03-14 00:02:27	0.17651	22.24026
6	9956125	Jack Lichtenstein	2023-03-16 13:25:36	0.17780	22.22500	Jack Lichtenstein	2023-03-16 13:25:36	0.17704	22.30704
7	10032902	cjwh	2023-03-14 19:38:35	0.17815	22.26875	cjwh	2023-03-14 19:38:35	0.17800	22.42800
8	10042829	FNiemann	2023-03-15 23:27:02	0.17833	22.29125	FNiemann	2023-03-15 23:27:02	0.17854	22.49604
9	9998660	maze508	2023-03-16 15:19:26	0.17875	22.34375	maze508	2023-03-16 15:19:26	0.17843	22.48218
==================================================
TOP 10 OF 2023 LEADERBOARD IF MENS CHAMPIONSHIP GAME WAS FLIPPED
NOTICE kaito510 RANKS IN GOLD MEDAL ZONE (INSIDE TOP 10)
THE FULL WHAT-IF LEADERBOARD IS AVAILABLE AS AN OUTPUT CSV FILE
TeamId	TeamName_x	SubmissionDate_x	Score_x	SumScore_x	TeamName_y	SubmissionDate_y	Score_y	SumScore_y	lastGameScore	flippedLastGameScore	flippedLastGameLeaderboardScore
0	9989669	RustyB	2023-03-15 00:13:56	0.17365	21.70625	RustyB	2023-03-15 00:13:56	0.17371	21.88746	0.18121	3.298346e-01	0.174890
1	10057285	NicholasHilton	2023-03-16 14:57:18	0.17520	21.90000	NicholasHilton	2023-03-16 14:57:18	0.17557	22.12182	0.22182	2.798646e-01	0.176031
2	9963107	mbund1237	2023-03-16 09:47:48	0.17562	21.95250	mbund1237	2023-03-16 09:47:48	0.17619	22.19994	0.24744	2.525732e-01	0.176231
3	9961135	tihonby	2023-03-16 15:55:41	0.17521	21.90125	tihonby	2023-03-16 15:55:41	0.17525	22.08150	0.18025	3.311328e-01	0.176447
4	9906483	David Scott	2023-03-14 00:02:27	0.17662	22.07750	David Scott	2023-03-14 00:02:27	0.17651	22.24026	0.16276	3.558895e-01	0.178043
5	9960844	Matthias	2023-03-16 04:36:40	0.17580	21.97500	Matthias	2023-03-16 04:36:40	0.17522	22.07772	0.10272	4.617208e-01	0.178069
6	10042829	FNiemann	2023-03-15 23:27:02	0.17833	22.29125	FNiemann	2023-03-15 23:27:02	0.17854	22.49604	0.20479	2.997154e-01	0.179293
7	10032902	cjwh	2023-03-14 19:38:35	0.17815	22.26875	cjwh	2023-03-14 19:38:35	0.17800	22.42800	0.15925	3.611272e-01	0.179602
8	9956125	Jack Lichtenstein	2023-03-16 13:25:36	0.17780	22.22500	Jack Lichtenstein	2023-03-16 13:25:36	0.17704	22.30704	0.08204	5.091875e-01	0.180430
9	9898024	kaito510	2023-03-15 11:12:14	0.18188	22.73500	kaito510	2023-03-15 11:12:14	0.18837	23.73462	0.99962	3.610686e-08	0.180437
</code></pre>
    <p>この What-If Leaderboard は、「各参加者が提出可能な最大2回の提出のうち、125/126試合終了時点、126/126試合終了時点でどちらの提出をスコアとして採用したかが同じだった」という仮定のもとで算出されている。</p>
    <p>2023年の評価は Brier Score だった。以下に示すのは、Brier Scoreにおける単一試合のリスク戦略が最適化されるのは「33.3%の勝率を持つチームを勝つ方に賭けたとき」であるという数学的証明である。</p>
    <p>ある試合にリスクを取る場合の期待リターンを、</p>
    <pre><code>f(p) = p(1 - p)^2
</code></pre>
    <p>とし、ここで <code>p</code> は成功確率、<code>(1-p)^2</code> はリスク成功時のリワードに相当する。すると、導関数 <code>f'(p)</code> と <code>f''(p)</code> は以下のように表せる:</p>
    <pre><code>f'(p) = -2p + 2p^2 + (1-p)^2
f''(p) = -4 + 6p
</code></pre>
    <p>詳しい計算は省くが、<code>argmax_p f(p) = 1/3</code> となる。つまり、勝率約33.3%のチームにベットするのが最も期待リターンが高い。</p>

    <h3>提出</h3>
    <p>このセクションは「Selection Sunday」後、締切前に作成予定である。</p>
</section>
        
    </main>
</body>
</html>
